{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/images/StudyOfInterview/jcjtx.jpg","path":"images/StudyOfInterview/jcjtx.jpg","modified":0,"renderable":0},{"_id":"themes/hexo-theme-archer-master/source/assets/example_qr.png","path":"assets/example_qr.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-archer-master/source/avatar/Misaka.jpg","path":"avatar/Misaka.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-archer-master/source/assets/loading.svg","path":"assets/loading.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-archer-master/source/css/mobile.css","path":"css/mobile.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-archer-master/source/assets/tabris-weixin.png","path":"assets/tabris-weixin.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-archer-master/source/css/style.css","path":"css/style.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-archer-master/source/font/Source Sans Pro.woff2","path":"font/Source Sans Pro.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-archer-master/source/scripts/share.js","path":"scripts/share.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-archer-master/source/assets/favicon.ico","path":"assets/favicon.ico","modified":0,"renderable":1},{"_id":"themes/hexo-theme-archer-master/source/assets/tabris-qq.png","path":"assets/tabris-qq.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-archer-master/source/font/Oswald-Regular.ttf","path":"font/Oswald-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-archer-master/source/font/SourceCodePro-Regular.ttf.woff2","path":"font/SourceCodePro-Regular.ttf.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-archer-master/source/intro/404-bg.jpg","path":"intro/404-bg.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-archer-master/source/font/SourceCodePro-Regular.ttf.woff","path":"font/SourceCodePro-Regular.ttf.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-archer-master/source/scripts/main.js","path":"scripts/main.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-archer-master/source/font/Source Sans Pro.woff","path":"font/Source Sans Pro.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-archer-master/source/intro/post-bg.jpg","path":"intro/post-bg.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-archer-master/source/intro/zewg-yq.jpg","path":"intro/zewg-yq.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-archer-master/source/intro/about-bg.jpg","path":"intro/about-bg.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-archer-master/source/intro/jxjy-2B.jpg","path":"intro/jxjy-2B.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-archer-master/source/avatar/qiu.jpg","path":"avatar/qiu.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-archer-master/source/intro/index-bg.jpg","path":"intro/index-bg.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-archer-master/source/intro/dsgl.jpg","path":"intro/dsgl.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-archer-master/source/intro/jxjy-2B(2).jpg","path":"intro/jxjy-2B(2).jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"7ec239693239964d066c29cef55ae28e203bca5f","modified":1537693993018},{"_id":"themes/hexo-theme-archer-master/.gitignore","hash":"d734edbdd316a19eae0ac2421256ac60dd61a1f8","modified":1532001627517},{"_id":"themes/hexo-theme-archer-master/.eslintrc.json","hash":"f398447605f56aa0bb9e250f8df0651a1f79ac45","modified":1532001627516},{"_id":"themes/hexo-theme-archer-master/README.md","hash":"f18523f720bfdbead16453dd43a80292c739dbd8","modified":1532001627518},{"_id":"themes/hexo-theme-archer-master/_config.yml","hash":"a32cdc270cc86588f7488ffb613e29760a4eac35","modified":1532001627518},{"_id":"themes/hexo-theme-archer-master/package.json","hash":"9ca2cf9a37698bff53bce357bc64a55692a9a4e8","modified":1532001627544},{"_id":"themes/hexo-theme-archer-master/webpack.prod.js","hash":"b6d35f7e9a9718b3e5e3e17c52fcc5e7c38330b0","modified":1532001627611},{"_id":"themes/hexo-theme-archer-master/webpack.config.js","hash":"369feedf559c96614506523dbabe95206ef2d20c","modified":1532001627610},{"_id":"themes/hexo-theme-archer-master/LICENSE","hash":"35f4fb806270f8243459c870a2141e795dfab166","modified":1532001627517},{"_id":"themes/hexo-theme-archer-master/gulpfile.js","hash":"4425599995b6c818274f4a27067f484eaf357d05","modified":1532001627524},{"_id":"source/_posts/NotesOfPython.md","hash":"2da70b7a260424a7a40f15836bf69f1de235faf0","modified":1537689584822},{"_id":"source/_posts/GraduationProject.md","hash":"85bf946db8d1296433e87059950f7cf1077b1949","modified":1537689334598},{"_id":"source/_posts/ExperienceOfInterview.md","hash":"fe2fbb8d75e2306e34bedb9c3d4961d130ead3df","modified":1537689568604},{"_id":"source/about/about.md","hash":"d6a7fc165a2ffbd6dac64e33f0a4f2fc7f1228b7","modified":1537691677237},{"_id":"source/_posts/StudyOfGit.md","hash":"55040578848d44b4625cbde4d575f6025513e65c","modified":1537689597417},{"_id":"source/_posts/hello-world.md","hash":"4953d43846bb05472f30fe0e938dfe3dac5f6bfd","modified":1537689334630},{"_id":"themes/hexo-theme-archer-master/docs/README-en.md","hash":"58b6518bc0de951b6ee3bde9e7dd8fdd16ded003","modified":1532001627519},{"_id":"source/_posts/StudyLinux-arch.md","hash":"1e81922801dd85ceac76d6f3c456692015661e46","modified":1539533561785},{"_id":"themes/hexo-theme-archer-master/docs/develop-guide-en.md","hash":"8a544d8196d456cbae1de78ba01bd7530f9653b1","modified":1532001627520},{"_id":"themes/hexo-theme-archer-master/docs/develop-guide-zh.md","hash":"f20432b5b6453ad7f452b06d5adbfe558a15646f","modified":1532001627520},{"_id":"themes/hexo-theme-archer-master/layout/404.ejs","hash":"a054b4ea1147846bed4252dd56182cb8e32d95eb","modified":1532001627526},{"_id":"themes/hexo-theme-archer-master/layout/about.ejs","hash":"990df15653a99453617e72dfc195fa0a75b9a5d1","modified":1532001627539},{"_id":"source/_posts/ManualOfRegex.md","hash":"c7be4f5b4d3ad928db7a22403adf14a2101183fe","modified":1537689649258},{"_id":"source/_posts/StudyOfInterview.md","hash":"9ff97a8e0b11293ee9c6b41940253416e30ed9b6","modified":1537695463110},{"_id":"themes/hexo-theme-archer-master/layout/site-meta.ejs","hash":"28b014bc19e934e3b118064e32d68d8a32a6a682","modified":1532001627541},{"_id":"themes/hexo-theme-archer-master/layout/post.ejs","hash":"7399b459dcf103a7fcb264c0b75f3f9e5c86dec7","modified":1532001627540},{"_id":"source/images/StudyOfInterview/jcjtx.jpg","hash":"7bdc07ec710166e2b1949beeff9e21840d74b34b","modified":1537689466339},{"_id":"themes/hexo-theme-archer-master/layout/layout.ejs","hash":"51ff4c08e884337c19a2d849333a6d46922f1db8","modified":1532001627540},{"_id":"themes/hexo-theme-archer-master/layout/index.ejs","hash":"3fd60bc795a8153d35fb6047a64ed55c589f7cbd","modified":1532001627539},{"_id":"themes/hexo-theme-archer-master/layout/_partial/base-head.ejs","hash":"5cf97ec87976daa8747611b1da95396c312aba90","modified":1532001627528},{"_id":"themes/hexo-theme-archer-master/layout/_partial/base-profile.ejs","hash":"dcf88c81a85232f8298c5327673da7147214a677","modified":1532001627529},{"_id":"themes/hexo-theme-archer-master/layout/_partial/base-header.ejs","hash":"af76b1a18a63934e83b078bf5f9f886e972a0ceb","modified":1532001627528},{"_id":"themes/hexo-theme-archer-master/layout/_partial/base-footer.ejs","hash":"92da263076aa7c54b9b651d744b7261a2df39072","modified":1532001627527},{"_id":"themes/hexo-theme-archer-master/layout/_partial/base-background-image.ejs","hash":"85cb8af231248188124dc9aa793a7f8318608d6d","modified":1532001627527},{"_id":"themes/hexo-theme-archer-master/layout/_partial/base-share.ejs","hash":"593398145ff712f3c01fff9fe2d2b38bfa8bb20b","modified":1532001627529},{"_id":"themes/hexo-theme-archer-master/layout/_partial/base-title-tags.ejs","hash":"0b8cbfeeb0d57eea6a6ef5d5232c54ce2082490f","modified":1532001627530},{"_id":"themes/hexo-theme-archer-master/layout/_partial/base-social.ejs","hash":"92ac580acc20bde7b3345bfe132671b9043bfbd6","modified":1532001627530},{"_id":"themes/hexo-theme-archer-master/src/scss/_normalize.scss","hash":"9123aa118cc636b4bfe718b87274d0b9732d8e89","modified":1532001627600},{"_id":"themes/hexo-theme-archer-master/layout/_partial/intro-height.ejs","hash":"fc03729825ac7ffd4045f910bbd936bc5841c65e","modified":1532001627535},{"_id":"themes/hexo-theme-archer-master/src/scss/_variables.scss","hash":"d5aaaa885977ed1424851da99e277bb61e3727f3","modified":1532001627609},{"_id":"themes/hexo-theme-archer-master/src/scss/_mixin.scss","hash":"728e06c7d9713fcc610ab0133e60778fb1d9a8c0","modified":1532001627600},{"_id":"themes/hexo-theme-archer-master/src/scss/_common.scss","hash":"3ee1d0fa5d22a9ba8634aa6e7580c061888ef13b","modified":1532001627599},{"_id":"themes/hexo-theme-archer-master/src/scss/style.scss","hash":"ff391096622b1f3e1f44aea92c78c1a336a21b2f","modified":1532001627610},{"_id":"themes/hexo-theme-archer-master/src/js/initSidebar.js","hash":"d94a9da296c56e9b75def4386849df2b3b80e982","modified":1532001627592},{"_id":"themes/hexo-theme-archer-master/src/scss/mobile.scss","hash":"4e454f976cb1796a7848c855b4a8e17baa8d13ba","modified":1532001627610},{"_id":"themes/hexo-theme-archer-master/src/js/browser.js","hash":"6e98eacb585fc24fe1f14e80dcb8d3b7d1b463fb","modified":1532001627592},{"_id":"themes/hexo-theme-archer-master/src/js/scroll.js","hash":"149f251f6ae1a319eecfc903ece61b9a6f4bede4","modified":1532001627596},{"_id":"themes/hexo-theme-archer-master/src/js/share.js","hash":"0c0ccd800e063bda901b99e5bfbe96c72723e5ba","modified":1532001627596},{"_id":"themes/hexo-theme-archer-master/src/js/mobile.js","hash":"27b974d628a94f5abd700ca7757bcd153d866442","modified":1532001627595},{"_id":"themes/hexo-theme-archer-master/src/js/main.js","hash":"422a17051ba25886e383e1bc0f6e873819931e90","modified":1532001627594},{"_id":"themes/hexo-theme-archer-master/src/js/init.js","hash":"10e15d24e0665fca92b228471eddfeed9e942a31","modified":1532001627592},{"_id":"themes/hexo-theme-archer-master/src/js/toc.js","hash":"874acd62f4be465008baeee08cc38bcce308ef98","modified":1532001627598},{"_id":"themes/hexo-theme-archer-master/src/js/sidebar.js","hash":"a90865aefc0f933d391c297ebf06960ac322af34","modified":1532001627597},{"_id":"themes/hexo-theme-archer-master/src/js/tag.js","hash":"b220a7ed370e8b6258df2bdef027ada5673c4b66","modified":1532001627597},{"_id":"themes/hexo-theme-archer-master/src/js/util.js","hash":"da642e9e6b50ef56a6f85dab85d19b087e4ba373","modified":1532001627598},{"_id":"themes/hexo-theme-archer-master/source/assets/example_qr.png","hash":"cce20432c34875f4d9c6df927ede0fc0f00bb194","modified":1532001627546},{"_id":"themes/hexo-theme-archer-master/source/avatar/Misaka.jpg","hash":"74a0372523f98dfbba992bf80642e160d04dc9b1","modified":1532001627551},{"_id":"themes/hexo-theme-archer-master/source/assets/loading.svg","hash":"85082b002bae1335114b71550350907884187e38","modified":1532001627547},{"_id":"themes/hexo-theme-archer-master/source/css/mobile.css","hash":"dc1fef5067bce18e53b0ab43bf6a9864133a8ac9","modified":1532001627555},{"_id":"themes/hexo-theme-archer-master/source/assets/tabris-weixin.png","hash":"c61f80f69022eb92eca730050b85e898a1551ba4","modified":1532001627550},{"_id":"themes/hexo-theme-archer-master/source/css/style.css","hash":"d8d19d9f326dbaecea6bbbd026876df8df6ab317","modified":1532001627555},{"_id":"themes/hexo-theme-archer-master/source/font/Source Sans Pro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1532001627560},{"_id":"themes/hexo-theme-archer-master/source/scripts/share.js","hash":"0b5db87fbf926e0b1962145d86ee9d5c7e64c44e","modified":1532001627591},{"_id":"themes/hexo-theme-archer-master/layout/_partial/comment/custom.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1532001627531},{"_id":"themes/hexo-theme-archer-master/source/assets/favicon.ico","hash":"1b763e30815a4bda405022bbec6af6f4ca4c77d4","modified":1532001627547},{"_id":"themes/hexo-theme-archer-master/source/assets/tabris-qq.png","hash":"b321c2f17980aefd846e6e73105e34ce413bd7c9","modified":1532001627549},{"_id":"themes/hexo-theme-archer-master/source/font/Oswald-Regular.ttf","hash":"965d729546a43a8490ad4cf33c25ac475682100c","modified":1532001627558},{"_id":"themes/hexo-theme-archer-master/source/font/SourceCodePro-Regular.ttf.woff2","hash":"f5991289ec17884cb641da0646d278d36702a190","modified":1532001627562},{"_id":"themes/hexo-theme-archer-master/source/intro/404-bg.jpg","hash":"3afb5bb26f4ff0bd0e0a28df955c8aa7d746d3c5","modified":1532001627564},{"_id":"themes/hexo-theme-archer-master/source/font/SourceCodePro-Regular.ttf.woff","hash":"12eef75e1ad3eca9dae42b65505010ce4464a315","modified":1532001627561},{"_id":"themes/hexo-theme-archer-master/source/scripts/main.js","hash":"3a813e43a2f35b40c06570f5203a0127a4a7e503","modified":1532001627590},{"_id":"themes/hexo-theme-archer-master/layout/_partial/comment/changyan.ejs","hash":"60189b4c02a1b886ecfdc758c55c9a24fa7d36af","modified":1532001627531},{"_id":"themes/hexo-theme-archer-master/layout/_partial/comment/disqus.ejs","hash":"cfdb15116abe89f4b54f7bb18a0b23a597c47a60","modified":1532001627532},{"_id":"themes/hexo-theme-archer-master/layout/_partial/comment/gitment.ejs","hash":"c043a98e33252b9a628bfd31c4a3b2883dce2b99","modified":1532001627533},{"_id":"themes/hexo-theme-archer-master/layout/_partial/comment/livere.ejs","hash":"a6acb5d7778ade98ba5b6932e38a585460513f49","modified":1532001627533},{"_id":"themes/hexo-theme-archer-master/layout/_partial/comment/youyan.ejs","hash":"483c07212879b116b772f428547c9962be96d2ce","modified":1532001627534},{"_id":"themes/hexo-theme-archer-master/layout/_partial/critical-css/critical-style.ejs","hash":"272a416b929c81cec0d682c6679be670cf5745d5","modified":1532001627534},{"_id":"themes/hexo-theme-archer-master/layout/_partial/script/font-loader.ejs","hash":"0181560515ef12c6a8f33cbf2bd6d5807d0ebd48","modified":1532001627536},{"_id":"themes/hexo-theme-archer-master/source/font/Source Sans Pro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1532001627559},{"_id":"themes/hexo-theme-archer-master/layout/_partial/sidebar/sidebar-categories.ejs","hash":"4feb7c3d17a3c8994eb095d43d75fbd0f1ed5b4f","modified":1532001627538},{"_id":"themes/hexo-theme-archer-master/src/scss/_partial/_404.scss","hash":"10258d5ac3124bca5d87efbb519e1493b99ffc6d","modified":1532001627601},{"_id":"themes/hexo-theme-archer-master/layout/_partial/sidebar/sidebar-tags.ejs","hash":"e96750b1aa7113322696857882b1e1fde11c1fc4","modified":1532001627539},{"_id":"themes/hexo-theme-archer-master/layout/_partial/sidebar/sidebar-archives.ejs","hash":"237a1b8002661065407a6bf96c3188eb09597525","modified":1532001627537},{"_id":"themes/hexo-theme-archer-master/layout/_partial/sidebar/base-sidebar.ejs","hash":"c5ce643a06a2103aa4ac0d8279c024f90886d37f","modified":1532001627537},{"_id":"themes/hexo-theme-archer-master/package-lock.json","hash":"3222a22ce66d166f389bd5bd453b2d8450cf77bb","modified":1532001627544},{"_id":"themes/hexo-theme-archer-master/docs/snap.png","hash":"0b2a8bf016f6eed576abfdcdb7dcf8de51c12562","modified":1532001627524},{"_id":"themes/hexo-theme-archer-master/src/scss/_partial/_index-page.scss","hash":"eeb2aa6eaa2f6d8a9ce978757ca12fd34b384090","modified":1532001627601},{"_id":"themes/hexo-theme-archer-master/source/intro/post-bg.jpg","hash":"525fafb2238c27754d8fa751f143ff1de9b8482d","modified":1532001627586},{"_id":"themes/hexo-theme-archer-master/source/intro/zewg-yq.jpg","hash":"b0baaf877d56f2aff6ab1a604bb2b8e6c1b935a9","modified":1532001627589},{"_id":"themes/hexo-theme-archer-master/src/scss/_partial/_post-page.scss","hash":"cf9dd525e0821367dafffcc49e4114f8259da5e7","modified":1532001627606},{"_id":"themes/hexo-theme-archer-master/source/intro/about-bg.jpg","hash":"ab388276822417cc4e703312c14e20280ec783b3","modified":1532001627567},{"_id":"themes/hexo-theme-archer-master/source/intro/jxjy-2B.jpg","hash":"2e67fe4b28895153244fc7f1d169d9b56f9aeeae","modified":1532001627584},{"_id":"themes/hexo-theme-archer-master/src/scss/_partial/_partial/_paginator.scss","hash":"ad14edda32d4e3f05819eda783db321402d37356","modified":1532001627603},{"_id":"themes/hexo-theme-archer-master/src/scss/_partial/_post/_code.scss","hash":"de5c3a3ea73d89432ef5705c5e751678cb1f7fd8","modified":1532001627607},{"_id":"themes/hexo-theme-archer-master/src/scss/_partial/_partial/_intro.scss","hash":"690f6188fdf0113b0ce6d28a97b872ce0f52f792","modified":1532001627603},{"_id":"themes/hexo-theme-archer-master/src/scss/_partial/_partial/_header.scss","hash":"44d42f7ac3c85e4d2d61e263f490c188e6097129","modified":1532001627602},{"_id":"themes/hexo-theme-archer-master/src/scss/_partial/_partial/_footer.scss","hash":"63506ad7c806cb2cdba5cae4b66a744e5efb97be","modified":1532001627602},{"_id":"themes/hexo-theme-archer-master/src/scss/_partial/_partial/_scrollbar.scss","hash":"eabe9fd56908ce595eedc90bb211412aba5d433c","modified":1532001627605},{"_id":"themes/hexo-theme-archer-master/src/scss/_partial/_partial/_profile.scss","hash":"e88fa63587af0ee490591ff5e8953c8e875dcfd6","modified":1532001627605},{"_id":"themes/hexo-theme-archer-master/src/scss/_partial/_sidebar/_sidebar.scss","hash":"af7f24c389f61e8722a3dd4eb6a4ea0f4b54d654","modified":1532001627609},{"_id":"themes/hexo-theme-archer-master/src/scss/_partial/_sidebar/_sidebar-tags.scss","hash":"ff4e9e3f2eaeb7eb3071a666cdfa61eabad92e3c","modified":1532001627608},{"_id":"themes/hexo-theme-archer-master/src/scss/_partial/_sidebar/_sidebar-archive.scss","hash":"93cd6d629472a409199ebe432380261ab0973dca","modified":1532001627607},{"_id":"themes/hexo-theme-archer-master/source/avatar/qiu.jpg","hash":"2f5c6b674b2d5ec8a1904c4bba2abbd9ba29cdd8","modified":1532001627553},{"_id":"themes/hexo-theme-archer-master/source/intro/index-bg.jpg","hash":"96b52e177b8bc53e64ec6ee1e10b2b6a4e13083b","modified":1532001627572},{"_id":"themes/hexo-theme-archer-master/source/intro/dsgl.jpg","hash":"8661bca46fa1440a77ab4179a3087511bcbc7554","modified":1532001627569},{"_id":"themes/hexo-theme-archer-master/source/intro/jxjy-2B(2).jpg","hash":"78252a9305c7f8b455ba21ca31f4a49cc1b0c16b","modified":1532001627581},{"_id":"public/about/about.html","hash":"556111bdc67aff1ea135cc80643a50badbf9e6ab","modified":1541070866718},{"_id":"public/2018/09/23/StudyLinux-arch/index.html","hash":"66d92c809ff46a70fac5c2a50d659edb6a65c27f","modified":1541070866719},{"_id":"public/2018/09/23/GraduationProject/index.html","hash":"d298d8c6884829acf04cf1de5932c43822cb893b","modified":1541070866720},{"_id":"public/2018/03/17/ManualOfRegex/index.html","hash":"67f8b53314b5a440f4621d4f2d40d200e3adad00","modified":1541070866720},{"_id":"public/2018/03/07/NotesOfPython/index.html","hash":"927c1ff61dd05b36620adbd2a0e8fcbcb161c0b5","modified":1541070866720},{"_id":"public/2018/01/31/ExperienceOfInterview/index.html","hash":"47e650adf25c2496138d67d6030de18f9bb6fa22","modified":1541070866720},{"_id":"public/2018/01/29/StudyOfInterview/index.html","hash":"41b2a2ba33cfb26ea709ba2336a9f756ba265a18","modified":1541070866721},{"_id":"public/2018/01/25/hello-world/index.html","hash":"83f375ca98938235cf5f4838079a863a8245242e","modified":1541070866721},{"_id":"public/2017/04/25/StudyOfGit/index.html","hash":"da69d988d67f237399e37a52fe44e5ecd11e58f1","modified":1541070866721},{"_id":"public/archives/index.html","hash":"f800fb3d5ac8f4ee9785d606aa716229a9635d95","modified":1541070866722},{"_id":"public/archives/2017/index.html","hash":"cc924b239cf878a03adfc848a421431c602b40de","modified":1541070866722},{"_id":"public/archives/2017/04/index.html","hash":"cc924b239cf878a03adfc848a421431c602b40de","modified":1541070866722},{"_id":"public/archives/2018/index.html","hash":"957bf1302c6807285271c6c15af4b0c79119f5f5","modified":1541070866722},{"_id":"public/archives/2018/01/index.html","hash":"6d54fbe194ce3cb2b5ccd38eaa5553dc6c860896","modified":1541070866722},{"_id":"public/archives/2018/03/index.html","hash":"29655b4f90f7568026f4ebed8223416c335b5cfb","modified":1541070866722},{"_id":"public/archives/2018/09/index.html","hash":"5eef3f63f82a6897cafa1ae36717f82cdf127ef0","modified":1541070866722},{"_id":"public/tags/毕业设计/index.html","hash":"fb75e897c4f110c0da3af0f13724285038175a6c","modified":1541070866722},{"_id":"public/tags/git/index.html","hash":"cc924b239cf878a03adfc848a421431c602b40de","modified":1541070866722},{"_id":"public/tags/随笔/index.html","hash":"bee4b3c13783430922d49405c29ba708503ad369","modified":1541070866722},{"_id":"public/tags/linux/index.html","hash":"e8c9522c3f688b3c804b7e290fc11ae5b918abe7","modified":1541070866723},{"_id":"public/tags/正则表达式/index.html","hash":"5f38c732a7588344b426c7801c0b7b83c9d3caf6","modified":1541070866723},{"_id":"public/tags/面试/index.html","hash":"133f5cdf8512d0c558cc3efc5c44c358f1eb97e2","modified":1541070866723},{"_id":"public/tags/C/index.html","hash":"133f5cdf8512d0c558cc3efc5c44c358f1eb97e2","modified":1541070866723},{"_id":"public/tags/数据库/index.html","hash":"a6dff9e6829d39b1c7809e3c6dd87321bba461ae","modified":1541070866723},{"_id":"public/tags/操作系统/index.html","hash":"133f5cdf8512d0c558cc3efc5c44c358f1eb97e2","modified":1541070866723},{"_id":"public/tags/计算机网络/index.html","hash":"133f5cdf8512d0c558cc3efc5c44c358f1eb97e2","modified":1541070866723},{"_id":"public/tags/大数据/index.html","hash":"8c54cff8100a544fe1a669d8f7e9f8b34a2f19d2","modified":1541070866723},{"_id":"public/index.html","hash":"f5ef5056f6dde9f09a9a2653b450cfd9c6296363","modified":1541070866723},{"_id":"public/CNAME","hash":"7ec239693239964d066c29cef55ae28e203bca5f","modified":1541070866738},{"_id":"public/assets/example_qr.png","hash":"cce20432c34875f4d9c6df927ede0fc0f00bb194","modified":1541070866738},{"_id":"public/images/StudyOfInterview/jcjtx.jpg","hash":"7bdc07ec710166e2b1949beeff9e21840d74b34b","modified":1541070866738},{"_id":"public/avatar/Misaka.jpg","hash":"74a0372523f98dfbba992bf80642e160d04dc9b1","modified":1541070866738},{"_id":"public/assets/loading.svg","hash":"85082b002bae1335114b71550350907884187e38","modified":1541070866738},{"_id":"public/assets/tabris-weixin.png","hash":"c61f80f69022eb92eca730050b85e898a1551ba4","modified":1541070866738},{"_id":"public/font/Source Sans Pro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1541070866738},{"_id":"public/font/Source Sans Pro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1541070866738},{"_id":"public/assets/favicon.ico","hash":"1b763e30815a4bda405022bbec6af6f4ca4c77d4","modified":1541070866762},{"_id":"public/assets/tabris-qq.png","hash":"b321c2f17980aefd846e6e73105e34ce413bd7c9","modified":1541070866763},{"_id":"public/font/Oswald-Regular.ttf","hash":"965d729546a43a8490ad4cf33c25ac475682100c","modified":1541070866767},{"_id":"public/font/SourceCodePro-Regular.ttf.woff2","hash":"f5991289ec17884cb641da0646d278d36702a190","modified":1541070866768},{"_id":"public/intro/404-bg.jpg","hash":"3afb5bb26f4ff0bd0e0a28df955c8aa7d746d3c5","modified":1541070866768},{"_id":"public/font/SourceCodePro-Regular.ttf.woff","hash":"12eef75e1ad3eca9dae42b65505010ce4464a315","modified":1541070866768},{"_id":"public/css/mobile.css","hash":"d9275c1b8bbca823ced1dc6b37c25fde70a57980","modified":1541070866777},{"_id":"public/intro/post-bg.jpg","hash":"525fafb2238c27754d8fa751f143ff1de9b8482d","modified":1541070866792},{"_id":"public/intro/zewg-yq.jpg","hash":"b0baaf877d56f2aff6ab1a604bb2b8e6c1b935a9","modified":1541070866792},{"_id":"public/intro/about-bg.jpg","hash":"ab388276822417cc4e703312c14e20280ec783b3","modified":1541070866792},{"_id":"public/intro/jxjy-2B.jpg","hash":"2e67fe4b28895153244fc7f1d169d9b56f9aeeae","modified":1541070866793},{"_id":"public/scripts/share.js","hash":"0b5db87fbf926e0b1962145d86ee9d5c7e64c44e","modified":1541070866804},{"_id":"public/avatar/qiu.jpg","hash":"2f5c6b674b2d5ec8a1904c4bba2abbd9ba29cdd8","modified":1541070866804},{"_id":"public/css/style.css","hash":"6a3c43bba8efb4646fa140b643546abd2c41d641","modified":1541070866817},{"_id":"public/intro/index-bg.jpg","hash":"96b52e177b8bc53e64ec6ee1e10b2b6a4e13083b","modified":1541070866817},{"_id":"public/scripts/main.js","hash":"3a813e43a2f35b40c06570f5203a0127a4a7e503","modified":1541070866831},{"_id":"public/intro/dsgl.jpg","hash":"8661bca46fa1440a77ab4179a3087511bcbc7554","modified":1541070866831},{"_id":"public/intro/jxjy-2B(2).jpg","hash":"78252a9305c7f8b455ba21ca31f4a49cc1b0c16b","modified":1541070866879}],"Category":[],"Data":[],"Page":[{"title":"about","date":"2018-09-23T07:56:08.000Z","categories":null,"tags":["loser"],"description":null,"toc":true,"_content":"\n> a loser","source":"about/about.md","raw":"---\ntitle: about\ndate: 2018-9-23 15:56:08\ncategories:  \ntags: [loser]\ndescription: \ntoc: true\n---\n\n> a loser","updated":"2018-09-23T08:34:37.237Z","path":"about/about.html","comments":1,"layout":"page","_id":"cjnyhsxm90001as1on5vmwlj4","content":"<blockquote>\n<p>a loser</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>a loser</p>\n</blockquote>\n"}],"Post":[{"title":"Python学习笔记","date":"2018-03-07T12:12:11.000Z","_content":"\n抄写了两个Spider,发现对于Python基础的掌握实在是差劲的可以.\n\n于是乎 过来补补基础\n\n一直在[Hackerrank](https://www.hackerrank.com/)上面做Python的题目.知识点覆盖挺全面的,推荐一波.\n\n# Basic\n\n## 乱七八糟小技巧\n\n```python\n>>> n,m,*l = ['1','2']\n>>> print(n,m,l)\n1 2 []\n```\n\n## 基本数据类型\n\n### .\n\n#### set\n\n集合是一个无序的，不重复的数据组合，它的主要作用如下：\n去重，把一个列表变成集合，就自动去重了\n关系测试，测试两组数据之前的交集、差集、并集等关系\n\n```python\n\nlist_1 = [1,3,4,7,3,6,7,9]\n#去重\nlist_1 = set(list_1)\n\nlist_2 = set([2,6,0,66,22,8,4])\nlist_3 = set([1,3,7])\nprint(list_1)\nprint(list_2)\nprint(list_3)\nprint(\"---------------------------\")\n\n#关系测试\n#交集(两个列表里面都有的值，这里是4、6)：\nprint(list_1.intersection(list_2))\n\n#并集（把两个列别合并起来，然后去重）：\nprint(list_1.union(list_2))\n\n#差集（把list_1里面有的而list_2里面没有的取出来）：\nprint(list_1.difference(list_2))\n#对称差集（两个列表里面，互相没有的取出来，也就是只去掉那些互相都有的值）\nprint(list_1.symmetric_difference(list_2))\n\n#子集（判断list_1是否包含了list_3里面的所有值）\nprint(list_3.issubset(list_1))\n#父集（判断list_1是否为list_3的父集）\nprint(list_1.issuperset(list_3))\n\n#无交集（判断list_3和list_4是否完全没有任何交集）\nlist_4 = set([5,6,8])\nprint(list_3.isdisjoint(list_4))\n\n#-----------------------关系测试的另一种写法：\n'''\ns = set([3,5,9,10])      #创建一个数值集合\nt = set(\"Hello\")         #创建一个唯一字符的集合\n\na = t | s          # t 和 s的并集\nb = t & s          # t 和 s的交集\nc = t – s          # 求差集（项在t中，但不在s中）\nd = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）\n\n基本操作：\nt.add('x')            # 添加一项\ns.update([10,37,42])  # 在s中添加多项\n\n使用remove()可以删除一项：\n\nt.remove('H')   #有就删除，没有就报错\nt.pop() #随机弹出一个\nt.discard('H')  #有就删除，没有也不会报错\n\nlen(s)\nset 的长度\n\nx in s\n测试 x 是否是 s 的成员\n\nx not in s\n测试 x 是否不是 s 的成员\n\ns.issubset(t)\ns <= t\n测试是否 s 中的每一个元素都在 t 中\n\ns.issuperset(t)\ns >= t\n测试是否 t 中的每一个元素都在 s 中\n\ns.union(t)\ns | t\n返回一个新的 set 包含 s 和 t 中的每一个元素\n\ns.intersection(t)\ns & t\n返回一个新的 set 包含 s 和 t 中的公共元素\n\ns.difference(t)\ns - t\n返回一个新的 set 包含 s 中有但是 t 中没有的元素\n\ns.symmetric_difference(t)\ns ^ t\n返回一个新的 set 包含 s 和 t 中不重复的元素\n\ns.copy()\n返回 set “s”的一个浅复制\n```\n\n## 排序\n\n### .\n\n#### 对字符定义优先级\n\n将需要排序的字符集放到一个字符串中\n在这个字符串中越靠前的字符排序后越靠前\n\n```python\norder = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1357902468'\nprint(*sorted(input(), key=order.index), sep='')\n```\n\n\n#### 关键字排序\n\n```python\nN, M = map(int, input().split())    # Ｎ行 Ｍ列\nrows = [input() for _ in range(N)]  # 一行 为一组数据\nK = int(input()) # 以第几为关键字\n\nfor row in sorted(rows, key=lambda x: int(x.split()[K])):# lambda 匿名函数\n    print(row)\n\n```\n\n## 字符串\n\n### .\n\n#### 26字母\n\n```Python\nimport string\nalpha = string.ascii_lowercase\n```\n\n#### 字符串反转\n\n```Python\n>>>　s = 'abcde'\n>>>　print(s[::-1])\nedcba\n```\n\n#### 字符串格式化输出\n\n个人喜欢最新的`'{}'.format()`的形式,不仅写起来更方便一些,还有旧方法不能实现的操作.感觉以后可能完全取缔旧的方法.\n\n[.format的介绍(与旧方法的对比)](https://pyformat.info/)\n\n\n输出一行 '-'\n```Python\n'{:-{align}{width}}'.format( '',align='>', width = 5)\n```\n输出\n```\n-----\n```\n\n## 函数(function)\n\n可更改(mutable)与不可更改(immutable)对象\n在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。\n\n- 不可变类型：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。\n- 可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。\n\npython 函数的参数传递：\n\n- 不可变类型：类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。\n- 可变类型：类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响\n\npython 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。\n\n\n### .\n\n#### eval()\n\neval(string) 对于一个字符串，相当与**运行**这个字符串所代表的python代码\n\n```python\n>>> x = 1\n>>> eval('x+1')\n>>> print(eval('x+1'))\n2\n```\n\n\n# 各种库\n\n导入库\n```python\nimport 库 #使用时需要 `库.函数()`\nfrom 库 import 函数 # 使用时直接 `函数()` 即可\n```\n\n## collections\n\n```python\nimport collections\n```\n\n### Counter\n\n计数用的函数\n\n###  defaultdict\n\n可以简单理解为一个**map**,\n\n```python\na = defaultdict([Type of value])\n------\na['key'] type is [Type of value]\n```\n\n### deque\n\n```python\n>>> from collections import deque\n>>> d = deque()\n>>> d.append(1)\n>>> print d\ndeque([1])\n>>> d.appendleft(2)\n>>> print d\ndeque([2, 1])\n>>> d.clear()\n>>> print d\ndeque([])\n>>> d.extend('1')\n>>> print d\ndeque(['1'])\n>>> d.extendleft('234')\n>>> print d\ndeque(['4', '3', '2', '1'])\n>>> d.count('1')\n1\n>>> d.pop()\n'1'\n>>> print d\ndeque(['4', '3', '2'])\n>>> d.popleft()\n'4'\n>>> print d\ndeque(['3', '2'])\n>>> d.extend('7896')\n>>> print d\ndeque(['3', '2', '7', '8', '9', '6'])\n>>> d.remove('2')\n>>> print d\ndeque(['3', '7', '8', '9', '6'])\n>>> d.reverse()\n>>> print d\ndeque(['6', '9', '8', '7', '3'])\n>>> d.rotate(3)\n>>> print d\ndeque(['8', '7', '3', '6', '9'])\n```\n\n# 自省\n\n## .\n\n### .\n\n#### getattr()\n\n```python\n'''\ngetattr(object, name[, default]) -> value\n其中 name 可以是字符串.\n这样的话 相当于 name可以用字符串代替 就不用一大堆`if elif else`了\n'''\ngetattr(object, name[, default]) -> value\n<==>\nobject.name(value)\n```","source":"_posts/NotesOfPython.md","raw":"---\ntitle: Python学习笔记\ndate: 2018-03-07 20:12:11\ntags:\n---\n\n抄写了两个Spider,发现对于Python基础的掌握实在是差劲的可以.\n\n于是乎 过来补补基础\n\n一直在[Hackerrank](https://www.hackerrank.com/)上面做Python的题目.知识点覆盖挺全面的,推荐一波.\n\n# Basic\n\n## 乱七八糟小技巧\n\n```python\n>>> n,m,*l = ['1','2']\n>>> print(n,m,l)\n1 2 []\n```\n\n## 基本数据类型\n\n### .\n\n#### set\n\n集合是一个无序的，不重复的数据组合，它的主要作用如下：\n去重，把一个列表变成集合，就自动去重了\n关系测试，测试两组数据之前的交集、差集、并集等关系\n\n```python\n\nlist_1 = [1,3,4,7,3,6,7,9]\n#去重\nlist_1 = set(list_1)\n\nlist_2 = set([2,6,0,66,22,8,4])\nlist_3 = set([1,3,7])\nprint(list_1)\nprint(list_2)\nprint(list_3)\nprint(\"---------------------------\")\n\n#关系测试\n#交集(两个列表里面都有的值，这里是4、6)：\nprint(list_1.intersection(list_2))\n\n#并集（把两个列别合并起来，然后去重）：\nprint(list_1.union(list_2))\n\n#差集（把list_1里面有的而list_2里面没有的取出来）：\nprint(list_1.difference(list_2))\n#对称差集（两个列表里面，互相没有的取出来，也就是只去掉那些互相都有的值）\nprint(list_1.symmetric_difference(list_2))\n\n#子集（判断list_1是否包含了list_3里面的所有值）\nprint(list_3.issubset(list_1))\n#父集（判断list_1是否为list_3的父集）\nprint(list_1.issuperset(list_3))\n\n#无交集（判断list_3和list_4是否完全没有任何交集）\nlist_4 = set([5,6,8])\nprint(list_3.isdisjoint(list_4))\n\n#-----------------------关系测试的另一种写法：\n'''\ns = set([3,5,9,10])      #创建一个数值集合\nt = set(\"Hello\")         #创建一个唯一字符的集合\n\na = t | s          # t 和 s的并集\nb = t & s          # t 和 s的交集\nc = t – s          # 求差集（项在t中，但不在s中）\nd = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）\n\n基本操作：\nt.add('x')            # 添加一项\ns.update([10,37,42])  # 在s中添加多项\n\n使用remove()可以删除一项：\n\nt.remove('H')   #有就删除，没有就报错\nt.pop() #随机弹出一个\nt.discard('H')  #有就删除，没有也不会报错\n\nlen(s)\nset 的长度\n\nx in s\n测试 x 是否是 s 的成员\n\nx not in s\n测试 x 是否不是 s 的成员\n\ns.issubset(t)\ns <= t\n测试是否 s 中的每一个元素都在 t 中\n\ns.issuperset(t)\ns >= t\n测试是否 t 中的每一个元素都在 s 中\n\ns.union(t)\ns | t\n返回一个新的 set 包含 s 和 t 中的每一个元素\n\ns.intersection(t)\ns & t\n返回一个新的 set 包含 s 和 t 中的公共元素\n\ns.difference(t)\ns - t\n返回一个新的 set 包含 s 中有但是 t 中没有的元素\n\ns.symmetric_difference(t)\ns ^ t\n返回一个新的 set 包含 s 和 t 中不重复的元素\n\ns.copy()\n返回 set “s”的一个浅复制\n```\n\n## 排序\n\n### .\n\n#### 对字符定义优先级\n\n将需要排序的字符集放到一个字符串中\n在这个字符串中越靠前的字符排序后越靠前\n\n```python\norder = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1357902468'\nprint(*sorted(input(), key=order.index), sep='')\n```\n\n\n#### 关键字排序\n\n```python\nN, M = map(int, input().split())    # Ｎ行 Ｍ列\nrows = [input() for _ in range(N)]  # 一行 为一组数据\nK = int(input()) # 以第几为关键字\n\nfor row in sorted(rows, key=lambda x: int(x.split()[K])):# lambda 匿名函数\n    print(row)\n\n```\n\n## 字符串\n\n### .\n\n#### 26字母\n\n```Python\nimport string\nalpha = string.ascii_lowercase\n```\n\n#### 字符串反转\n\n```Python\n>>>　s = 'abcde'\n>>>　print(s[::-1])\nedcba\n```\n\n#### 字符串格式化输出\n\n个人喜欢最新的`'{}'.format()`的形式,不仅写起来更方便一些,还有旧方法不能实现的操作.感觉以后可能完全取缔旧的方法.\n\n[.format的介绍(与旧方法的对比)](https://pyformat.info/)\n\n\n输出一行 '-'\n```Python\n'{:-{align}{width}}'.format( '',align='>', width = 5)\n```\n输出\n```\n-----\n```\n\n## 函数(function)\n\n可更改(mutable)与不可更改(immutable)对象\n在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。\n\n- 不可变类型：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。\n- 可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。\n\npython 函数的参数传递：\n\n- 不可变类型：类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。\n- 可变类型：类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响\n\npython 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。\n\n\n### .\n\n#### eval()\n\neval(string) 对于一个字符串，相当与**运行**这个字符串所代表的python代码\n\n```python\n>>> x = 1\n>>> eval('x+1')\n>>> print(eval('x+1'))\n2\n```\n\n\n# 各种库\n\n导入库\n```python\nimport 库 #使用时需要 `库.函数()`\nfrom 库 import 函数 # 使用时直接 `函数()` 即可\n```\n\n## collections\n\n```python\nimport collections\n```\n\n### Counter\n\n计数用的函数\n\n###  defaultdict\n\n可以简单理解为一个**map**,\n\n```python\na = defaultdict([Type of value])\n------\na['key'] type is [Type of value]\n```\n\n### deque\n\n```python\n>>> from collections import deque\n>>> d = deque()\n>>> d.append(1)\n>>> print d\ndeque([1])\n>>> d.appendleft(2)\n>>> print d\ndeque([2, 1])\n>>> d.clear()\n>>> print d\ndeque([])\n>>> d.extend('1')\n>>> print d\ndeque(['1'])\n>>> d.extendleft('234')\n>>> print d\ndeque(['4', '3', '2', '1'])\n>>> d.count('1')\n1\n>>> d.pop()\n'1'\n>>> print d\ndeque(['4', '3', '2'])\n>>> d.popleft()\n'4'\n>>> print d\ndeque(['3', '2'])\n>>> d.extend('7896')\n>>> print d\ndeque(['3', '2', '7', '8', '9', '6'])\n>>> d.remove('2')\n>>> print d\ndeque(['3', '7', '8', '9', '6'])\n>>> d.reverse()\n>>> print d\ndeque(['6', '9', '8', '7', '3'])\n>>> d.rotate(3)\n>>> print d\ndeque(['8', '7', '3', '6', '9'])\n```\n\n# 自省\n\n## .\n\n### .\n\n#### getattr()\n\n```python\n'''\ngetattr(object, name[, default]) -> value\n其中 name 可以是字符串.\n这样的话 相当于 name可以用字符串代替 就不用一大堆`if elif else`了\n'''\ngetattr(object, name[, default]) -> value\n<==>\nobject.name(value)\n```","slug":"NotesOfPython","published":1,"updated":"2018-09-23T07:59:44.822Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnyhsxm10000as1owps6ozqt","content":"<p>抄写了两个Spider,发现对于Python基础的掌握实在是差劲的可以.</p>\n<p>于是乎 过来补补基础</p>\n<p>一直在<a href=\"https://www.hackerrank.com/\" target=\"_blank\" rel=\"noopener\">Hackerrank</a>上面做Python的题目.知识点覆盖挺全面的,推荐一波.</p>\n<h1 id=\"Basic\"><a href=\"#Basic\" class=\"headerlink\" title=\"Basic\"></a>Basic</h1><h2 id=\"乱七八糟小技巧\"><a href=\"#乱七八糟小技巧\" class=\"headerlink\" title=\"乱七八糟小技巧\"></a>乱七八糟小技巧</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>n,m,*l = [<span class=\"string\">'1'</span>,<span class=\"string\">'2'</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(n,m,l)</span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">2</span> []</span><br></pre></td></tr></table></figure>\n<h2 id=\"基本数据类型\"><a href=\"#基本数据类型\" class=\"headerlink\" title=\"基本数据类型\"></a>基本数据类型</h2><h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\".\"></a>.</h3><h4 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h4><p>集合是一个无序的，不重复的数据组合，它的主要作用如下：<br>去重，把一个列表变成集合，就自动去重了<br>关系测试，测试两组数据之前的交集、差集、并集等关系</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">list_1 = [<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">7</span>,<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">9</span>]</span><br><span class=\"line\"><span class=\"comment\">#去重</span></span><br><span class=\"line\">list_1 = set(list_1)</span><br><span class=\"line\"></span><br><span class=\"line\">list_2 = set([<span class=\"number\">2</span>,<span class=\"number\">6</span>,<span class=\"number\">0</span>,<span class=\"number\">66</span>,<span class=\"number\">22</span>,<span class=\"number\">8</span>,<span class=\"number\">4</span>])</span><br><span class=\"line\">list_3 = set([<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">7</span>])</span><br><span class=\"line\">print(list_1)</span><br><span class=\"line\">print(list_2)</span><br><span class=\"line\">print(list_3)</span><br><span class=\"line\">print(<span class=\"string\">\"---------------------------\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#关系测试</span></span><br><span class=\"line\"><span class=\"comment\">#交集(两个列表里面都有的值，这里是4、6)：</span></span><br><span class=\"line\">print(list_1.intersection(list_2))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#并集（把两个列别合并起来，然后去重）：</span></span><br><span class=\"line\">print(list_1.union(list_2))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#差集（把list_1里面有的而list_2里面没有的取出来）：</span></span><br><span class=\"line\">print(list_1.difference(list_2))</span><br><span class=\"line\"><span class=\"comment\">#对称差集（两个列表里面，互相没有的取出来，也就是只去掉那些互相都有的值）</span></span><br><span class=\"line\">print(list_1.symmetric_difference(list_2))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#子集（判断list_1是否包含了list_3里面的所有值）</span></span><br><span class=\"line\">print(list_3.issubset(list_1))</span><br><span class=\"line\"><span class=\"comment\">#父集（判断list_1是否为list_3的父集）</span></span><br><span class=\"line\">print(list_1.issuperset(list_3))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#无交集（判断list_3和list_4是否完全没有任何交集）</span></span><br><span class=\"line\">list_4 = set([<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">8</span>])</span><br><span class=\"line\">print(list_3.isdisjoint(list_4))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#-----------------------关系测试的另一种写法：</span></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">s = set([3,5,9,10])      #创建一个数值集合</span></span><br><span class=\"line\"><span class=\"string\">t = set(\"Hello\")         #创建一个唯一字符的集合</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">a = t | s          # t 和 s的并集</span></span><br><span class=\"line\"><span class=\"string\">b = t &amp; s          # t 和 s的交集</span></span><br><span class=\"line\"><span class=\"string\">c = t – s          # 求差集（项在t中，但不在s中）</span></span><br><span class=\"line\"><span class=\"string\">d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">基本操作：</span></span><br><span class=\"line\"><span class=\"string\">t.add('x')            # 添加一项</span></span><br><span class=\"line\"><span class=\"string\">s.update([10,37,42])  # 在s中添加多项</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">使用remove()可以删除一项：</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">t.remove('H')   #有就删除，没有就报错</span></span><br><span class=\"line\"><span class=\"string\">t.pop() #随机弹出一个</span></span><br><span class=\"line\"><span class=\"string\">t.discard('H')  #有就删除，没有也不会报错</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">len(s)</span></span><br><span class=\"line\"><span class=\"string\">set 的长度</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">x in s</span></span><br><span class=\"line\"><span class=\"string\">测试 x 是否是 s 的成员</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">x not in s</span></span><br><span class=\"line\"><span class=\"string\">测试 x 是否不是 s 的成员</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">s.issubset(t)</span></span><br><span class=\"line\"><span class=\"string\">s &lt;= t</span></span><br><span class=\"line\"><span class=\"string\">测试是否 s 中的每一个元素都在 t 中</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">s.issuperset(t)</span></span><br><span class=\"line\"><span class=\"string\">s &gt;= t</span></span><br><span class=\"line\"><span class=\"string\">测试是否 t 中的每一个元素都在 s 中</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">s.union(t)</span></span><br><span class=\"line\"><span class=\"string\">s | t</span></span><br><span class=\"line\"><span class=\"string\">返回一个新的 set 包含 s 和 t 中的每一个元素</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">s.intersection(t)</span></span><br><span class=\"line\"><span class=\"string\">s &amp; t</span></span><br><span class=\"line\"><span class=\"string\">返回一个新的 set 包含 s 和 t 中的公共元素</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">s.difference(t)</span></span><br><span class=\"line\"><span class=\"string\">s - t</span></span><br><span class=\"line\"><span class=\"string\">返回一个新的 set 包含 s 中有但是 t 中没有的元素</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">s.symmetric_difference(t)</span></span><br><span class=\"line\"><span class=\"string\">s ^ t</span></span><br><span class=\"line\"><span class=\"string\">返回一个新的 set 包含 s 和 t 中不重复的元素</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">s.copy()</span></span><br><span class=\"line\"><span class=\"string\">返回 set “s”的一个浅复制</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h2><h3 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\".\"></a>.</h3><h4 id=\"对字符定义优先级\"><a href=\"#对字符定义优先级\" class=\"headerlink\" title=\"对字符定义优先级\"></a>对字符定义优先级</h4><p>将需要排序的字符集放到一个字符串中<br>在这个字符串中越靠前的字符排序后越靠前</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">order = <span class=\"string\">'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1357902468'</span></span><br><span class=\"line\">print(*sorted(input(), key=order.index), sep=<span class=\"string\">''</span>)</span><br></pre></td></tr></table></figure>\n<h4 id=\"关键字排序\"><a href=\"#关键字排序\" class=\"headerlink\" title=\"关键字排序\"></a>关键字排序</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">N, M = map(int, input().split())    <span class=\"comment\"># Ｎ行 Ｍ列</span></span><br><span class=\"line\">rows = [input() <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(N)]  <span class=\"comment\"># 一行 为一组数据</span></span><br><span class=\"line\">K = int(input()) <span class=\"comment\"># 以第几为关键字</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> sorted(rows, key=<span class=\"keyword\">lambda</span> x: int(x.split()[K])):<span class=\"comment\"># lambda 匿名函数</span></span><br><span class=\"line\">    print(row)</span><br></pre></td></tr></table></figure>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><h3 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\".\"></a>.</h3><h4 id=\"26字母\"><a href=\"#26字母\" class=\"headerlink\" title=\"26字母\"></a>26字母</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> string</span><br><span class=\"line\">alpha = string.ascii_lowercase</span><br></pre></td></tr></table></figure>\n<h4 id=\"字符串反转\"><a href=\"#字符串反转\" class=\"headerlink\" title=\"字符串反转\"></a>字符串反转</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt;　s = <span class=\"string\">'abcde'</span></span><br><span class=\"line\">&gt;&gt;&gt;　print(s[::<span class=\"number\">-1</span>])</span><br><span class=\"line\">edcba</span><br></pre></td></tr></table></figure>\n<h4 id=\"字符串格式化输出\"><a href=\"#字符串格式化输出\" class=\"headerlink\" title=\"字符串格式化输出\"></a>字符串格式化输出</h4><p>个人喜欢最新的<code>&#39;{}&#39;.format()</code>的形式,不仅写起来更方便一些,还有旧方法不能实现的操作.感觉以后可能完全取缔旧的方法.</p>\n<p><a href=\"https://pyformat.info/\" target=\"_blank\" rel=\"noopener\">.format的介绍(与旧方法的对比)</a></p>\n<p>输出一行 ‘-‘<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'&#123;:-&#123;align&#125;&#123;width&#125;&#125;'</span>.format( <span class=\"string\">''</span>,align=<span class=\"string\">'&gt;'</span>, width = <span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure></p>\n<p>输出<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"函数-function\"><a href=\"#函数-function\" class=\"headerlink\" title=\"函数(function)\"></a>函数(function)</h2><p>可更改(mutable)与不可更改(immutable)对象<br>在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。</p>\n<ul>\n<li>不可变类型：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。</li>\n<li>可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。</li>\n</ul>\n<p>python 函数的参数传递：</p>\n<ul>\n<li>不可变类型：类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。</li>\n<li>可变类型：类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响</li>\n</ul>\n<p>python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。</p>\n<h3 id=\"-3\"><a href=\"#-3\" class=\"headerlink\" title=\".\"></a>.</h3><h4 id=\"eval\"><a href=\"#eval\" class=\"headerlink\" title=\"eval()\"></a>eval()</h4><p>eval(string) 对于一个字符串，相当与<strong>运行</strong>这个字符串所代表的python代码</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>x = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>eval(<span class=\"string\">'x+1'</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(eval(<span class=\"string\">'x+1'</span>))</span><br><span class=\"line\"><span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"各种库\"><a href=\"#各种库\" class=\"headerlink\" title=\"各种库\"></a>各种库</h1><p>导入库<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> 库 <span class=\"comment\">#使用时需要 `库.函数()`</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> 库 <span class=\"keyword\">import</span> 函数 <span class=\"comment\"># 使用时直接 `函数()` 即可</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"collections\"><a href=\"#collections\" class=\"headerlink\" title=\"collections\"></a>collections</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> collections</span><br></pre></td></tr></table></figure>\n<h3 id=\"Counter\"><a href=\"#Counter\" class=\"headerlink\" title=\"Counter\"></a>Counter</h3><p>计数用的函数</p>\n<h3 id=\"defaultdict\"><a href=\"#defaultdict\" class=\"headerlink\" title=\"defaultdict\"></a>defaultdict</h3><p>可以简单理解为一个<strong>map</strong>,</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = defaultdict([Type of value])</span><br><span class=\"line\">------</span><br><span class=\"line\">a[<span class=\"string\">'key'</span>] type <span class=\"keyword\">is</span> [Type of value]</span><br></pre></td></tr></table></figure>\n<h3 id=\"deque\"><a href=\"#deque\" class=\"headerlink\" title=\"deque\"></a>deque</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> deque</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d = deque()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d.append(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> d</span><br><span class=\"line\">deque([<span class=\"number\">1</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d.appendleft(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> d</span><br><span class=\"line\">deque([<span class=\"number\">2</span>, <span class=\"number\">1</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d.clear()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> d</span><br><span class=\"line\">deque([])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d.extend(<span class=\"string\">'1'</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> d</span><br><span class=\"line\">deque([<span class=\"string\">'1'</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d.extendleft(<span class=\"string\">'234'</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> d</span><br><span class=\"line\">deque([<span class=\"string\">'4'</span>, <span class=\"string\">'3'</span>, <span class=\"string\">'2'</span>, <span class=\"string\">'1'</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d.count(<span class=\"string\">'1'</span>)</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d.pop()</span><br><span class=\"line\"><span class=\"string\">'1'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> d</span><br><span class=\"line\">deque([<span class=\"string\">'4'</span>, <span class=\"string\">'3'</span>, <span class=\"string\">'2'</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d.popleft()</span><br><span class=\"line\"><span class=\"string\">'4'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> d</span><br><span class=\"line\">deque([<span class=\"string\">'3'</span>, <span class=\"string\">'2'</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d.extend(<span class=\"string\">'7896'</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> d</span><br><span class=\"line\">deque([<span class=\"string\">'3'</span>, <span class=\"string\">'2'</span>, <span class=\"string\">'7'</span>, <span class=\"string\">'8'</span>, <span class=\"string\">'9'</span>, <span class=\"string\">'6'</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d.remove(<span class=\"string\">'2'</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> d</span><br><span class=\"line\">deque([<span class=\"string\">'3'</span>, <span class=\"string\">'7'</span>, <span class=\"string\">'8'</span>, <span class=\"string\">'9'</span>, <span class=\"string\">'6'</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d.reverse()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> d</span><br><span class=\"line\">deque([<span class=\"string\">'6'</span>, <span class=\"string\">'9'</span>, <span class=\"string\">'8'</span>, <span class=\"string\">'7'</span>, <span class=\"string\">'3'</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d.rotate(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> d</span><br><span class=\"line\">deque([<span class=\"string\">'8'</span>, <span class=\"string\">'7'</span>, <span class=\"string\">'3'</span>, <span class=\"string\">'6'</span>, <span class=\"string\">'9'</span>])</span><br></pre></td></tr></table></figure>\n<h1 id=\"自省\"><a href=\"#自省\" class=\"headerlink\" title=\"自省\"></a>自省</h1><h2 id=\"-4\"><a href=\"#-4\" class=\"headerlink\" title=\".\"></a>.</h2><h3 id=\"-5\"><a href=\"#-5\" class=\"headerlink\" title=\".\"></a>.</h3><h4 id=\"getattr\"><a href=\"#getattr\" class=\"headerlink\" title=\"getattr()\"></a>getattr()</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">getattr(object, name[, default]) -&gt; value</span></span><br><span class=\"line\"><span class=\"string\">其中 name 可以是字符串.</span></span><br><span class=\"line\"><span class=\"string\">这样的话 相当于 name可以用字符串代替 就不用一大堆`if elif else`了</span></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br><span class=\"line\">getattr(object, name[, default]) -&gt; value</span><br><span class=\"line\">&lt;==&gt;</span><br><span class=\"line\">object.name(value)</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>抄写了两个Spider,发现对于Python基础的掌握实在是差劲的可以.</p>\n<p>于是乎 过来补补基础</p>\n<p>一直在<a href=\"https://www.hackerrank.com/\" target=\"_blank\" rel=\"noopener\">Hackerrank</a>上面做Python的题目.知识点覆盖挺全面的,推荐一波.</p>\n<h1 id=\"Basic\"><a href=\"#Basic\" class=\"headerlink\" title=\"Basic\"></a>Basic</h1><h2 id=\"乱七八糟小技巧\"><a href=\"#乱七八糟小技巧\" class=\"headerlink\" title=\"乱七八糟小技巧\"></a>乱七八糟小技巧</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>n,m,*l = [<span class=\"string\">'1'</span>,<span class=\"string\">'2'</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(n,m,l)</span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">2</span> []</span><br></pre></td></tr></table></figure>\n<h2 id=\"基本数据类型\"><a href=\"#基本数据类型\" class=\"headerlink\" title=\"基本数据类型\"></a>基本数据类型</h2><h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\".\"></a>.</h3><h4 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h4><p>集合是一个无序的，不重复的数据组合，它的主要作用如下：<br>去重，把一个列表变成集合，就自动去重了<br>关系测试，测试两组数据之前的交集、差集、并集等关系</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">list_1 = [<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">7</span>,<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">9</span>]</span><br><span class=\"line\"><span class=\"comment\">#去重</span></span><br><span class=\"line\">list_1 = set(list_1)</span><br><span class=\"line\"></span><br><span class=\"line\">list_2 = set([<span class=\"number\">2</span>,<span class=\"number\">6</span>,<span class=\"number\">0</span>,<span class=\"number\">66</span>,<span class=\"number\">22</span>,<span class=\"number\">8</span>,<span class=\"number\">4</span>])</span><br><span class=\"line\">list_3 = set([<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">7</span>])</span><br><span class=\"line\">print(list_1)</span><br><span class=\"line\">print(list_2)</span><br><span class=\"line\">print(list_3)</span><br><span class=\"line\">print(<span class=\"string\">\"---------------------------\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#关系测试</span></span><br><span class=\"line\"><span class=\"comment\">#交集(两个列表里面都有的值，这里是4、6)：</span></span><br><span class=\"line\">print(list_1.intersection(list_2))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#并集（把两个列别合并起来，然后去重）：</span></span><br><span class=\"line\">print(list_1.union(list_2))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#差集（把list_1里面有的而list_2里面没有的取出来）：</span></span><br><span class=\"line\">print(list_1.difference(list_2))</span><br><span class=\"line\"><span class=\"comment\">#对称差集（两个列表里面，互相没有的取出来，也就是只去掉那些互相都有的值）</span></span><br><span class=\"line\">print(list_1.symmetric_difference(list_2))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#子集（判断list_1是否包含了list_3里面的所有值）</span></span><br><span class=\"line\">print(list_3.issubset(list_1))</span><br><span class=\"line\"><span class=\"comment\">#父集（判断list_1是否为list_3的父集）</span></span><br><span class=\"line\">print(list_1.issuperset(list_3))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#无交集（判断list_3和list_4是否完全没有任何交集）</span></span><br><span class=\"line\">list_4 = set([<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">8</span>])</span><br><span class=\"line\">print(list_3.isdisjoint(list_4))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#-----------------------关系测试的另一种写法：</span></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">s = set([3,5,9,10])      #创建一个数值集合</span></span><br><span class=\"line\"><span class=\"string\">t = set(\"Hello\")         #创建一个唯一字符的集合</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">a = t | s          # t 和 s的并集</span></span><br><span class=\"line\"><span class=\"string\">b = t &amp; s          # t 和 s的交集</span></span><br><span class=\"line\"><span class=\"string\">c = t – s          # 求差集（项在t中，但不在s中）</span></span><br><span class=\"line\"><span class=\"string\">d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">基本操作：</span></span><br><span class=\"line\"><span class=\"string\">t.add('x')            # 添加一项</span></span><br><span class=\"line\"><span class=\"string\">s.update([10,37,42])  # 在s中添加多项</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">使用remove()可以删除一项：</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">t.remove('H')   #有就删除，没有就报错</span></span><br><span class=\"line\"><span class=\"string\">t.pop() #随机弹出一个</span></span><br><span class=\"line\"><span class=\"string\">t.discard('H')  #有就删除，没有也不会报错</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">len(s)</span></span><br><span class=\"line\"><span class=\"string\">set 的长度</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">x in s</span></span><br><span class=\"line\"><span class=\"string\">测试 x 是否是 s 的成员</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">x not in s</span></span><br><span class=\"line\"><span class=\"string\">测试 x 是否不是 s 的成员</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">s.issubset(t)</span></span><br><span class=\"line\"><span class=\"string\">s &lt;= t</span></span><br><span class=\"line\"><span class=\"string\">测试是否 s 中的每一个元素都在 t 中</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">s.issuperset(t)</span></span><br><span class=\"line\"><span class=\"string\">s &gt;= t</span></span><br><span class=\"line\"><span class=\"string\">测试是否 t 中的每一个元素都在 s 中</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">s.union(t)</span></span><br><span class=\"line\"><span class=\"string\">s | t</span></span><br><span class=\"line\"><span class=\"string\">返回一个新的 set 包含 s 和 t 中的每一个元素</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">s.intersection(t)</span></span><br><span class=\"line\"><span class=\"string\">s &amp; t</span></span><br><span class=\"line\"><span class=\"string\">返回一个新的 set 包含 s 和 t 中的公共元素</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">s.difference(t)</span></span><br><span class=\"line\"><span class=\"string\">s - t</span></span><br><span class=\"line\"><span class=\"string\">返回一个新的 set 包含 s 中有但是 t 中没有的元素</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">s.symmetric_difference(t)</span></span><br><span class=\"line\"><span class=\"string\">s ^ t</span></span><br><span class=\"line\"><span class=\"string\">返回一个新的 set 包含 s 和 t 中不重复的元素</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">s.copy()</span></span><br><span class=\"line\"><span class=\"string\">返回 set “s”的一个浅复制</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h2><h3 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\".\"></a>.</h3><h4 id=\"对字符定义优先级\"><a href=\"#对字符定义优先级\" class=\"headerlink\" title=\"对字符定义优先级\"></a>对字符定义优先级</h4><p>将需要排序的字符集放到一个字符串中<br>在这个字符串中越靠前的字符排序后越靠前</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">order = <span class=\"string\">'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1357902468'</span></span><br><span class=\"line\">print(*sorted(input(), key=order.index), sep=<span class=\"string\">''</span>)</span><br></pre></td></tr></table></figure>\n<h4 id=\"关键字排序\"><a href=\"#关键字排序\" class=\"headerlink\" title=\"关键字排序\"></a>关键字排序</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">N, M = map(int, input().split())    <span class=\"comment\"># Ｎ行 Ｍ列</span></span><br><span class=\"line\">rows = [input() <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(N)]  <span class=\"comment\"># 一行 为一组数据</span></span><br><span class=\"line\">K = int(input()) <span class=\"comment\"># 以第几为关键字</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> sorted(rows, key=<span class=\"keyword\">lambda</span> x: int(x.split()[K])):<span class=\"comment\"># lambda 匿名函数</span></span><br><span class=\"line\">    print(row)</span><br></pre></td></tr></table></figure>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><h3 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\".\"></a>.</h3><h4 id=\"26字母\"><a href=\"#26字母\" class=\"headerlink\" title=\"26字母\"></a>26字母</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> string</span><br><span class=\"line\">alpha = string.ascii_lowercase</span><br></pre></td></tr></table></figure>\n<h4 id=\"字符串反转\"><a href=\"#字符串反转\" class=\"headerlink\" title=\"字符串反转\"></a>字符串反转</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt;　s = <span class=\"string\">'abcde'</span></span><br><span class=\"line\">&gt;&gt;&gt;　print(s[::<span class=\"number\">-1</span>])</span><br><span class=\"line\">edcba</span><br></pre></td></tr></table></figure>\n<h4 id=\"字符串格式化输出\"><a href=\"#字符串格式化输出\" class=\"headerlink\" title=\"字符串格式化输出\"></a>字符串格式化输出</h4><p>个人喜欢最新的<code>&#39;{}&#39;.format()</code>的形式,不仅写起来更方便一些,还有旧方法不能实现的操作.感觉以后可能完全取缔旧的方法.</p>\n<p><a href=\"https://pyformat.info/\" target=\"_blank\" rel=\"noopener\">.format的介绍(与旧方法的对比)</a></p>\n<p>输出一行 ‘-‘<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'&#123;:-&#123;align&#125;&#123;width&#125;&#125;'</span>.format( <span class=\"string\">''</span>,align=<span class=\"string\">'&gt;'</span>, width = <span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure></p>\n<p>输出<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"函数-function\"><a href=\"#函数-function\" class=\"headerlink\" title=\"函数(function)\"></a>函数(function)</h2><p>可更改(mutable)与不可更改(immutable)对象<br>在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。</p>\n<ul>\n<li>不可变类型：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。</li>\n<li>可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。</li>\n</ul>\n<p>python 函数的参数传递：</p>\n<ul>\n<li>不可变类型：类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。</li>\n<li>可变类型：类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响</li>\n</ul>\n<p>python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。</p>\n<h3 id=\"-3\"><a href=\"#-3\" class=\"headerlink\" title=\".\"></a>.</h3><h4 id=\"eval\"><a href=\"#eval\" class=\"headerlink\" title=\"eval()\"></a>eval()</h4><p>eval(string) 对于一个字符串，相当与<strong>运行</strong>这个字符串所代表的python代码</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>x = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>eval(<span class=\"string\">'x+1'</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(eval(<span class=\"string\">'x+1'</span>))</span><br><span class=\"line\"><span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"各种库\"><a href=\"#各种库\" class=\"headerlink\" title=\"各种库\"></a>各种库</h1><p>导入库<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> 库 <span class=\"comment\">#使用时需要 `库.函数()`</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> 库 <span class=\"keyword\">import</span> 函数 <span class=\"comment\"># 使用时直接 `函数()` 即可</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"collections\"><a href=\"#collections\" class=\"headerlink\" title=\"collections\"></a>collections</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> collections</span><br></pre></td></tr></table></figure>\n<h3 id=\"Counter\"><a href=\"#Counter\" class=\"headerlink\" title=\"Counter\"></a>Counter</h3><p>计数用的函数</p>\n<h3 id=\"defaultdict\"><a href=\"#defaultdict\" class=\"headerlink\" title=\"defaultdict\"></a>defaultdict</h3><p>可以简单理解为一个<strong>map</strong>,</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = defaultdict([Type of value])</span><br><span class=\"line\">------</span><br><span class=\"line\">a[<span class=\"string\">'key'</span>] type <span class=\"keyword\">is</span> [Type of value]</span><br></pre></td></tr></table></figure>\n<h3 id=\"deque\"><a href=\"#deque\" class=\"headerlink\" title=\"deque\"></a>deque</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> deque</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d = deque()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d.append(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> d</span><br><span class=\"line\">deque([<span class=\"number\">1</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d.appendleft(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> d</span><br><span class=\"line\">deque([<span class=\"number\">2</span>, <span class=\"number\">1</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d.clear()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> d</span><br><span class=\"line\">deque([])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d.extend(<span class=\"string\">'1'</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> d</span><br><span class=\"line\">deque([<span class=\"string\">'1'</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d.extendleft(<span class=\"string\">'234'</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> d</span><br><span class=\"line\">deque([<span class=\"string\">'4'</span>, <span class=\"string\">'3'</span>, <span class=\"string\">'2'</span>, <span class=\"string\">'1'</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d.count(<span class=\"string\">'1'</span>)</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d.pop()</span><br><span class=\"line\"><span class=\"string\">'1'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> d</span><br><span class=\"line\">deque([<span class=\"string\">'4'</span>, <span class=\"string\">'3'</span>, <span class=\"string\">'2'</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d.popleft()</span><br><span class=\"line\"><span class=\"string\">'4'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> d</span><br><span class=\"line\">deque([<span class=\"string\">'3'</span>, <span class=\"string\">'2'</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d.extend(<span class=\"string\">'7896'</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> d</span><br><span class=\"line\">deque([<span class=\"string\">'3'</span>, <span class=\"string\">'2'</span>, <span class=\"string\">'7'</span>, <span class=\"string\">'8'</span>, <span class=\"string\">'9'</span>, <span class=\"string\">'6'</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d.remove(<span class=\"string\">'2'</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> d</span><br><span class=\"line\">deque([<span class=\"string\">'3'</span>, <span class=\"string\">'7'</span>, <span class=\"string\">'8'</span>, <span class=\"string\">'9'</span>, <span class=\"string\">'6'</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d.reverse()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> d</span><br><span class=\"line\">deque([<span class=\"string\">'6'</span>, <span class=\"string\">'9'</span>, <span class=\"string\">'8'</span>, <span class=\"string\">'7'</span>, <span class=\"string\">'3'</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d.rotate(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> d</span><br><span class=\"line\">deque([<span class=\"string\">'8'</span>, <span class=\"string\">'7'</span>, <span class=\"string\">'3'</span>, <span class=\"string\">'6'</span>, <span class=\"string\">'9'</span>])</span><br></pre></td></tr></table></figure>\n<h1 id=\"自省\"><a href=\"#自省\" class=\"headerlink\" title=\"自省\"></a>自省</h1><h2 id=\"-4\"><a href=\"#-4\" class=\"headerlink\" title=\".\"></a>.</h2><h3 id=\"-5\"><a href=\"#-5\" class=\"headerlink\" title=\".\"></a>.</h3><h4 id=\"getattr\"><a href=\"#getattr\" class=\"headerlink\" title=\"getattr()\"></a>getattr()</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">getattr(object, name[, default]) -&gt; value</span></span><br><span class=\"line\"><span class=\"string\">其中 name 可以是字符串.</span></span><br><span class=\"line\"><span class=\"string\">这样的话 相当于 name可以用字符串代替 就不用一大堆`if elif else`了</span></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br><span class=\"line\">getattr(object, name[, default]) -&gt; value</span><br><span class=\"line\">&lt;==&gt;</span><br><span class=\"line\">object.name(value)</span><br></pre></td></tr></table></figure>"},{"title":"GraduationProject","date":"2018-09-23T07:33:11.000Z","description":"tabris的毕业设计","toc":true,"_content":"\n\n> 在这里记录一下我的毕业设计\n> 链接在[GitHub](https://github.com/tabris233/GraduationProject)上\n\n","source":"_posts/GraduationProject.md","raw":"---\ntitle: GraduationProject\ndate: 2018-09-23 15:33:11\ncategories:  \ntags: [毕业设计] #文章标签，可空，多标签请用格式，注意:后面有个空格\ndescription: tabris的毕业设计 \ntoc: true\n---\n\n\n> 在这里记录一下我的毕业设计\n> 链接在[GitHub](https://github.com/tabris233/GraduationProject)上\n\n","slug":"GraduationProject","published":1,"updated":"2018-09-23T07:55:34.598Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnyhsxma0002as1oejv9mei7","content":"<blockquote>\n<p>在这里记录一下我的毕业设计<br>链接在<a href=\"https://github.com/tabris233/GraduationProject\" target=\"_blank\" rel=\"noopener\">GitHub</a>上</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>在这里记录一下我的毕业设计<br>链接在<a href=\"https://github.com/tabris233/GraduationProject\" target=\"_blank\" rel=\"noopener\">GitHub</a>上</p>\n</blockquote>\n"},{"title":"必须要会的Git基本使用及常用命令操作","date":"2017-04-25T05:15:08.000Z","_content":"\n之前一直用的svn，后来换了之后才发现git的强大功能，是svn不能比的。缺点就是可能上手比较难一点，刚开始自己研究了两天才摸索出来一些基本使用方法。\n最近做项目需要建库等等，都用到了git，随着越来越多的使用，也越来有越多的认识。\n<!-- more -->\n一开始都是别人建好远程库，克隆下来就行了。\n下面内容只是带你git入门，一些基础的东西，是开发过程中一些基本的操作，单单这些你会用了之后就能发现他的好处，以及使用命令行Enter敲击时的快感，还能提高逼格。\n当然我们还是为了方便项目管理。\n \n#####安装\ngit工具下载地址，可以选择适合自己的操作系统：https://git-scm.com/downloads\n安装完git，要配置环境变量，拷贝git安装目录下的bin文件目录，如D:\\Program Files\\Git\\bin\n,将目录拷贝添加到PATH变量后。\n__注意：与前面的值要用“;”号隔开__\n具体步骤：\n> 右键计算机-属性-高级系统设置-环境变量-PATH将目录添加到后面，%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;D:\\Program Files\\Git\\bin\n\n安装完成后使用 ``git --version``命令查看一下git版本，测试是否安装、配置成功。\n#####克隆远程库\n使用cmd（安装过git直接可以右键文件夹使用``git bash here``）定位到要放置仓库的目录\n``git clone [远程仓库地址]``\n远程仓库就是托管到第三方平台上面的库。\n常用的有github，这个私有是收费的，要用免费的只能是公共的。\n目前国内用的比较多的[coding](https://coding.net/) ，和开源中国的[码云](http://git.oschina.net/)。原理都一样，只不过看起来会有点视觉上的差别，个人觉得coding比较简洁,适合学习，刚入门git的新手练习。而且视图更直观。\n码云是我现在用的，功能要比coding多，包括直接下载上传文件以及打包好的apk文件。\n\n在这里要说一下克隆的时候有的坑，__要克隆远程仓库必须是你在这个项目中，就是项目所有者（管理员）把你添加进这个项目成员__。输入克隆的指令后，如果是第一次使用会提示你输入用户名，和密码。\n\n前面步骤如果无误，之后会显示克隆的进度，直到完成克隆。\n\n#####创建代码库\n包括远程库（第三方平台）、本地库（存放代码信息）。\n- 创建远程库：根据第三方平台提示进行创建，一般都有步骤说明，按照说明来就好。\n创建完成后建议初始化一下仓库，\n可以在远程上根据提示，创建使用README.md文件初始化项目。\n也可以使用git命令：\n```\ngit init\necho \"# HelloWorld\" >> README.md\ngit add README.md\ngit commit -m \"first commit\"\n```\n建议使用前者，直接在第三方上创建。\n- 创建本地仓库：有两种方法\n1、使用git命令\n``git init``\n2、android Studio中（这里使用AS为例，其它的IDEA、webStorm操作都一样）\n点击``VCS-import into version control-create git repository``\n会弹出选择仓库的路径，直接选当前项目就行，然后确定。\n创建完之后，找到项目路径会发现文件夹下多了个.git文件，这个就是存放代码的仓库。\n而且项目中的文件的名称都会变为红色，说明已经有仓库了，但是这些红色的项目文件，并没有加到本地仓库（.git仓库文件中）。\n__（关于颜色后面我会具体说，各种颜色代表的状态）__\n- 关联本地和远程库\n关联就是把本地仓库的.git仓库文件，和远程（coding）创建的仓库联系起来，每次提交代码，将本地.git中代码，提交到远程库。\n使用命令：\n``git remote add origin [远程仓库地址]``\n如果是首次使用，会提示输入用户名+密码，用户名一般是邮箱，输错是关联不成功的。\n关联成功则无提示，接着输入命令\n``git push origin master``\n如果失败，很大可能是远程仓库已存在文件。可以执行\n``git push -f origin master``强制提交。\n提交过程是能看到进度的。\n提交完成后可以去平台上查看有没有代码就知道是否成功。\n\n\n\n__注意：所有命令行操作必须使用cmd或者git bash定位到项目目录下__\n\n#####仓库基本使用\n提交过程：\n``右键项目-git-add，弹框，选择是``；\n这时候只是把代码添加到本地仓库，\n``再右键项目选择commit  directory 在弹框的commit message中输入提交信息，选择commit and push``\n然后会显示进度。\n在多人协作开发一个项目的时候，提交之前一定要先pull一下（``VCS - pull``）,如果有冲突，选择合并或者是选择远程的，还是本地的，三者选一。\n处理好这些再进行提交操作。\n#####分支管理\n分支作为git一个重要的存在，可以进行版本回退，或者协作开发都是一个很便利的存在。\n在创建仓库的时候，默认会有个master分支，如果是首次开发，则不需要创建分支。\n但是在版本迭代的时候，特别是大版本迭代，就用到了分支，分支是相互独立存在的仓库。\n互不影响，在克隆的时候切换一下分支，就会把不同分支下的仓库内容拷贝过来，就像1.0、2.0版本，是分开的，1.0在master分支，2.0版本在maste2分支，可以随时修改历史版本。\n\n__常用命令__\n创建并切换到新建分支：\n``git checkout -b master2``\n切换分支：\n``git checkout master2``\n删除分支：\n``git branch -d fmaster2``\n将分支推送到远程仓库：\n``git push origin <branch>``\n\n#####关于颜色\n白色（正常色）：未改动或者没有仓库时的颜色。上\n红色：未添加仓库的，在创建仓库时会出现。\n绿色：已添加到本地仓库，没有进行commit push提交远程的。\n蓝色：修改已经提交到本地仓库的代码。\n\n\n#####常见问题\n\n>有一种情况是提交/强制提交的时候出现\n\n``\nerror: src refspec master does not match any.\nerror: failed to push some refs to 'https://github.com/wapchief/chat-room-JFrame.git'\n``\n说明是本地代码库为空\n解决办法：\n1、在项目中，如android studio，打开项目，右键->Git->+Add，然后重新右键->Git->commit Directory->commit and push->commit。执行之后会发现代码文件颜色都变成正常的白色，之后回到命令行执行提交操作\n2、在本地仓库创建一个文件，推送到仓库\n``touch README\ngit add README \ngit commit -m 'first commit'\ngit push origin master``\n如果按照上面的步骤来的话是不会出现这种情况的，这种情况出现于已有现成的项目，并且本地项目的代码未提交到本地仓库。这时候提交到远程，就会判定你本地仓库为空。\n\n> 补充一个在提交过程中出现无法解决问题的办法\n\n如果在使用命令行操作时出现无法解决的错误，直接进入到项目文件，删除``.git``文件,然后右键该项目目录，或者使用cmd定位到该目录，重新执行\n```\ngit init  #初始化本地仓库\ngit remote add origin [远程库地址]  #关联远程库\ngit add . #提交本地代码到本地仓库的暂存区\ngit commit -m '[提交说明]' #提交本地代码到本地仓库，并附上提交说明\ngit push -f origin master #强制推送到远程库\n```\n___\n关于这些只是对于刚入门的学习者有些帮助，在我学习的时候也遇到了好多坑，至今有些问题还能遇到，但是不至于手忙脚乱，起码知道问题出在了哪个环节。\nGit是一个很强大的版本控制工具，有很多功能，需要尝试去深入研究，希望学习者能够感受到他带来的便捷。","source":"_posts/StudyOfGit.md","raw":"---\ntitle: 必须要会的Git基本使用及常用命令操作\ndate: 2017-4-25 13:15:08\ncategories: \ntags: [git] #文章标签，可空，多标签请用格式，注意:后面有个空格\n\n---\n\n之前一直用的svn，后来换了之后才发现git的强大功能，是svn不能比的。缺点就是可能上手比较难一点，刚开始自己研究了两天才摸索出来一些基本使用方法。\n最近做项目需要建库等等，都用到了git，随着越来越多的使用，也越来有越多的认识。\n<!-- more -->\n一开始都是别人建好远程库，克隆下来就行了。\n下面内容只是带你git入门，一些基础的东西，是开发过程中一些基本的操作，单单这些你会用了之后就能发现他的好处，以及使用命令行Enter敲击时的快感，还能提高逼格。\n当然我们还是为了方便项目管理。\n \n#####安装\ngit工具下载地址，可以选择适合自己的操作系统：https://git-scm.com/downloads\n安装完git，要配置环境变量，拷贝git安装目录下的bin文件目录，如D:\\Program Files\\Git\\bin\n,将目录拷贝添加到PATH变量后。\n__注意：与前面的值要用“;”号隔开__\n具体步骤：\n> 右键计算机-属性-高级系统设置-环境变量-PATH将目录添加到后面，%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;D:\\Program Files\\Git\\bin\n\n安装完成后使用 ``git --version``命令查看一下git版本，测试是否安装、配置成功。\n#####克隆远程库\n使用cmd（安装过git直接可以右键文件夹使用``git bash here``）定位到要放置仓库的目录\n``git clone [远程仓库地址]``\n远程仓库就是托管到第三方平台上面的库。\n常用的有github，这个私有是收费的，要用免费的只能是公共的。\n目前国内用的比较多的[coding](https://coding.net/) ，和开源中国的[码云](http://git.oschina.net/)。原理都一样，只不过看起来会有点视觉上的差别，个人觉得coding比较简洁,适合学习，刚入门git的新手练习。而且视图更直观。\n码云是我现在用的，功能要比coding多，包括直接下载上传文件以及打包好的apk文件。\n\n在这里要说一下克隆的时候有的坑，__要克隆远程仓库必须是你在这个项目中，就是项目所有者（管理员）把你添加进这个项目成员__。输入克隆的指令后，如果是第一次使用会提示你输入用户名，和密码。\n\n前面步骤如果无误，之后会显示克隆的进度，直到完成克隆。\n\n#####创建代码库\n包括远程库（第三方平台）、本地库（存放代码信息）。\n- 创建远程库：根据第三方平台提示进行创建，一般都有步骤说明，按照说明来就好。\n创建完成后建议初始化一下仓库，\n可以在远程上根据提示，创建使用README.md文件初始化项目。\n也可以使用git命令：\n```\ngit init\necho \"# HelloWorld\" >> README.md\ngit add README.md\ngit commit -m \"first commit\"\n```\n建议使用前者，直接在第三方上创建。\n- 创建本地仓库：有两种方法\n1、使用git命令\n``git init``\n2、android Studio中（这里使用AS为例，其它的IDEA、webStorm操作都一样）\n点击``VCS-import into version control-create git repository``\n会弹出选择仓库的路径，直接选当前项目就行，然后确定。\n创建完之后，找到项目路径会发现文件夹下多了个.git文件，这个就是存放代码的仓库。\n而且项目中的文件的名称都会变为红色，说明已经有仓库了，但是这些红色的项目文件，并没有加到本地仓库（.git仓库文件中）。\n__（关于颜色后面我会具体说，各种颜色代表的状态）__\n- 关联本地和远程库\n关联就是把本地仓库的.git仓库文件，和远程（coding）创建的仓库联系起来，每次提交代码，将本地.git中代码，提交到远程库。\n使用命令：\n``git remote add origin [远程仓库地址]``\n如果是首次使用，会提示输入用户名+密码，用户名一般是邮箱，输错是关联不成功的。\n关联成功则无提示，接着输入命令\n``git push origin master``\n如果失败，很大可能是远程仓库已存在文件。可以执行\n``git push -f origin master``强制提交。\n提交过程是能看到进度的。\n提交完成后可以去平台上查看有没有代码就知道是否成功。\n\n\n\n__注意：所有命令行操作必须使用cmd或者git bash定位到项目目录下__\n\n#####仓库基本使用\n提交过程：\n``右键项目-git-add，弹框，选择是``；\n这时候只是把代码添加到本地仓库，\n``再右键项目选择commit  directory 在弹框的commit message中输入提交信息，选择commit and push``\n然后会显示进度。\n在多人协作开发一个项目的时候，提交之前一定要先pull一下（``VCS - pull``）,如果有冲突，选择合并或者是选择远程的，还是本地的，三者选一。\n处理好这些再进行提交操作。\n#####分支管理\n分支作为git一个重要的存在，可以进行版本回退，或者协作开发都是一个很便利的存在。\n在创建仓库的时候，默认会有个master分支，如果是首次开发，则不需要创建分支。\n但是在版本迭代的时候，特别是大版本迭代，就用到了分支，分支是相互独立存在的仓库。\n互不影响，在克隆的时候切换一下分支，就会把不同分支下的仓库内容拷贝过来，就像1.0、2.0版本，是分开的，1.0在master分支，2.0版本在maste2分支，可以随时修改历史版本。\n\n__常用命令__\n创建并切换到新建分支：\n``git checkout -b master2``\n切换分支：\n``git checkout master2``\n删除分支：\n``git branch -d fmaster2``\n将分支推送到远程仓库：\n``git push origin <branch>``\n\n#####关于颜色\n白色（正常色）：未改动或者没有仓库时的颜色。上\n红色：未添加仓库的，在创建仓库时会出现。\n绿色：已添加到本地仓库，没有进行commit push提交远程的。\n蓝色：修改已经提交到本地仓库的代码。\n\n\n#####常见问题\n\n>有一种情况是提交/强制提交的时候出现\n\n``\nerror: src refspec master does not match any.\nerror: failed to push some refs to 'https://github.com/wapchief/chat-room-JFrame.git'\n``\n说明是本地代码库为空\n解决办法：\n1、在项目中，如android studio，打开项目，右键->Git->+Add，然后重新右键->Git->commit Directory->commit and push->commit。执行之后会发现代码文件颜色都变成正常的白色，之后回到命令行执行提交操作\n2、在本地仓库创建一个文件，推送到仓库\n``touch README\ngit add README \ngit commit -m 'first commit'\ngit push origin master``\n如果按照上面的步骤来的话是不会出现这种情况的，这种情况出现于已有现成的项目，并且本地项目的代码未提交到本地仓库。这时候提交到远程，就会判定你本地仓库为空。\n\n> 补充一个在提交过程中出现无法解决问题的办法\n\n如果在使用命令行操作时出现无法解决的错误，直接进入到项目文件，删除``.git``文件,然后右键该项目目录，或者使用cmd定位到该目录，重新执行\n```\ngit init  #初始化本地仓库\ngit remote add origin [远程库地址]  #关联远程库\ngit add . #提交本地代码到本地仓库的暂存区\ngit commit -m '[提交说明]' #提交本地代码到本地仓库，并附上提交说明\ngit push -f origin master #强制推送到远程库\n```\n___\n关于这些只是对于刚入门的学习者有些帮助，在我学习的时候也遇到了好多坑，至今有些问题还能遇到，但是不至于手忙脚乱，起码知道问题出在了哪个环节。\nGit是一个很强大的版本控制工具，有很多功能，需要尝试去深入研究，希望学习者能够感受到他带来的便捷。","slug":"StudyOfGit","published":1,"updated":"2018-09-23T07:59:57.417Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnyhsxmf0003as1oatnp6p59","content":"<p>之前一直用的svn，后来换了之后才发现git的强大功能，是svn不能比的。缺点就是可能上手比较难一点，刚开始自己研究了两天才摸索出来一些基本使用方法。<br>最近做项目需要建库等等，都用到了git，随着越来越多的使用，也越来有越多的认识。<br><a id=\"more\"></a><br>一开始都是别人建好远程库，克隆下来就行了。<br>下面内容只是带你git入门，一些基础的东西，是开发过程中一些基本的操作，单单这些你会用了之后就能发现他的好处，以及使用命令行Enter敲击时的快感，还能提高逼格。<br>当然我们还是为了方便项目管理。</p>\n<p>#####安装<br>git工具下载地址，可以选择适合自己的操作系统：<a href=\"https://git-scm.com/downloads\" target=\"_blank\" rel=\"noopener\">https://git-scm.com/downloads</a><br>安装完git，要配置环境变量，拷贝git安装目录下的bin文件目录，如D:\\Program Files\\Git\\bin<br>,将目录拷贝添加到PATH变量后。<br><strong>注意：与前面的值要用“;”号隔开</strong><br>具体步骤：</p>\n<blockquote>\n<p>右键计算机-属性-高级系统设置-环境变量-PATH将目录添加到后面，%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;D:\\Program Files\\Git\\bin</p>\n</blockquote>\n<p>安装完成后使用 <code>git --version</code>命令查看一下git版本，测试是否安装、配置成功。</p>\n<p>#####克隆远程库<br>使用cmd（安装过git直接可以右键文件夹使用<code>git bash here</code>）定位到要放置仓库的目录<br><code>git clone [远程仓库地址]</code><br>远程仓库就是托管到第三方平台上面的库。<br>常用的有github，这个私有是收费的，要用免费的只能是公共的。<br>目前国内用的比较多的<a href=\"https://coding.net/\" target=\"_blank\" rel=\"noopener\">coding</a> ，和开源中国的<a href=\"http://git.oschina.net/\" target=\"_blank\" rel=\"noopener\">码云</a>。原理都一样，只不过看起来会有点视觉上的差别，个人觉得coding比较简洁,适合学习，刚入门git的新手练习。而且视图更直观。<br>码云是我现在用的，功能要比coding多，包括直接下载上传文件以及打包好的apk文件。</p>\n<p>在这里要说一下克隆的时候有的坑，<strong>要克隆远程仓库必须是你在这个项目中，就是项目所有者（管理员）把你添加进这个项目成员</strong>。输入克隆的指令后，如果是第一次使用会提示你输入用户名，和密码。</p>\n<p>前面步骤如果无误，之后会显示克隆的进度，直到完成克隆。</p>\n<p>#####创建代码库<br>包括远程库（第三方平台）、本地库（存放代码信息）。</p>\n<ul>\n<li>创建远程库：根据第三方平台提示进行创建，一般都有步骤说明，按照说明来就好。<br>创建完成后建议初始化一下仓库，<br>可以在远程上根据提示，创建使用README.md文件初始化项目。<br>也可以使用git命令：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br><span class=\"line\">echo &quot;# HelloWorld&quot; &gt;&gt; README.md</span><br><span class=\"line\">git add README.md</span><br><span class=\"line\">git commit -m &quot;first commit&quot;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>建议使用前者，直接在第三方上创建。</p>\n<ul>\n<li>创建本地仓库：有两种方法<br>1、使用git命令<br><code>git init</code><br>2、android Studio中（这里使用AS为例，其它的IDEA、webStorm操作都一样）<br>点击<code>VCS-import into version control-create git repository</code><br>会弹出选择仓库的路径，直接选当前项目就行，然后确定。<br>创建完之后，找到项目路径会发现文件夹下多了个.git文件，这个就是存放代码的仓库。<br>而且项目中的文件的名称都会变为红色，说明已经有仓库了，但是这些红色的项目文件，并没有加到本地仓库（.git仓库文件中）。<br><strong>（关于颜色后面我会具体说，各种颜色代表的状态）</strong></li>\n<li>关联本地和远程库<br>关联就是把本地仓库的.git仓库文件，和远程（coding）创建的仓库联系起来，每次提交代码，将本地.git中代码，提交到远程库。<br>使用命令：<br><code>git remote add origin [远程仓库地址]</code><br>如果是首次使用，会提示输入用户名+密码，用户名一般是邮箱，输错是关联不成功的。<br>关联成功则无提示，接着输入命令<br><code>git push origin master</code><br>如果失败，很大可能是远程仓库已存在文件。可以执行<br><code>git push -f origin master</code>强制提交。<br>提交过程是能看到进度的。<br>提交完成后可以去平台上查看有没有代码就知道是否成功。</li>\n</ul>\n<p><strong>注意：所有命令行操作必须使用cmd或者git bash定位到项目目录下</strong></p>\n<p>#####仓库基本使用<br>提交过程：<br><code>右键项目-git-add，弹框，选择是</code>；<br>这时候只是把代码添加到本地仓库，<br><code>再右键项目选择commit  directory 在弹框的commit message中输入提交信息，选择commit and push</code><br>然后会显示进度。<br>在多人协作开发一个项目的时候，提交之前一定要先pull一下（<code>VCS - pull</code>）,如果有冲突，选择合并或者是选择远程的，还是本地的，三者选一。<br>处理好这些再进行提交操作。</p>\n<p>#####分支管理<br>分支作为git一个重要的存在，可以进行版本回退，或者协作开发都是一个很便利的存在。<br>在创建仓库的时候，默认会有个master分支，如果是首次开发，则不需要创建分支。<br>但是在版本迭代的时候，特别是大版本迭代，就用到了分支，分支是相互独立存在的仓库。<br>互不影响，在克隆的时候切换一下分支，就会把不同分支下的仓库内容拷贝过来，就像1.0、2.0版本，是分开的，1.0在master分支，2.0版本在maste2分支，可以随时修改历史版本。</p>\n<p><strong>常用命令</strong><br>创建并切换到新建分支：<br><code>git checkout -b master2</code><br>切换分支：<br><code>git checkout master2</code><br>删除分支：<br><code>git branch -d fmaster2</code><br>将分支推送到远程仓库：<br><code>git push origin &lt;branch&gt;</code></p>\n<p>#####关于颜色<br>白色（正常色）：未改动或者没有仓库时的颜色。上<br>红色：未添加仓库的，在创建仓库时会出现。<br>绿色：已添加到本地仓库，没有进行commit push提交远程的。<br>蓝色：修改已经提交到本地仓库的代码。</p>\n<p>#####常见问题</p>\n<blockquote>\n<p>有一种情况是提交/强制提交的时候出现</p>\n</blockquote>\n<p><code>error: src refspec master does not match any.\nerror: failed to push some refs to &#39;https://github.com/wapchief/chat-room-JFrame.git&#39;</code><br>说明是本地代码库为空<br>解决办法：<br>1、在项目中，如android studio，打开项目，右键-&gt;Git-&gt;+Add，然后重新右键-&gt;Git-&gt;commit Directory-&gt;commit and push-&gt;commit。执行之后会发现代码文件颜色都变成正常的白色，之后回到命令行执行提交操作<br>2、在本地仓库创建一个文件，推送到仓库<br><code>touch README\ngit add README \ngit commit -m &#39;first commit&#39;\ngit push origin master</code><br>如果按照上面的步骤来的话是不会出现这种情况的，这种情况出现于已有现成的项目，并且本地项目的代码未提交到本地仓库。这时候提交到远程，就会判定你本地仓库为空。</p>\n<blockquote>\n<p>补充一个在提交过程中出现无法解决问题的办法</p>\n</blockquote>\n<p>如果在使用命令行操作时出现无法解决的错误，直接进入到项目文件，删除<code>.git</code>文件,然后右键该项目目录，或者使用cmd定位到该目录，重新执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init  #初始化本地仓库</span><br><span class=\"line\">git remote add origin [远程库地址]  #关联远程库</span><br><span class=\"line\">git add . #提交本地代码到本地仓库的暂存区</span><br><span class=\"line\">git commit -m &apos;[提交说明]&apos; #提交本地代码到本地仓库，并附上提交说明</span><br><span class=\"line\">git push -f origin master #强制推送到远程库</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>关于这些只是对于刚入门的学习者有些帮助，在我学习的时候也遇到了好多坑，至今有些问题还能遇到，但是不至于手忙脚乱，起码知道问题出在了哪个环节。<br>Git是一个很强大的版本控制工具，有很多功能，需要尝试去深入研究，希望学习者能够感受到他带来的便捷。</p>\n","site":{"data":{}},"excerpt":"<p>之前一直用的svn，后来换了之后才发现git的强大功能，是svn不能比的。缺点就是可能上手比较难一点，刚开始自己研究了两天才摸索出来一些基本使用方法。<br>最近做项目需要建库等等，都用到了git，随着越来越多的使用，也越来有越多的认识。<br>","more":"<br>一开始都是别人建好远程库，克隆下来就行了。<br>下面内容只是带你git入门，一些基础的东西，是开发过程中一些基本的操作，单单这些你会用了之后就能发现他的好处，以及使用命令行Enter敲击时的快感，还能提高逼格。<br>当然我们还是为了方便项目管理。</p>\n<p>#####安装<br>git工具下载地址，可以选择适合自己的操作系统：<a href=\"https://git-scm.com/downloads\" target=\"_blank\" rel=\"noopener\">https://git-scm.com/downloads</a><br>安装完git，要配置环境变量，拷贝git安装目录下的bin文件目录，如D:\\Program Files\\Git\\bin<br>,将目录拷贝添加到PATH变量后。<br><strong>注意：与前面的值要用“;”号隔开</strong><br>具体步骤：</p>\n<blockquote>\n<p>右键计算机-属性-高级系统设置-环境变量-PATH将目录添加到后面，%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;D:\\Program Files\\Git\\bin</p>\n</blockquote>\n<p>安装完成后使用 <code>git --version</code>命令查看一下git版本，测试是否安装、配置成功。</p>\n<p>#####克隆远程库<br>使用cmd（安装过git直接可以右键文件夹使用<code>git bash here</code>）定位到要放置仓库的目录<br><code>git clone [远程仓库地址]</code><br>远程仓库就是托管到第三方平台上面的库。<br>常用的有github，这个私有是收费的，要用免费的只能是公共的。<br>目前国内用的比较多的<a href=\"https://coding.net/\" target=\"_blank\" rel=\"noopener\">coding</a> ，和开源中国的<a href=\"http://git.oschina.net/\" target=\"_blank\" rel=\"noopener\">码云</a>。原理都一样，只不过看起来会有点视觉上的差别，个人觉得coding比较简洁,适合学习，刚入门git的新手练习。而且视图更直观。<br>码云是我现在用的，功能要比coding多，包括直接下载上传文件以及打包好的apk文件。</p>\n<p>在这里要说一下克隆的时候有的坑，<strong>要克隆远程仓库必须是你在这个项目中，就是项目所有者（管理员）把你添加进这个项目成员</strong>。输入克隆的指令后，如果是第一次使用会提示你输入用户名，和密码。</p>\n<p>前面步骤如果无误，之后会显示克隆的进度，直到完成克隆。</p>\n<p>#####创建代码库<br>包括远程库（第三方平台）、本地库（存放代码信息）。</p>\n<ul>\n<li>创建远程库：根据第三方平台提示进行创建，一般都有步骤说明，按照说明来就好。<br>创建完成后建议初始化一下仓库，<br>可以在远程上根据提示，创建使用README.md文件初始化项目。<br>也可以使用git命令：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br><span class=\"line\">echo &quot;# HelloWorld&quot; &gt;&gt; README.md</span><br><span class=\"line\">git add README.md</span><br><span class=\"line\">git commit -m &quot;first commit&quot;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>建议使用前者，直接在第三方上创建。</p>\n<ul>\n<li>创建本地仓库：有两种方法<br>1、使用git命令<br><code>git init</code><br>2、android Studio中（这里使用AS为例，其它的IDEA、webStorm操作都一样）<br>点击<code>VCS-import into version control-create git repository</code><br>会弹出选择仓库的路径，直接选当前项目就行，然后确定。<br>创建完之后，找到项目路径会发现文件夹下多了个.git文件，这个就是存放代码的仓库。<br>而且项目中的文件的名称都会变为红色，说明已经有仓库了，但是这些红色的项目文件，并没有加到本地仓库（.git仓库文件中）。<br><strong>（关于颜色后面我会具体说，各种颜色代表的状态）</strong></li>\n<li>关联本地和远程库<br>关联就是把本地仓库的.git仓库文件，和远程（coding）创建的仓库联系起来，每次提交代码，将本地.git中代码，提交到远程库。<br>使用命令：<br><code>git remote add origin [远程仓库地址]</code><br>如果是首次使用，会提示输入用户名+密码，用户名一般是邮箱，输错是关联不成功的。<br>关联成功则无提示，接着输入命令<br><code>git push origin master</code><br>如果失败，很大可能是远程仓库已存在文件。可以执行<br><code>git push -f origin master</code>强制提交。<br>提交过程是能看到进度的。<br>提交完成后可以去平台上查看有没有代码就知道是否成功。</li>\n</ul>\n<p><strong>注意：所有命令行操作必须使用cmd或者git bash定位到项目目录下</strong></p>\n<p>#####仓库基本使用<br>提交过程：<br><code>右键项目-git-add，弹框，选择是</code>；<br>这时候只是把代码添加到本地仓库，<br><code>再右键项目选择commit  directory 在弹框的commit message中输入提交信息，选择commit and push</code><br>然后会显示进度。<br>在多人协作开发一个项目的时候，提交之前一定要先pull一下（<code>VCS - pull</code>）,如果有冲突，选择合并或者是选择远程的，还是本地的，三者选一。<br>处理好这些再进行提交操作。</p>\n<p>#####分支管理<br>分支作为git一个重要的存在，可以进行版本回退，或者协作开发都是一个很便利的存在。<br>在创建仓库的时候，默认会有个master分支，如果是首次开发，则不需要创建分支。<br>但是在版本迭代的时候，特别是大版本迭代，就用到了分支，分支是相互独立存在的仓库。<br>互不影响，在克隆的时候切换一下分支，就会把不同分支下的仓库内容拷贝过来，就像1.0、2.0版本，是分开的，1.0在master分支，2.0版本在maste2分支，可以随时修改历史版本。</p>\n<p><strong>常用命令</strong><br>创建并切换到新建分支：<br><code>git checkout -b master2</code><br>切换分支：<br><code>git checkout master2</code><br>删除分支：<br><code>git branch -d fmaster2</code><br>将分支推送到远程仓库：<br><code>git push origin &lt;branch&gt;</code></p>\n<p>#####关于颜色<br>白色（正常色）：未改动或者没有仓库时的颜色。上<br>红色：未添加仓库的，在创建仓库时会出现。<br>绿色：已添加到本地仓库，没有进行commit push提交远程的。<br>蓝色：修改已经提交到本地仓库的代码。</p>\n<p>#####常见问题</p>\n<blockquote>\n<p>有一种情况是提交/强制提交的时候出现</p>\n</blockquote>\n<p><code>error: src refspec master does not match any.\nerror: failed to push some refs to &#39;https://github.com/wapchief/chat-room-JFrame.git&#39;</code><br>说明是本地代码库为空<br>解决办法：<br>1、在项目中，如android studio，打开项目，右键-&gt;Git-&gt;+Add，然后重新右键-&gt;Git-&gt;commit Directory-&gt;commit and push-&gt;commit。执行之后会发现代码文件颜色都变成正常的白色，之后回到命令行执行提交操作<br>2、在本地仓库创建一个文件，推送到仓库<br><code>touch README\ngit add README \ngit commit -m &#39;first commit&#39;\ngit push origin master</code><br>如果按照上面的步骤来的话是不会出现这种情况的，这种情况出现于已有现成的项目，并且本地项目的代码未提交到本地仓库。这时候提交到远程，就会判定你本地仓库为空。</p>\n<blockquote>\n<p>补充一个在提交过程中出现无法解决问题的办法</p>\n</blockquote>\n<p>如果在使用命令行操作时出现无法解决的错误，直接进入到项目文件，删除<code>.git</code>文件,然后右键该项目目录，或者使用cmd定位到该目录，重新执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init  #初始化本地仓库</span><br><span class=\"line\">git remote add origin [远程库地址]  #关联远程库</span><br><span class=\"line\">git add . #提交本地代码到本地仓库的暂存区</span><br><span class=\"line\">git commit -m &apos;[提交说明]&apos; #提交本地代码到本地仓库，并附上提交说明</span><br><span class=\"line\">git push -f origin master #强制推送到远程库</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>关于这些只是对于刚入门的学习者有些帮助，在我学习的时候也遇到了好多坑，至今有些问题还能遇到，但是不至于手忙脚乱，起码知道问题出在了哪个环节。<br>Git是一个很强大的版本控制工具，有很多功能，需要尝试去深入研究，希望学习者能够感受到他带来的便捷。</p>"},{"title":"Hello World","date":"2018-01-25T13:00:08.000Z","description":null,"toc":true,"_content":"\n# Hello World\n\ntabris的个人博客终于搭建成功啦,百度不收录的博客权当自己的学习笔记+矫情的地方.\n\nACM退役啦,不知道学些什么:\n机器学习感觉智商和数学水平够不上.\nC++也不好找工作.\nJava还不想学.\n前端更是不想学.\n\n学学大数据\n投后台开发岗和大数据岗\n\n失业了就回家种地\n\n所以先学些必备的技能.\n\n- git\n- IDE 使用.\n- so on\n\n\n> let's begin. \n>        --tabris\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2018-1-25 21:00:08\ncategories:  \ntags: [随笔] #文章标签，可空，多标签请用格式，注意:后面有个空格\ndescription: \ntoc: true\n---\n\n# Hello World\n\ntabris的个人博客终于搭建成功啦,百度不收录的博客权当自己的学习笔记+矫情的地方.\n\nACM退役啦,不知道学些什么:\n机器学习感觉智商和数学水平够不上.\nC++也不好找工作.\nJava还不想学.\n前端更是不想学.\n\n学学大数据\n投后台开发岗和大数据岗\n\n失业了就回家种地\n\n所以先学些必备的技能.\n\n- git\n- IDE 使用.\n- so on\n\n\n> let's begin. \n>        --tabris\n","slug":"hello-world","published":1,"updated":"2018-09-23T07:55:34.630Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnyhsxmk0005as1on4yddivs","content":"<h1 id=\"Hello-World\"><a href=\"#Hello-World\" class=\"headerlink\" title=\"Hello World\"></a>Hello World</h1><p>tabris的个人博客终于搭建成功啦,百度不收录的博客权当自己的学习笔记+矫情的地方.</p>\n<p>ACM退役啦,不知道学些什么:<br>机器学习感觉智商和数学水平够不上.<br>C++也不好找工作.<br>Java还不想学.<br>前端更是不想学.</p>\n<p>学学大数据<br>投后台开发岗和大数据岗</p>\n<p>失业了就回家种地</p>\n<p>所以先学些必备的技能.</p>\n<ul>\n<li>git</li>\n<li>IDE 使用.</li>\n<li>so on</li>\n</ul>\n<blockquote>\n<p>let’s begin.<br>       –tabris</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Hello-World\"><a href=\"#Hello-World\" class=\"headerlink\" title=\"Hello World\"></a>Hello World</h1><p>tabris的个人博客终于搭建成功啦,百度不收录的博客权当自己的学习笔记+矫情的地方.</p>\n<p>ACM退役啦,不知道学些什么:<br>机器学习感觉智商和数学水平够不上.<br>C++也不好找工作.<br>Java还不想学.<br>前端更是不想学.</p>\n<p>学学大数据<br>投后台开发岗和大数据岗</p>\n<p>失业了就回家种地</p>\n<p>所以先学些必备的技能.</p>\n<ul>\n<li>git</li>\n<li>IDE 使用.</li>\n<li>so on</li>\n</ul>\n<blockquote>\n<p>let’s begin.<br>       –tabris</p>\n</blockquote>\n"},{"title":"StudyLinux----arch","date":"2018-09-23T09:21:03.000Z","description":["Arch 作为'最难'安装的linux系统  通过它可以更好的了解linux"],"toc":true,"_content":"\n# Arch 踩坑笔记\n\n> 记录一下从0开始玩linux的经历\n>\n> 其实之前已经有了一点ubuntu的使用经验 但是很浅\n>\n>Arch 作为'最难'安装的linux系统  通过它可以更好的了解linux\n>\n> 这里是VMware安装的Arch虚拟机\n> [配置和美化Arch Linux](https://blog.csdn.net/u011054333/article/details/50631599)\n## 安装:\n\n这里参考\n\n> [这是最全面的安装指南](https://www.viseator.com/2017/05/17/arch_install/)\n\n## 基础设置:\n\n#### 创建新用户\n```\n# useradd -m -G wheel username （请自行替换username为你的用户名）\n# passwd username （请自行替换username为你的用户名）\n```\n#### 开机自动联网\n\n```shell\n# systemctl enable dhcpcd\n```\n\n#### 网络工具\n\n```shell\n# pacman -Syy net-tools\n```\n\n#### 时间\n\n装完archlinux，时间总是比实际快了8个小时，找了各种办法，最终使用了openNTPD的方法\n\n设置时区：`sudo ln sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime`\n\n安装openNTPD：`sudo pacman -S openntpd`\n\n重启openNTPD：`systemctl restart openntpd`\n\n设置开机启动：`systemctl enable openntpd`\n\n\n#### ssh\n安装ssh\n```\n# pacman -Syy openssh\n```\n启动服务\n```\n# systemctl start sshd\n```\n开机启动\n```\n# systemctl enable sshd.service\n```\n\n\n#### aur助手\n[yay](https://github.com/Jguer/yay) 是下一个最好的 AUR 助手。它使用 Go 语言写成，宗旨是提供最少化用户输入的 `pacman` 界面、yaourt 式的搜索，而几乎没有任何依赖软件。\n\nyay 的特性：\n\n- `yay` 提供 AUR 表格补全，并且从 ABS 或 AUR 下载 PKGBUILD\n- 支持收窄搜索，并且不需要引用 PKGBUILD 源\n- `yay` 的二进制文件除了 `pacman` 以外别无依赖\n- 提供先进的包依赖解决方案，以及在编译安装之后移除编译时的依赖\n- 当在 `/etc/pacman.conf` 文件配置中启用了色彩时支持色彩输出\n- `yay` 可被配置成只支持 AUR 或者 repo 里的软件包\n\n安装 yay：\n\n你可以从 `git` 克隆并编译安装。\n\n```\ngit clone https://aur.archlinux.org/yay.gitcd yaymakepkg -si\n```\n\n使用 yay：\n\n搜索：\n\n```\nyay -Ss <package-name>\n```\n\n安装：\n\n```\nyay -S <package-name>\n```\n\n\n#### powerline\nPowerline 是 vim、zsh、bash、tmux、IPython、Awesome、bar、fish、lemonbar、pdb、rc、shell、tcsh、wm、i3 和 Qtil 中的一个状态栏插件。它给程序提供了状态栏，并使程序更好看。它用 Python 写成。\n\n## 命令行\n\n> linux 强大的命令行操作,使效率倍增,所以配置好命令行,并安装实用命令行软件是必要的\n\n#### zsh[^1]\n\n[^1]: [终端环境之Zsh＆oh-my-zsh](https://mtaoist.xyz/2018/03/14/oh-my-zsh/)\n\n```shell\nsudo pacman -S zsh zsh-completions\n\n# 将zsh设为默认shell\nchsh -s /bin/zsh\n#其他发行版可先用chsh -l 查看zsh安装位置\n```\n\n##### oh-my-zsh\n\n- curl 和 git 应该已被安装(若没有Arch 用sudo pacman -S curl git 安装，其他发行版类似。)\n\n- [Oh-my-zsh](http://ohmyz.sh/)是一个傻瓜化的zsh配置管理框架，提供了大量实用的功能，主题等。做到开箱即用，现在基本成为了Zsh的标配。\n\n- 安装\n\n  ```\n  sh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"\n  ```\n\n- 配置文件位置： ~/.zshrc\n\n- 主题\n  `oh-my-zsh`自带大量[Themes](https://github.com/robbyrussell/oh-my-zsh/wiki/Themes)，默认为`robbyrussell`。你也可以选择`random`，即每次打开终端随机选一个主题。\n\n  > ZSH_THEME=”你喜欢的主题名”\n  > ![themes](https://mtaoist.xyz/img/zsh_theme.png)\n\n- 常用插件\n\n  - git: 提供大量git的Aliases，[详情](https://github.com/robbyrussell/oh-my-zsh/wiki/Plugin:git)\n\n  - archlinux： 提供一些pacman包管理器的Aliases，[详情](https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins#archlinux)\n\n  - z：经常使用cd 切换路径，积累一定数据后可用z快速跳转到指定位置\n\n  - sudo：按两次[Esc]自动在前面加sudo\n\n  - pip： 补全pip 命令\n\n  - zsh-autosuggestions: 根据历史记录进行智能提示(按 ctrl+E 是正确姿势)。非oh-my-zsh自带，用git下载安装\n\n    ```\n    git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions\n    ```\n\n  - zsh-syntax-highlighting：命令高亮，正确显示绿色，错误为红色。非oh-my-zsh自带，用git下载安装\n\n    ```\n    git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting\n    ```\n\n    > plugins=( 你想启用的插件，空格分隔 )\n    > ![plugins](https://mtaoist.xyz/img/zsh_plugins.png)\n\n  - 重新加载配置文件，立刻生效。\n\n    > source ~/.zshrc\n\n- 其他插件请参见官方[wiki](https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins-Overview)\n\n- 少即是多，启用大量插件会严重拖慢zsh启动速度\n\n---\n\n我这里是在root下安装的,在`zsh`与`oh-my-zsh`的使用中,发现切换用户会出现错误\n\n```shell\nLast login: Sun Sep 16 14:21:35 2018 from 192.168.174.1\n/home/tabris/.zshrc:source:71: permission denied: /root/.oh-my-zsh/oh-my-zsh.sh\n```\n\n---\n\n我这里采用的是`agnoster`主题\n为在使用tmux时不重复显示`whoami@whereami`做两处修改\n- 在`/etc/profile`中添加环境变量\n  ```\n  DEFAULT_USER=$USER\n  ```\n- 在`agnoster`主题文件91行中做如下修改\n  ```git\n  - if [[ \"$USER\" != \"$DEFAULT_USER\" || -n \"$SSH_CLIENT\"]]; then\n  + if [[ \"$USER\" != \"$DEFAULT_USER\" || (( -n \"$SSH_CLIENT\" && -z \"$TMUX\" )) ]]; then\n  ```\n这样在本地初始打开一个terminal时不会显示,ssh远程连接是时显示\n进入tmux时不会显示\n\n\n原因是\n[Archlinux下安装和配置zsh](https://blog.csdn.net/kingolie/article/details/53066679)\n#### tmux\n\n安装tmux\n \n```shell\nsudo pacman -S tmux\n```\n\n在这里配置tmux\nhttps://github.com/search?utf8=%E2%9C%93&q=tmux&type=\nhttps://github.com/samoshkin/tmux-config  <--推荐这个配置\n\n[为 vim + tmux 开启真彩色(true color)](http://lotabout.me/2018/true-color-for-tmux-and-vim/)\n\n[tmux进阶之tmuxinator](https://blog.csdn.net/u014717036/article/details/60139776)\n\n#### neovim\n\n> neovim属于vim的加强版  功能更加强大\n\n注意的是启动neovim的命令式`nvim`而不是`neovim`\n\n同时安装 [nerd-fonts](https://gitee.com/hustlion-dev/nerd-fonts#option-3-install-script)\n\n\n##### spacevim\n\n一个定制化的vim配置,支持`vim,neovim`\n\n[官网](https://spacevim.org/)\n\n\n\n#### *Xshell下256/真色支持\n\n检查当前是否为256/真色[参考本篇文章](https://gaomf.cn/2017/01/16/Terminal_Color/)\n\n\n我这里的xshell只能支持256色\n\n这时xshell中只有在tmux下spacevim才能显示256色,不支持真色\n\n在.zshrc文件头添加\n```\nsh /${.zshrc的目录}/.change_term.sh\n```\n.change_term.sh文件内容如下\n```shell\necho \"before: $TERM\"\nif [ \"$TERM\" = \"linux\" ]\nthen\n  echo \"export TERM=xterm-256color\"\n  export TERM=xterm-256color\nelif [ \"$TERM\" = \"xterm\" ]\nthen\n  echo \"export TERM=tmux-direct\"\n  export TERM=tmux-direct\nelif [ \"$TERM\" = \"xterm-256color\" ]\nthen\n  echo \"export TERM=xterm-direct\"\n  export TERM=xterm-direct\nelse\n  echo \"export TERM=tmux-256color\"\n  export TERM=tmux-256color\nfi\necho \"now: $TERM\"\n# 如果是ssh自动启用tmux\nif [ -n \"$SSH_CLIENT\" ]\nthen\n  tmux\nfi\n\nclear \n```\n\n## 桌面环境\n\n> [参考](https://blog.csdn.net/kingolie/article/details/76723448)\n\n#### **1、安装显卡驱动**\n\n```\n# lspci | grep VGA    # 确定显卡型号\n# pacman -S <驱动包>\n#\n# # 官方仓库提供的驱动包：\n# # +----------------------+--------------------+--------------+\n# # |                      |        开源        |     私有     |\n# # +----------------------+--------------------+--------------+\n# # |         通用         |   xf86-video-vesa  |              |\n# # +----------------------+--------------------+--------------+\n# # |         Intel        |  xf86-video-intel  |              |\n# # +--------+-------------+--------------------+--------------+\n# # |        | GeForce 9+  |                    |    nvidia    |\n# # +        +-------------+                    +--------------+\n# # | nVidia | GeForce 8/9 | xf86-video-nouveau | nvidia-340xx |\n# # +        +-------------+                    +--------------+\n# # |        | GeForce 6/7 |                    | nvidia-304xx |\n# # +--------+-------------+--------------------+--------------+\n# # |        AMD/ATI       |   xf86-video-ati   |              |\n# # +----------------------+--------------------+--------------+12345678910111213141516171819\n```\n\n#### **2、安装桌面环境**\n\n所有桌面环境都需要依赖xorg。所以先要安装xorg组。\n\n```shell\npacman -S xorg\n```\n\n输入命令之后首先会询问要安装xorg组下的哪些包，选择全部。然后对于libgl包有个四个不同的实现，选择mesa-libgl。 \n然后再安装xorg-xinit和xterm：\n\n```shell\npacman -S xorg-xinit xterm\n```\n\n安装完成之后就可以使用startx命令启动xorg的简易界面了。进入成功的话会显示出几个简陋的窗口。然后按Ctrl+D就可以退出了。\n\n#### **3、安装xfce4桌面**\n\n安装xfce4桌面和附带的软件包：\n\n```shell\npacman -S xfce4 xfce4-goodies\n```\n\n#### **4、安装LightDM登录管理器(显示管理器)**\n\n详细安装和配置看arch-wiki-lighdm \n我没有通过startx的方式启动桌面环境，而是使用了登录管理器lightdm \n安装：\n\n```zsh\npacman -S lightdm lightdm-gtk-greeter\n```\n\n其配置文件为：\n/etc/lightdm/lightdm.conf \n安装好之后测试启动：\n\n```shell\nsystemctl start lightdm.service1\n```\n\n如果正常就会看到熟悉的登录界面了，不过不要登录，现在只是测试lightdm是否可以正常启动 \n点击画面上的关机小图标，弹出关机对话，选择注销! \n注销之后就回到之前的tty命令行模式了，可以看到相关的启动信息 \n一切正常，所以设置lightdm为开机自动启动，这样以后开机就不会出现tty命令行界面了，而是直接进入登录界面：\n\n```shell\nsystemctl enable lightdm.service\n```\n\n之后你可以重启进入xfce4图形界面，然后在图形界面中使用终端来继续以下配置步骤，也可以不重启，直接继续\n\n进入xfce4图形界面的命令为`startxfce4`\n\n\n\n#### 桌面美化\n\n\n\n[^1]: \n","source":"_posts/StudyLinux-arch.md","raw":"---\ntitle: StudyLinux----arch\ndate: 2018-09-23 17:21:03\ntags: [linux]\ndescription: [\"Arch 作为'最难'安装的linux系统  通过它可以更好的了解linux\"]\ntoc: true\n---\n\n# Arch 踩坑笔记\n\n> 记录一下从0开始玩linux的经历\n>\n> 其实之前已经有了一点ubuntu的使用经验 但是很浅\n>\n>Arch 作为'最难'安装的linux系统  通过它可以更好的了解linux\n>\n> 这里是VMware安装的Arch虚拟机\n> [配置和美化Arch Linux](https://blog.csdn.net/u011054333/article/details/50631599)\n## 安装:\n\n这里参考\n\n> [这是最全面的安装指南](https://www.viseator.com/2017/05/17/arch_install/)\n\n## 基础设置:\n\n#### 创建新用户\n```\n# useradd -m -G wheel username （请自行替换username为你的用户名）\n# passwd username （请自行替换username为你的用户名）\n```\n#### 开机自动联网\n\n```shell\n# systemctl enable dhcpcd\n```\n\n#### 网络工具\n\n```shell\n# pacman -Syy net-tools\n```\n\n#### 时间\n\n装完archlinux，时间总是比实际快了8个小时，找了各种办法，最终使用了openNTPD的方法\n\n设置时区：`sudo ln sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime`\n\n安装openNTPD：`sudo pacman -S openntpd`\n\n重启openNTPD：`systemctl restart openntpd`\n\n设置开机启动：`systemctl enable openntpd`\n\n\n#### ssh\n安装ssh\n```\n# pacman -Syy openssh\n```\n启动服务\n```\n# systemctl start sshd\n```\n开机启动\n```\n# systemctl enable sshd.service\n```\n\n\n#### aur助手\n[yay](https://github.com/Jguer/yay) 是下一个最好的 AUR 助手。它使用 Go 语言写成，宗旨是提供最少化用户输入的 `pacman` 界面、yaourt 式的搜索，而几乎没有任何依赖软件。\n\nyay 的特性：\n\n- `yay` 提供 AUR 表格补全，并且从 ABS 或 AUR 下载 PKGBUILD\n- 支持收窄搜索，并且不需要引用 PKGBUILD 源\n- `yay` 的二进制文件除了 `pacman` 以外别无依赖\n- 提供先进的包依赖解决方案，以及在编译安装之后移除编译时的依赖\n- 当在 `/etc/pacman.conf` 文件配置中启用了色彩时支持色彩输出\n- `yay` 可被配置成只支持 AUR 或者 repo 里的软件包\n\n安装 yay：\n\n你可以从 `git` 克隆并编译安装。\n\n```\ngit clone https://aur.archlinux.org/yay.gitcd yaymakepkg -si\n```\n\n使用 yay：\n\n搜索：\n\n```\nyay -Ss <package-name>\n```\n\n安装：\n\n```\nyay -S <package-name>\n```\n\n\n#### powerline\nPowerline 是 vim、zsh、bash、tmux、IPython、Awesome、bar、fish、lemonbar、pdb、rc、shell、tcsh、wm、i3 和 Qtil 中的一个状态栏插件。它给程序提供了状态栏，并使程序更好看。它用 Python 写成。\n\n## 命令行\n\n> linux 强大的命令行操作,使效率倍增,所以配置好命令行,并安装实用命令行软件是必要的\n\n#### zsh[^1]\n\n[^1]: [终端环境之Zsh＆oh-my-zsh](https://mtaoist.xyz/2018/03/14/oh-my-zsh/)\n\n```shell\nsudo pacman -S zsh zsh-completions\n\n# 将zsh设为默认shell\nchsh -s /bin/zsh\n#其他发行版可先用chsh -l 查看zsh安装位置\n```\n\n##### oh-my-zsh\n\n- curl 和 git 应该已被安装(若没有Arch 用sudo pacman -S curl git 安装，其他发行版类似。)\n\n- [Oh-my-zsh](http://ohmyz.sh/)是一个傻瓜化的zsh配置管理框架，提供了大量实用的功能，主题等。做到开箱即用，现在基本成为了Zsh的标配。\n\n- 安装\n\n  ```\n  sh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"\n  ```\n\n- 配置文件位置： ~/.zshrc\n\n- 主题\n  `oh-my-zsh`自带大量[Themes](https://github.com/robbyrussell/oh-my-zsh/wiki/Themes)，默认为`robbyrussell`。你也可以选择`random`，即每次打开终端随机选一个主题。\n\n  > ZSH_THEME=”你喜欢的主题名”\n  > ![themes](https://mtaoist.xyz/img/zsh_theme.png)\n\n- 常用插件\n\n  - git: 提供大量git的Aliases，[详情](https://github.com/robbyrussell/oh-my-zsh/wiki/Plugin:git)\n\n  - archlinux： 提供一些pacman包管理器的Aliases，[详情](https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins#archlinux)\n\n  - z：经常使用cd 切换路径，积累一定数据后可用z快速跳转到指定位置\n\n  - sudo：按两次[Esc]自动在前面加sudo\n\n  - pip： 补全pip 命令\n\n  - zsh-autosuggestions: 根据历史记录进行智能提示(按 ctrl+E 是正确姿势)。非oh-my-zsh自带，用git下载安装\n\n    ```\n    git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions\n    ```\n\n  - zsh-syntax-highlighting：命令高亮，正确显示绿色，错误为红色。非oh-my-zsh自带，用git下载安装\n\n    ```\n    git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting\n    ```\n\n    > plugins=( 你想启用的插件，空格分隔 )\n    > ![plugins](https://mtaoist.xyz/img/zsh_plugins.png)\n\n  - 重新加载配置文件，立刻生效。\n\n    > source ~/.zshrc\n\n- 其他插件请参见官方[wiki](https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins-Overview)\n\n- 少即是多，启用大量插件会严重拖慢zsh启动速度\n\n---\n\n我这里是在root下安装的,在`zsh`与`oh-my-zsh`的使用中,发现切换用户会出现错误\n\n```shell\nLast login: Sun Sep 16 14:21:35 2018 from 192.168.174.1\n/home/tabris/.zshrc:source:71: permission denied: /root/.oh-my-zsh/oh-my-zsh.sh\n```\n\n---\n\n我这里采用的是`agnoster`主题\n为在使用tmux时不重复显示`whoami@whereami`做两处修改\n- 在`/etc/profile`中添加环境变量\n  ```\n  DEFAULT_USER=$USER\n  ```\n- 在`agnoster`主题文件91行中做如下修改\n  ```git\n  - if [[ \"$USER\" != \"$DEFAULT_USER\" || -n \"$SSH_CLIENT\"]]; then\n  + if [[ \"$USER\" != \"$DEFAULT_USER\" || (( -n \"$SSH_CLIENT\" && -z \"$TMUX\" )) ]]; then\n  ```\n这样在本地初始打开一个terminal时不会显示,ssh远程连接是时显示\n进入tmux时不会显示\n\n\n原因是\n[Archlinux下安装和配置zsh](https://blog.csdn.net/kingolie/article/details/53066679)\n#### tmux\n\n安装tmux\n \n```shell\nsudo pacman -S tmux\n```\n\n在这里配置tmux\nhttps://github.com/search?utf8=%E2%9C%93&q=tmux&type=\nhttps://github.com/samoshkin/tmux-config  <--推荐这个配置\n\n[为 vim + tmux 开启真彩色(true color)](http://lotabout.me/2018/true-color-for-tmux-and-vim/)\n\n[tmux进阶之tmuxinator](https://blog.csdn.net/u014717036/article/details/60139776)\n\n#### neovim\n\n> neovim属于vim的加强版  功能更加强大\n\n注意的是启动neovim的命令式`nvim`而不是`neovim`\n\n同时安装 [nerd-fonts](https://gitee.com/hustlion-dev/nerd-fonts#option-3-install-script)\n\n\n##### spacevim\n\n一个定制化的vim配置,支持`vim,neovim`\n\n[官网](https://spacevim.org/)\n\n\n\n#### *Xshell下256/真色支持\n\n检查当前是否为256/真色[参考本篇文章](https://gaomf.cn/2017/01/16/Terminal_Color/)\n\n\n我这里的xshell只能支持256色\n\n这时xshell中只有在tmux下spacevim才能显示256色,不支持真色\n\n在.zshrc文件头添加\n```\nsh /${.zshrc的目录}/.change_term.sh\n```\n.change_term.sh文件内容如下\n```shell\necho \"before: $TERM\"\nif [ \"$TERM\" = \"linux\" ]\nthen\n  echo \"export TERM=xterm-256color\"\n  export TERM=xterm-256color\nelif [ \"$TERM\" = \"xterm\" ]\nthen\n  echo \"export TERM=tmux-direct\"\n  export TERM=tmux-direct\nelif [ \"$TERM\" = \"xterm-256color\" ]\nthen\n  echo \"export TERM=xterm-direct\"\n  export TERM=xterm-direct\nelse\n  echo \"export TERM=tmux-256color\"\n  export TERM=tmux-256color\nfi\necho \"now: $TERM\"\n# 如果是ssh自动启用tmux\nif [ -n \"$SSH_CLIENT\" ]\nthen\n  tmux\nfi\n\nclear \n```\n\n## 桌面环境\n\n> [参考](https://blog.csdn.net/kingolie/article/details/76723448)\n\n#### **1、安装显卡驱动**\n\n```\n# lspci | grep VGA    # 确定显卡型号\n# pacman -S <驱动包>\n#\n# # 官方仓库提供的驱动包：\n# # +----------------------+--------------------+--------------+\n# # |                      |        开源        |     私有     |\n# # +----------------------+--------------------+--------------+\n# # |         通用         |   xf86-video-vesa  |              |\n# # +----------------------+--------------------+--------------+\n# # |         Intel        |  xf86-video-intel  |              |\n# # +--------+-------------+--------------------+--------------+\n# # |        | GeForce 9+  |                    |    nvidia    |\n# # +        +-------------+                    +--------------+\n# # | nVidia | GeForce 8/9 | xf86-video-nouveau | nvidia-340xx |\n# # +        +-------------+                    +--------------+\n# # |        | GeForce 6/7 |                    | nvidia-304xx |\n# # +--------+-------------+--------------------+--------------+\n# # |        AMD/ATI       |   xf86-video-ati   |              |\n# # +----------------------+--------------------+--------------+12345678910111213141516171819\n```\n\n#### **2、安装桌面环境**\n\n所有桌面环境都需要依赖xorg。所以先要安装xorg组。\n\n```shell\npacman -S xorg\n```\n\n输入命令之后首先会询问要安装xorg组下的哪些包，选择全部。然后对于libgl包有个四个不同的实现，选择mesa-libgl。 \n然后再安装xorg-xinit和xterm：\n\n```shell\npacman -S xorg-xinit xterm\n```\n\n安装完成之后就可以使用startx命令启动xorg的简易界面了。进入成功的话会显示出几个简陋的窗口。然后按Ctrl+D就可以退出了。\n\n#### **3、安装xfce4桌面**\n\n安装xfce4桌面和附带的软件包：\n\n```shell\npacman -S xfce4 xfce4-goodies\n```\n\n#### **4、安装LightDM登录管理器(显示管理器)**\n\n详细安装和配置看arch-wiki-lighdm \n我没有通过startx的方式启动桌面环境，而是使用了登录管理器lightdm \n安装：\n\n```zsh\npacman -S lightdm lightdm-gtk-greeter\n```\n\n其配置文件为：\n/etc/lightdm/lightdm.conf \n安装好之后测试启动：\n\n```shell\nsystemctl start lightdm.service1\n```\n\n如果正常就会看到熟悉的登录界面了，不过不要登录，现在只是测试lightdm是否可以正常启动 \n点击画面上的关机小图标，弹出关机对话，选择注销! \n注销之后就回到之前的tty命令行模式了，可以看到相关的启动信息 \n一切正常，所以设置lightdm为开机自动启动，这样以后开机就不会出现tty命令行界面了，而是直接进入登录界面：\n\n```shell\nsystemctl enable lightdm.service\n```\n\n之后你可以重启进入xfce4图形界面，然后在图形界面中使用终端来继续以下配置步骤，也可以不重启，直接继续\n\n进入xfce4图形界面的命令为`startxfce4`\n\n\n\n#### 桌面美化\n\n\n\n[^1]: \n","slug":"StudyLinux-arch","published":1,"updated":"2018-10-14T16:12:41.785Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnyhsxn3000bas1o7odn97ek","content":"<h1 id=\"Arch-踩坑笔记\"><a href=\"#Arch-踩坑笔记\" class=\"headerlink\" title=\"Arch 踩坑笔记\"></a>Arch 踩坑笔记</h1><blockquote>\n<p>记录一下从0开始玩linux的经历</p>\n<p>其实之前已经有了一点ubuntu的使用经验 但是很浅</p>\n<p>Arch 作为’最难’安装的linux系统  通过它可以更好的了解linux</p>\n<p>这里是VMware安装的Arch虚拟机<br><a href=\"https://blog.csdn.net/u011054333/article/details/50631599\" target=\"_blank\" rel=\"noopener\">配置和美化Arch Linux</a></p>\n</blockquote>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装:\"></a>安装:</h2><p>这里参考</p>\n<blockquote>\n<p><a href=\"https://www.viseator.com/2017/05/17/arch_install/\" target=\"_blank\" rel=\"noopener\">这是最全面的安装指南</a></p>\n</blockquote>\n<h2 id=\"基础设置\"><a href=\"#基础设置\" class=\"headerlink\" title=\"基础设置:\"></a>基础设置:</h2><h4 id=\"创建新用户\"><a href=\"#创建新用户\" class=\"headerlink\" title=\"创建新用户\"></a>创建新用户</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># useradd -m -G wheel username （请自行替换username为你的用户名）</span><br><span class=\"line\"># passwd username （请自行替换username为你的用户名）</span><br></pre></td></tr></table></figure>\n<h4 id=\"开机自动联网\"><a href=\"#开机自动联网\" class=\"headerlink\" title=\"开机自动联网\"></a>开机自动联网</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span> systemctl enable dhcpcd</span><br></pre></td></tr></table></figure>\n<h4 id=\"网络工具\"><a href=\"#网络工具\" class=\"headerlink\" title=\"网络工具\"></a>网络工具</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span> pacman -Syy net-tools</span><br></pre></td></tr></table></figure>\n<h4 id=\"时间\"><a href=\"#时间\" class=\"headerlink\" title=\"时间\"></a>时间</h4><p>装完archlinux，时间总是比实际快了8个小时，找了各种办法，最终使用了openNTPD的方法</p>\n<p>设置时区：<code>sudo ln sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</code></p>\n<p>安装openNTPD：<code>sudo pacman -S openntpd</code></p>\n<p>重启openNTPD：<code>systemctl restart openntpd</code></p>\n<p>设置开机启动：<code>systemctl enable openntpd</code></p>\n<h4 id=\"ssh\"><a href=\"#ssh\" class=\"headerlink\" title=\"ssh\"></a>ssh</h4><p>安装ssh<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># pacman -Syy openssh</span><br></pre></td></tr></table></figure></p>\n<p>启动服务<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># systemctl start sshd</span><br></pre></td></tr></table></figure></p>\n<p>开机启动<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># systemctl enable sshd.service</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"aur助手\"><a href=\"#aur助手\" class=\"headerlink\" title=\"aur助手\"></a>aur助手</h4><p><a href=\"https://github.com/Jguer/yay\" target=\"_blank\" rel=\"noopener\">yay</a> 是下一个最好的 AUR 助手。它使用 Go 语言写成，宗旨是提供最少化用户输入的 <code>pacman</code> 界面、yaourt 式的搜索，而几乎没有任何依赖软件。</p>\n<p>yay 的特性：</p>\n<ul>\n<li><code>yay</code> 提供 AUR 表格补全，并且从 ABS 或 AUR 下载 PKGBUILD</li>\n<li>支持收窄搜索，并且不需要引用 PKGBUILD 源</li>\n<li><code>yay</code> 的二进制文件除了 <code>pacman</code> 以外别无依赖</li>\n<li>提供先进的包依赖解决方案，以及在编译安装之后移除编译时的依赖</li>\n<li>当在 <code>/etc/pacman.conf</code> 文件配置中启用了色彩时支持色彩输出</li>\n<li><code>yay</code> 可被配置成只支持 AUR 或者 repo 里的软件包</li>\n</ul>\n<p>安装 yay：</p>\n<p>你可以从 <code>git</code> 克隆并编译安装。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://aur.archlinux.org/yay.gitcd yaymakepkg -si</span><br></pre></td></tr></table></figure>\n<p>使用 yay：</p>\n<p>搜索：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yay -Ss &lt;package-name&gt;</span><br></pre></td></tr></table></figure>\n<p>安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yay -S &lt;package-name&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"powerline\"><a href=\"#powerline\" class=\"headerlink\" title=\"powerline\"></a>powerline</h4><p>Powerline 是 vim、zsh、bash、tmux、IPython、Awesome、bar、fish、lemonbar、pdb、rc、shell、tcsh、wm、i3 和 Qtil 中的一个状态栏插件。它给程序提供了状态栏，并使程序更好看。它用 Python 写成。</p>\n<h2 id=\"命令行\"><a href=\"#命令行\" class=\"headerlink\" title=\"命令行\"></a>命令行</h2><blockquote>\n<p>linux 强大的命令行操作,使效率倍增,所以配置好命令行,并安装实用命令行软件是必要的</p>\n</blockquote>\n<h4 id=\"zsh-1\"><a href=\"#zsh-1\" class=\"headerlink\" title=\"zsh^1\"></a>zsh<a href=\"[终端环境之Zsh＆oh-my-zsh](https://mtaoist.xyz/2018/03/14/oh-my-zsh/)\">^1</a></h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo pacman -S zsh zsh-completions</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> 将zsh设为默认shell</span><br><span class=\"line\">chsh -s /bin/zsh</span><br><span class=\"line\"><span class=\"meta\">#</span>其他发行版可先用chsh -l 查看zsh安装位置</span><br></pre></td></tr></table></figure>\n<h5 id=\"oh-my-zsh\"><a href=\"#oh-my-zsh\" class=\"headerlink\" title=\"oh-my-zsh\"></a>oh-my-zsh</h5><ul>\n<li><p>curl 和 git 应该已被安装(若没有Arch 用sudo pacman -S curl git 安装，其他发行版类似。)</p>\n</li>\n<li><p><a href=\"http://ohmyz.sh/\" target=\"_blank\" rel=\"noopener\">Oh-my-zsh</a>是一个傻瓜化的zsh配置管理框架，提供了大量实用的功能，主题等。做到开箱即用，现在基本成为了Zsh的标配。</p>\n</li>\n<li><p>安装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>配置文件位置： ~/.zshrc</p>\n</li>\n<li><p>主题<br><code>oh-my-zsh</code>自带大量<a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/Themes\" target=\"_blank\" rel=\"noopener\">Themes</a>，默认为<code>robbyrussell</code>。你也可以选择<code>random</code>，即每次打开终端随机选一个主题。</p>\n<blockquote>\n<p>ZSH_THEME=”你喜欢的主题名”<br><img src=\"https://mtaoist.xyz/img/zsh_theme.png\" alt=\"themes\"></p>\n</blockquote>\n</li>\n<li><p>常用插件</p>\n<ul>\n<li><p>git: 提供大量git的Aliases，<a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/Plugin:git\" target=\"_blank\" rel=\"noopener\">详情</a></p>\n</li>\n<li><p>archlinux： 提供一些pacman包管理器的Aliases，<a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins#archlinux\" target=\"_blank\" rel=\"noopener\">详情</a></p>\n</li>\n<li><p>z：经常使用cd 切换路径，积累一定数据后可用z快速跳转到指定位置</p>\n</li>\n<li><p>sudo：按两次[Esc]自动在前面加sudo</p>\n</li>\n<li><p>pip： 补全pip 命令</p>\n</li>\n<li><p>zsh-autosuggestions: 根据历史记录进行智能提示(按 ctrl+E 是正确姿势)。非oh-my-zsh自带，用git下载安装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>zsh-syntax-highlighting：命令高亮，正确显示绿色，错误为红色。非oh-my-zsh自带，用git下载安装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>plugins=( 你想启用的插件，空格分隔 )<br><img src=\"https://mtaoist.xyz/img/zsh_plugins.png\" alt=\"plugins\"></p>\n</blockquote>\n</li>\n<li><p>重新加载配置文件，立刻生效。</p>\n<blockquote>\n<p>source ~/.zshrc</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>其他插件请参见官方<a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins-Overview\" target=\"_blank\" rel=\"noopener\">wiki</a></p>\n</li>\n<li><p>少即是多，启用大量插件会严重拖慢zsh启动速度</p>\n</li>\n</ul>\n<hr>\n<p>我这里是在root下安装的,在<code>zsh</code>与<code>oh-my-zsh</code>的使用中,发现切换用户会出现错误</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Last login: Sun Sep 16 14:21:35 2018 from 192.168.174.1</span><br><span class=\"line\">/home/tabris/.zshrc:source:71: permission denied: /root/.oh-my-zsh/oh-my-zsh.sh</span><br></pre></td></tr></table></figure>\n<hr>\n<p>我这里采用的是<code>agnoster</code>主题<br>为在使用tmux时不重复显示<code>whoami@whereami</code>做两处修改</p>\n<ul>\n<li><p>在<code>/etc/profile</code>中添加环境变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DEFAULT_USER=$USER</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在<code>agnoster</code>主题文件91行中做如下修改</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- if [[ &quot;$USER&quot; != &quot;$DEFAULT_USER&quot; || -n &quot;$SSH_CLIENT&quot;]]; then</span><br><span class=\"line\">+ if [[ &quot;$USER&quot; != &quot;$DEFAULT_USER&quot; || (( -n &quot;$SSH_CLIENT&quot; &amp;&amp; -z &quot;$TMUX&quot; )) ]]; then</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这样在本地初始打开一个terminal时不会显示,ssh远程连接是时显示<br>进入tmux时不会显示</p>\n<p>原因是<br><a href=\"https://blog.csdn.net/kingolie/article/details/53066679\" target=\"_blank\" rel=\"noopener\">Archlinux下安装和配置zsh</a></p>\n<h4 id=\"tmux\"><a href=\"#tmux\" class=\"headerlink\" title=\"tmux\"></a>tmux</h4><p>安装tmux</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo pacman -S tmux</span><br></pre></td></tr></table></figure>\n<p>在这里配置tmux<br><a href=\"https://github.com/search?utf8=%E2%9C%93&amp;q=tmux&amp;type=\" target=\"_blank\" rel=\"noopener\">https://github.com/search?utf8=%E2%9C%93&amp;q=tmux&amp;type=</a><br><a href=\"https://github.com/samoshkin/tmux-config\" target=\"_blank\" rel=\"noopener\">https://github.com/samoshkin/tmux-config</a>  &lt;–推荐这个配置</p>\n<p><a href=\"http://lotabout.me/2018/true-color-for-tmux-and-vim/\" target=\"_blank\" rel=\"noopener\">为 vim + tmux 开启真彩色(true color)</a></p>\n<p><a href=\"https://blog.csdn.net/u014717036/article/details/60139776\" target=\"_blank\" rel=\"noopener\">tmux进阶之tmuxinator</a></p>\n<h4 id=\"neovim\"><a href=\"#neovim\" class=\"headerlink\" title=\"neovim\"></a>neovim</h4><blockquote>\n<p>neovim属于vim的加强版  功能更加强大</p>\n</blockquote>\n<p>注意的是启动neovim的命令式<code>nvim</code>而不是<code>neovim</code></p>\n<p>同时安装 <a href=\"https://gitee.com/hustlion-dev/nerd-fonts#option-3-install-script\" target=\"_blank\" rel=\"noopener\">nerd-fonts</a></p>\n<h5 id=\"spacevim\"><a href=\"#spacevim\" class=\"headerlink\" title=\"spacevim\"></a>spacevim</h5><p>一个定制化的vim配置,支持<code>vim,neovim</code></p>\n<p><a href=\"https://spacevim.org/\" target=\"_blank\" rel=\"noopener\">官网</a></p>\n<h4 id=\"Xshell下256-真色支持\"><a href=\"#Xshell下256-真色支持\" class=\"headerlink\" title=\"*Xshell下256/真色支持\"></a>*Xshell下256/真色支持</h4><p>检查当前是否为256/真色<a href=\"https://gaomf.cn/2017/01/16/Terminal_Color/\" target=\"_blank\" rel=\"noopener\">参考本篇文章</a></p>\n<p>我这里的xshell只能支持256色</p>\n<p>这时xshell中只有在tmux下spacevim才能显示256色,不支持真色</p>\n<p>在.zshrc文件头添加<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh /$&#123;.zshrc的目录&#125;/.change_term.sh</span><br></pre></td></tr></table></figure></p>\n<p>.change_term.sh文件内容如下<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo \"before: $TERM\"</span><br><span class=\"line\">if [ \"$TERM\" = \"linux\" ]</span><br><span class=\"line\">then</span><br><span class=\"line\">  echo \"export TERM=xterm-256color\"</span><br><span class=\"line\">  export TERM=xterm-256color</span><br><span class=\"line\">elif [ \"$TERM\" = \"xterm\" ]</span><br><span class=\"line\">then</span><br><span class=\"line\">  echo \"export TERM=tmux-direct\"</span><br><span class=\"line\">  export TERM=tmux-direct</span><br><span class=\"line\">elif [ \"$TERM\" = \"xterm-256color\" ]</span><br><span class=\"line\">then</span><br><span class=\"line\">  echo \"export TERM=xterm-direct\"</span><br><span class=\"line\">  export TERM=xterm-direct</span><br><span class=\"line\">else</span><br><span class=\"line\">  echo \"export TERM=tmux-256color\"</span><br><span class=\"line\">  export TERM=tmux-256color</span><br><span class=\"line\">fi</span><br><span class=\"line\">echo \"now: $TERM\"</span><br><span class=\"line\"><span class=\"meta\">#</span> 如果是ssh自动启用tmux</span><br><span class=\"line\">if [ -n \"$SSH_CLIENT\" ]</span><br><span class=\"line\">then</span><br><span class=\"line\">  tmux</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\">clear</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"桌面环境\"><a href=\"#桌面环境\" class=\"headerlink\" title=\"桌面环境\"></a>桌面环境</h2><blockquote>\n<p><a href=\"https://blog.csdn.net/kingolie/article/details/76723448\" target=\"_blank\" rel=\"noopener\">参考</a></p>\n</blockquote>\n<h4 id=\"1、安装显卡驱动\"><a href=\"#1、安装显卡驱动\" class=\"headerlink\" title=\"1、安装显卡驱动\"></a><strong>1、安装显卡驱动</strong></h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># lspci | grep VGA    # 确定显卡型号</span><br><span class=\"line\"># pacman -S &lt;驱动包&gt;</span><br><span class=\"line\">#</span><br><span class=\"line\"># # 官方仓库提供的驱动包：</span><br><span class=\"line\"># # +----------------------+--------------------+--------------+</span><br><span class=\"line\"># # |                      |        开源        |     私有     |</span><br><span class=\"line\"># # +----------------------+--------------------+--------------+</span><br><span class=\"line\"># # |         通用         |   xf86-video-vesa  |              |</span><br><span class=\"line\"># # +----------------------+--------------------+--------------+</span><br><span class=\"line\"># # |         Intel        |  xf86-video-intel  |              |</span><br><span class=\"line\"># # +--------+-------------+--------------------+--------------+</span><br><span class=\"line\"># # |        | GeForce 9+  |                    |    nvidia    |</span><br><span class=\"line\"># # +        +-------------+                    +--------------+</span><br><span class=\"line\"># # | nVidia | GeForce 8/9 | xf86-video-nouveau | nvidia-340xx |</span><br><span class=\"line\"># # +        +-------------+                    +--------------+</span><br><span class=\"line\"># # |        | GeForce 6/7 |                    | nvidia-304xx |</span><br><span class=\"line\"># # +--------+-------------+--------------------+--------------+</span><br><span class=\"line\"># # |        AMD/ATI       |   xf86-video-ati   |              |</span><br><span class=\"line\"># # +----------------------+--------------------+--------------+12345678910111213141516171819</span><br></pre></td></tr></table></figure>\n<h4 id=\"2、安装桌面环境\"><a href=\"#2、安装桌面环境\" class=\"headerlink\" title=\"2、安装桌面环境\"></a><strong>2、安装桌面环境</strong></h4><p>所有桌面环境都需要依赖xorg。所以先要安装xorg组。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pacman -S xorg</span><br></pre></td></tr></table></figure>\n<p>输入命令之后首先会询问要安装xorg组下的哪些包，选择全部。然后对于libgl包有个四个不同的实现，选择mesa-libgl。<br>然后再安装xorg-xinit和xterm：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pacman -S xorg-xinit xterm</span><br></pre></td></tr></table></figure>\n<p>安装完成之后就可以使用startx命令启动xorg的简易界面了。进入成功的话会显示出几个简陋的窗口。然后按Ctrl+D就可以退出了。</p>\n<h4 id=\"3、安装xfce4桌面\"><a href=\"#3、安装xfce4桌面\" class=\"headerlink\" title=\"3、安装xfce4桌面\"></a><strong>3、安装xfce4桌面</strong></h4><p>安装xfce4桌面和附带的软件包：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pacman -S xfce4 xfce4-goodies</span><br></pre></td></tr></table></figure>\n<h4 id=\"4、安装LightDM登录管理器-显示管理器\"><a href=\"#4、安装LightDM登录管理器-显示管理器\" class=\"headerlink\" title=\"4、安装LightDM登录管理器(显示管理器)\"></a><strong>4、安装LightDM登录管理器(显示管理器)</strong></h4><p>详细安装和配置看arch-wiki-lighdm<br>我没有通过startx的方式启动桌面环境，而是使用了登录管理器lightdm<br>安装：</p>\n<figure class=\"highlight zsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pacman -S lightdm lightdm-gtk-greeter</span><br></pre></td></tr></table></figure>\n<p>其配置文件为：<br>/etc/lightdm/lightdm.conf<br>安装好之后测试启动：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl start lightdm.service1</span><br></pre></td></tr></table></figure>\n<p>如果正常就会看到熟悉的登录界面了，不过不要登录，现在只是测试lightdm是否可以正常启动<br>点击画面上的关机小图标，弹出关机对话，选择注销!<br>注销之后就回到之前的tty命令行模式了，可以看到相关的启动信息<br>一切正常，所以设置lightdm为开机自动启动，这样以后开机就不会出现tty命令行界面了，而是直接进入登录界面：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl enable lightdm.service</span><br></pre></td></tr></table></figure>\n<p>之后你可以重启进入xfce4图形界面，然后在图形界面中使用终端来继续以下配置步骤，也可以不重启，直接继续</p>\n<p>进入xfce4图形界面的命令为<code>startxfce4</code></p>\n<h4 id=\"桌面美化\"><a href=\"#桌面美化\" class=\"headerlink\" title=\"桌面美化\"></a>桌面美化</h4><p><a href=\"[终端环境之Zsh＆oh-my-zsh](https://mtaoist.xyz/2018/03/14/oh-my-zsh/)\">^1</a>: </p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Arch-踩坑笔记\"><a href=\"#Arch-踩坑笔记\" class=\"headerlink\" title=\"Arch 踩坑笔记\"></a>Arch 踩坑笔记</h1><blockquote>\n<p>记录一下从0开始玩linux的经历</p>\n<p>其实之前已经有了一点ubuntu的使用经验 但是很浅</p>\n<p>Arch 作为’最难’安装的linux系统  通过它可以更好的了解linux</p>\n<p>这里是VMware安装的Arch虚拟机<br><a href=\"https://blog.csdn.net/u011054333/article/details/50631599\" target=\"_blank\" rel=\"noopener\">配置和美化Arch Linux</a></p>\n</blockquote>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装:\"></a>安装:</h2><p>这里参考</p>\n<blockquote>\n<p><a href=\"https://www.viseator.com/2017/05/17/arch_install/\" target=\"_blank\" rel=\"noopener\">这是最全面的安装指南</a></p>\n</blockquote>\n<h2 id=\"基础设置\"><a href=\"#基础设置\" class=\"headerlink\" title=\"基础设置:\"></a>基础设置:</h2><h4 id=\"创建新用户\"><a href=\"#创建新用户\" class=\"headerlink\" title=\"创建新用户\"></a>创建新用户</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># useradd -m -G wheel username （请自行替换username为你的用户名）</span><br><span class=\"line\"># passwd username （请自行替换username为你的用户名）</span><br></pre></td></tr></table></figure>\n<h4 id=\"开机自动联网\"><a href=\"#开机自动联网\" class=\"headerlink\" title=\"开机自动联网\"></a>开机自动联网</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span> systemctl enable dhcpcd</span><br></pre></td></tr></table></figure>\n<h4 id=\"网络工具\"><a href=\"#网络工具\" class=\"headerlink\" title=\"网络工具\"></a>网络工具</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span> pacman -Syy net-tools</span><br></pre></td></tr></table></figure>\n<h4 id=\"时间\"><a href=\"#时间\" class=\"headerlink\" title=\"时间\"></a>时间</h4><p>装完archlinux，时间总是比实际快了8个小时，找了各种办法，最终使用了openNTPD的方法</p>\n<p>设置时区：<code>sudo ln sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</code></p>\n<p>安装openNTPD：<code>sudo pacman -S openntpd</code></p>\n<p>重启openNTPD：<code>systemctl restart openntpd</code></p>\n<p>设置开机启动：<code>systemctl enable openntpd</code></p>\n<h4 id=\"ssh\"><a href=\"#ssh\" class=\"headerlink\" title=\"ssh\"></a>ssh</h4><p>安装ssh<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># pacman -Syy openssh</span><br></pre></td></tr></table></figure></p>\n<p>启动服务<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># systemctl start sshd</span><br></pre></td></tr></table></figure></p>\n<p>开机启动<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># systemctl enable sshd.service</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"aur助手\"><a href=\"#aur助手\" class=\"headerlink\" title=\"aur助手\"></a>aur助手</h4><p><a href=\"https://github.com/Jguer/yay\" target=\"_blank\" rel=\"noopener\">yay</a> 是下一个最好的 AUR 助手。它使用 Go 语言写成，宗旨是提供最少化用户输入的 <code>pacman</code> 界面、yaourt 式的搜索，而几乎没有任何依赖软件。</p>\n<p>yay 的特性：</p>\n<ul>\n<li><code>yay</code> 提供 AUR 表格补全，并且从 ABS 或 AUR 下载 PKGBUILD</li>\n<li>支持收窄搜索，并且不需要引用 PKGBUILD 源</li>\n<li><code>yay</code> 的二进制文件除了 <code>pacman</code> 以外别无依赖</li>\n<li>提供先进的包依赖解决方案，以及在编译安装之后移除编译时的依赖</li>\n<li>当在 <code>/etc/pacman.conf</code> 文件配置中启用了色彩时支持色彩输出</li>\n<li><code>yay</code> 可被配置成只支持 AUR 或者 repo 里的软件包</li>\n</ul>\n<p>安装 yay：</p>\n<p>你可以从 <code>git</code> 克隆并编译安装。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://aur.archlinux.org/yay.gitcd yaymakepkg -si</span><br></pre></td></tr></table></figure>\n<p>使用 yay：</p>\n<p>搜索：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yay -Ss &lt;package-name&gt;</span><br></pre></td></tr></table></figure>\n<p>安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yay -S &lt;package-name&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"powerline\"><a href=\"#powerline\" class=\"headerlink\" title=\"powerline\"></a>powerline</h4><p>Powerline 是 vim、zsh、bash、tmux、IPython、Awesome、bar、fish、lemonbar、pdb、rc、shell、tcsh、wm、i3 和 Qtil 中的一个状态栏插件。它给程序提供了状态栏，并使程序更好看。它用 Python 写成。</p>\n<h2 id=\"命令行\"><a href=\"#命令行\" class=\"headerlink\" title=\"命令行\"></a>命令行</h2><blockquote>\n<p>linux 强大的命令行操作,使效率倍增,所以配置好命令行,并安装实用命令行软件是必要的</p>\n</blockquote>\n<h4 id=\"zsh-1\"><a href=\"#zsh-1\" class=\"headerlink\" title=\"zsh^1\"></a>zsh<a href=\"[终端环境之Zsh＆oh-my-zsh](https://mtaoist.xyz/2018/03/14/oh-my-zsh/)\">^1</a></h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo pacman -S zsh zsh-completions</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> 将zsh设为默认shell</span><br><span class=\"line\">chsh -s /bin/zsh</span><br><span class=\"line\"><span class=\"meta\">#</span>其他发行版可先用chsh -l 查看zsh安装位置</span><br></pre></td></tr></table></figure>\n<h5 id=\"oh-my-zsh\"><a href=\"#oh-my-zsh\" class=\"headerlink\" title=\"oh-my-zsh\"></a>oh-my-zsh</h5><ul>\n<li><p>curl 和 git 应该已被安装(若没有Arch 用sudo pacman -S curl git 安装，其他发行版类似。)</p>\n</li>\n<li><p><a href=\"http://ohmyz.sh/\" target=\"_blank\" rel=\"noopener\">Oh-my-zsh</a>是一个傻瓜化的zsh配置管理框架，提供了大量实用的功能，主题等。做到开箱即用，现在基本成为了Zsh的标配。</p>\n</li>\n<li><p>安装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>配置文件位置： ~/.zshrc</p>\n</li>\n<li><p>主题<br><code>oh-my-zsh</code>自带大量<a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/Themes\" target=\"_blank\" rel=\"noopener\">Themes</a>，默认为<code>robbyrussell</code>。你也可以选择<code>random</code>，即每次打开终端随机选一个主题。</p>\n<blockquote>\n<p>ZSH_THEME=”你喜欢的主题名”<br><img src=\"https://mtaoist.xyz/img/zsh_theme.png\" alt=\"themes\"></p>\n</blockquote>\n</li>\n<li><p>常用插件</p>\n<ul>\n<li><p>git: 提供大量git的Aliases，<a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/Plugin:git\" target=\"_blank\" rel=\"noopener\">详情</a></p>\n</li>\n<li><p>archlinux： 提供一些pacman包管理器的Aliases，<a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins#archlinux\" target=\"_blank\" rel=\"noopener\">详情</a></p>\n</li>\n<li><p>z：经常使用cd 切换路径，积累一定数据后可用z快速跳转到指定位置</p>\n</li>\n<li><p>sudo：按两次[Esc]自动在前面加sudo</p>\n</li>\n<li><p>pip： 补全pip 命令</p>\n</li>\n<li><p>zsh-autosuggestions: 根据历史记录进行智能提示(按 ctrl+E 是正确姿势)。非oh-my-zsh自带，用git下载安装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>zsh-syntax-highlighting：命令高亮，正确显示绿色，错误为红色。非oh-my-zsh自带，用git下载安装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>plugins=( 你想启用的插件，空格分隔 )<br><img src=\"https://mtaoist.xyz/img/zsh_plugins.png\" alt=\"plugins\"></p>\n</blockquote>\n</li>\n<li><p>重新加载配置文件，立刻生效。</p>\n<blockquote>\n<p>source ~/.zshrc</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>其他插件请参见官方<a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins-Overview\" target=\"_blank\" rel=\"noopener\">wiki</a></p>\n</li>\n<li><p>少即是多，启用大量插件会严重拖慢zsh启动速度</p>\n</li>\n</ul>\n<hr>\n<p>我这里是在root下安装的,在<code>zsh</code>与<code>oh-my-zsh</code>的使用中,发现切换用户会出现错误</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Last login: Sun Sep 16 14:21:35 2018 from 192.168.174.1</span><br><span class=\"line\">/home/tabris/.zshrc:source:71: permission denied: /root/.oh-my-zsh/oh-my-zsh.sh</span><br></pre></td></tr></table></figure>\n<hr>\n<p>我这里采用的是<code>agnoster</code>主题<br>为在使用tmux时不重复显示<code>whoami@whereami</code>做两处修改</p>\n<ul>\n<li><p>在<code>/etc/profile</code>中添加环境变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DEFAULT_USER=$USER</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在<code>agnoster</code>主题文件91行中做如下修改</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- if [[ &quot;$USER&quot; != &quot;$DEFAULT_USER&quot; || -n &quot;$SSH_CLIENT&quot;]]; then</span><br><span class=\"line\">+ if [[ &quot;$USER&quot; != &quot;$DEFAULT_USER&quot; || (( -n &quot;$SSH_CLIENT&quot; &amp;&amp; -z &quot;$TMUX&quot; )) ]]; then</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这样在本地初始打开一个terminal时不会显示,ssh远程连接是时显示<br>进入tmux时不会显示</p>\n<p>原因是<br><a href=\"https://blog.csdn.net/kingolie/article/details/53066679\" target=\"_blank\" rel=\"noopener\">Archlinux下安装和配置zsh</a></p>\n<h4 id=\"tmux\"><a href=\"#tmux\" class=\"headerlink\" title=\"tmux\"></a>tmux</h4><p>安装tmux</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo pacman -S tmux</span><br></pre></td></tr></table></figure>\n<p>在这里配置tmux<br><a href=\"https://github.com/search?utf8=%E2%9C%93&amp;q=tmux&amp;type=\" target=\"_blank\" rel=\"noopener\">https://github.com/search?utf8=%E2%9C%93&amp;q=tmux&amp;type=</a><br><a href=\"https://github.com/samoshkin/tmux-config\" target=\"_blank\" rel=\"noopener\">https://github.com/samoshkin/tmux-config</a>  &lt;–推荐这个配置</p>\n<p><a href=\"http://lotabout.me/2018/true-color-for-tmux-and-vim/\" target=\"_blank\" rel=\"noopener\">为 vim + tmux 开启真彩色(true color)</a></p>\n<p><a href=\"https://blog.csdn.net/u014717036/article/details/60139776\" target=\"_blank\" rel=\"noopener\">tmux进阶之tmuxinator</a></p>\n<h4 id=\"neovim\"><a href=\"#neovim\" class=\"headerlink\" title=\"neovim\"></a>neovim</h4><blockquote>\n<p>neovim属于vim的加强版  功能更加强大</p>\n</blockquote>\n<p>注意的是启动neovim的命令式<code>nvim</code>而不是<code>neovim</code></p>\n<p>同时安装 <a href=\"https://gitee.com/hustlion-dev/nerd-fonts#option-3-install-script\" target=\"_blank\" rel=\"noopener\">nerd-fonts</a></p>\n<h5 id=\"spacevim\"><a href=\"#spacevim\" class=\"headerlink\" title=\"spacevim\"></a>spacevim</h5><p>一个定制化的vim配置,支持<code>vim,neovim</code></p>\n<p><a href=\"https://spacevim.org/\" target=\"_blank\" rel=\"noopener\">官网</a></p>\n<h4 id=\"Xshell下256-真色支持\"><a href=\"#Xshell下256-真色支持\" class=\"headerlink\" title=\"*Xshell下256/真色支持\"></a>*Xshell下256/真色支持</h4><p>检查当前是否为256/真色<a href=\"https://gaomf.cn/2017/01/16/Terminal_Color/\" target=\"_blank\" rel=\"noopener\">参考本篇文章</a></p>\n<p>我这里的xshell只能支持256色</p>\n<p>这时xshell中只有在tmux下spacevim才能显示256色,不支持真色</p>\n<p>在.zshrc文件头添加<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh /$&#123;.zshrc的目录&#125;/.change_term.sh</span><br></pre></td></tr></table></figure></p>\n<p>.change_term.sh文件内容如下<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo \"before: $TERM\"</span><br><span class=\"line\">if [ \"$TERM\" = \"linux\" ]</span><br><span class=\"line\">then</span><br><span class=\"line\">  echo \"export TERM=xterm-256color\"</span><br><span class=\"line\">  export TERM=xterm-256color</span><br><span class=\"line\">elif [ \"$TERM\" = \"xterm\" ]</span><br><span class=\"line\">then</span><br><span class=\"line\">  echo \"export TERM=tmux-direct\"</span><br><span class=\"line\">  export TERM=tmux-direct</span><br><span class=\"line\">elif [ \"$TERM\" = \"xterm-256color\" ]</span><br><span class=\"line\">then</span><br><span class=\"line\">  echo \"export TERM=xterm-direct\"</span><br><span class=\"line\">  export TERM=xterm-direct</span><br><span class=\"line\">else</span><br><span class=\"line\">  echo \"export TERM=tmux-256color\"</span><br><span class=\"line\">  export TERM=tmux-256color</span><br><span class=\"line\">fi</span><br><span class=\"line\">echo \"now: $TERM\"</span><br><span class=\"line\"><span class=\"meta\">#</span> 如果是ssh自动启用tmux</span><br><span class=\"line\">if [ -n \"$SSH_CLIENT\" ]</span><br><span class=\"line\">then</span><br><span class=\"line\">  tmux</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\">clear</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"桌面环境\"><a href=\"#桌面环境\" class=\"headerlink\" title=\"桌面环境\"></a>桌面环境</h2><blockquote>\n<p><a href=\"https://blog.csdn.net/kingolie/article/details/76723448\" target=\"_blank\" rel=\"noopener\">参考</a></p>\n</blockquote>\n<h4 id=\"1、安装显卡驱动\"><a href=\"#1、安装显卡驱动\" class=\"headerlink\" title=\"1、安装显卡驱动\"></a><strong>1、安装显卡驱动</strong></h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># lspci | grep VGA    # 确定显卡型号</span><br><span class=\"line\"># pacman -S &lt;驱动包&gt;</span><br><span class=\"line\">#</span><br><span class=\"line\"># # 官方仓库提供的驱动包：</span><br><span class=\"line\"># # +----------------------+--------------------+--------------+</span><br><span class=\"line\"># # |                      |        开源        |     私有     |</span><br><span class=\"line\"># # +----------------------+--------------------+--------------+</span><br><span class=\"line\"># # |         通用         |   xf86-video-vesa  |              |</span><br><span class=\"line\"># # +----------------------+--------------------+--------------+</span><br><span class=\"line\"># # |         Intel        |  xf86-video-intel  |              |</span><br><span class=\"line\"># # +--------+-------------+--------------------+--------------+</span><br><span class=\"line\"># # |        | GeForce 9+  |                    |    nvidia    |</span><br><span class=\"line\"># # +        +-------------+                    +--------------+</span><br><span class=\"line\"># # | nVidia | GeForce 8/9 | xf86-video-nouveau | nvidia-340xx |</span><br><span class=\"line\"># # +        +-------------+                    +--------------+</span><br><span class=\"line\"># # |        | GeForce 6/7 |                    | nvidia-304xx |</span><br><span class=\"line\"># # +--------+-------------+--------------------+--------------+</span><br><span class=\"line\"># # |        AMD/ATI       |   xf86-video-ati   |              |</span><br><span class=\"line\"># # +----------------------+--------------------+--------------+12345678910111213141516171819</span><br></pre></td></tr></table></figure>\n<h4 id=\"2、安装桌面环境\"><a href=\"#2、安装桌面环境\" class=\"headerlink\" title=\"2、安装桌面环境\"></a><strong>2、安装桌面环境</strong></h4><p>所有桌面环境都需要依赖xorg。所以先要安装xorg组。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pacman -S xorg</span><br></pre></td></tr></table></figure>\n<p>输入命令之后首先会询问要安装xorg组下的哪些包，选择全部。然后对于libgl包有个四个不同的实现，选择mesa-libgl。<br>然后再安装xorg-xinit和xterm：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pacman -S xorg-xinit xterm</span><br></pre></td></tr></table></figure>\n<p>安装完成之后就可以使用startx命令启动xorg的简易界面了。进入成功的话会显示出几个简陋的窗口。然后按Ctrl+D就可以退出了。</p>\n<h4 id=\"3、安装xfce4桌面\"><a href=\"#3、安装xfce4桌面\" class=\"headerlink\" title=\"3、安装xfce4桌面\"></a><strong>3、安装xfce4桌面</strong></h4><p>安装xfce4桌面和附带的软件包：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pacman -S xfce4 xfce4-goodies</span><br></pre></td></tr></table></figure>\n<h4 id=\"4、安装LightDM登录管理器-显示管理器\"><a href=\"#4、安装LightDM登录管理器-显示管理器\" class=\"headerlink\" title=\"4、安装LightDM登录管理器(显示管理器)\"></a><strong>4、安装LightDM登录管理器(显示管理器)</strong></h4><p>详细安装和配置看arch-wiki-lighdm<br>我没有通过startx的方式启动桌面环境，而是使用了登录管理器lightdm<br>安装：</p>\n<figure class=\"highlight zsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pacman -S lightdm lightdm-gtk-greeter</span><br></pre></td></tr></table></figure>\n<p>其配置文件为：<br>/etc/lightdm/lightdm.conf<br>安装好之后测试启动：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl start lightdm.service1</span><br></pre></td></tr></table></figure>\n<p>如果正常就会看到熟悉的登录界面了，不过不要登录，现在只是测试lightdm是否可以正常启动<br>点击画面上的关机小图标，弹出关机对话，选择注销!<br>注销之后就回到之前的tty命令行模式了，可以看到相关的启动信息<br>一切正常，所以设置lightdm为开机自动启动，这样以后开机就不会出现tty命令行界面了，而是直接进入登录界面：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl enable lightdm.service</span><br></pre></td></tr></table></figure>\n<p>之后你可以重启进入xfce4图形界面，然后在图形界面中使用终端来继续以下配置步骤，也可以不重启，直接继续</p>\n<p>进入xfce4图形界面的命令为<code>startxfce4</code></p>\n<h4 id=\"桌面美化\"><a href=\"#桌面美化\" class=\"headerlink\" title=\"桌面美化\"></a>桌面美化</h4><p><a href=\"[终端环境之Zsh＆oh-my-zsh](https://mtaoist.xyz/2018/03/14/oh-my-zsh/)\">^1</a>: </p>\n"},{"title":"正则表达式手册","date":"2018-03-17T08:15:41.000Z","_content":"# 表达式全集\n\n由于hexo的markdown的引擎太烂了  这里的格式会乱点\n有时间在换一个好一点的引擎   太乱了!! \n移步这里[格式好看的正则表达式手册](http://tool.oschina.net/uploads/apidocs/jquery/regexp.html)\n\n|     字符     | 描述                                                         |\n| :----------: | :----------------------------------------------------------- |\n|      \\       | 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“`n`”匹配字符“`n`”。“`\\n`”匹配一个换行符。串行“`\\`”匹配“`\\`”而“`(`”则匹配“`(`”。 |\n|      ^       | 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“`\\n`”或“`\\r`”之后的位置。 |\n|      $       | 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“`\\n`”或“`\\r`”之前的位置。 |\n|              | 匹配前面的子表达式零次或多次。例如，zo能匹配“`z`”以及“`zoo`”。*等价于{0,}。* |\n|      +       | 匹配前面的子表达式一次或多次。例如，“`zo+`”能匹配“`zo`”以及“`zoo`”，但不能匹配“`z`”。+等价于{1,}。 |\n|      ?       | 匹配前面的子表达式零次或一次。例如，“`do(es)?`”可以匹配“`does`”或“`does`”中的“`do`”。?等价于{0,1}。 |\n|     {n}      | n是一个非负整数。匹配确定的n次。例如，“`o{2}`”不能匹配“`Bob`”中的“`o`”，但是能匹配“`food`”中的两个o。 |\n|     {n,}     | n是一个非负整数。至少匹配n次。例如，“`o{2,}`”不能匹配“`Bob`”中的“`o`”，但能匹配“`foooood`”中的所有o。“`o{1,}`”等价于“`o+`”。“`o{0,}`”则等价于“`o`”。 |\n|    {n,m}     | m和n均为非负整数，其中n<=m。最少匹配n次且最多匹配m次。例如，“`o{1,3}`”将匹配“`fooooood`”中的前三个o。“`o{0,1}`”等价于“`o?`”。请注意在逗号和两个数之间不能有空格。 |\n|      ?       | 当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“`oooo`”，“`o+?`”将匹配单个“`o`”，而“`o+`”将匹配所有“`o`”。 |\n|      .       | 匹配除“`\\``n`”之外的任何单个字符。要匹配包括“`\\``n`”在内的任何字符，请使用像“`(.|\\n)`”的模式。 |\n|  (pattern)   | 匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“`(`”或“`)`”。 |\n| (?:pattern)  | 匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“`(|)`”来组合一个模式的各个部分是很有用。例如“`industr(?:y|ies)`”就是一个比“`industry|industries`”更简略的表达式。 |\n| (?=pattern)  | 正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“`Windows(?=95|98|NT|2000)`”能匹配“`Windows2000`”中的“`Windows`”，但不能匹配“`Windows3.1`”中的“`Windows`”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 |\n| (?!pattern)  | 正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“`Windows(?!95|98|NT|2000)`”能匹配“`Windows3.1`”中的“`Windows`”，但不能匹配“`Windows2000`”中的“`Windows`”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始 |\n| (?<=pattern) | 反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“`(?<=95|98|NT|2000)Windows`”能匹配“`2000Windows`”中的“`Windows`”，但不能匹配“`3.1Windows`”中的“`Windows`”。 |\n| (?<!pattern) | 反向否定预查，与正向否定预查类拟，只是方向相反。例如“`(?<!95|98|NT|2000)Windows`”能匹配“`3.1Windows`”中的“`Windows`”，但不能匹配“`2000Windows`”中的“`Windows`”。 |\n|     x\\|y     | 匹配x或y。例如，“`z|food`”能匹配“`z`”或“`food`”。“`(z|f)ood`”则匹配“`zood`”或“`food`”。 |\n|    [xyz]     | 字符集合。匹配所包含的任意一个字符。例如，“`[abc]`”可以匹配“`plain`”中的“`a`”。 |\n|    [^xyz]    | 负值字符集合。匹配未包含的任意字符。例如，“`[^abc]`”可以匹配“`plain`”中的“`p`”。 |\n|    [a-z]     | 字符范围。匹配指定范围内的任意字符。例如，“`[a-z]`”可以匹配“`a`”到“`z`”范围内的任意小写字母字符。 |\n|    [^a-z]    | 负值字符范围。匹配任何不在指定范围内的任意字符。例如，“`[^a-z]`”可以匹配任何不在“`a`”到“`z`”范围内的任意字符。 |\n|      \\b      | 匹配一个单词边界，也就是指单词和空格间的位置。例如，“`er\\b`”可以匹配“`never`”中的“`er`”，但不能匹配“`verb`”中的“`er`”。 |\n|      \\B      | 匹配非单词边界。“`er\\B`”能匹配“`verb`”中的“`er`”，但不能匹配“`never`”中的“`er`”。 |\n|     \\cx      | 匹配由x指明的控制字符。例如，\\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“`c`”字符。 |\n|      \\d      | 匹配一个数字字符。等价于[0-9]。                              |\n|      \\D      | 匹配一个非数字字符。等价于[^0-9]。                           |\n|      \\f      | 匹配一个换页符。等价于\\x0c和\\cL。                            |\n|      \\n      | 匹配一个换行符。等价于\\x0a和\\cJ。                            |\n|      \\r      | 匹配一个回车符。等价于\\x0d和\\cM。                            |\n|      \\s      | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \\f\\n\\r\\t\\v]。 |\n|      \\S      | 匹配任何非空白字符。等价于[^ \\f\\n\\r\\t\\v]。                   |\n|      \\t      | 匹配一个制表符。等价于\\x09和\\cI。                            |\n|      \\v      | 匹配一个垂直制表符。等价于\\x0b和\\cK。                        |\n|      \\w      | 匹配包括下划线的任何单词字符。等价于“`[A-Za-z0-9*]*`”。      |\n|      \\W      | 匹配任何非单词字符。等价于“`[^A-Za-z0-9]`”。                 |\n|     \\xn      | 匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“`\\x41`”匹配“`A`”。“`\\x041`”则等价于“`\\x04&1`”。正则表达式中可以使用ASCII编码。. |\n|     \\num     | 匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“`(.)\\1`”匹配两个连续的相同字符。 |\n|      \\n      | 标识一个八进制转义值或一个向后引用。如果\\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。 |\n|     \\nm      | 标识一个八进制转义值或一个向后引用。如果\\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\\nm将匹配八进制转义值nm。 |\n|     \\nml     | 如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。 |\n|     \\un      | 匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\\u00A9匹配版权符号（©）。 |\n\n# 常用正则表达式\n\n|||\n|-|-|\n|         用户名          | `/^[a-z0-9*-]{3,16}$/`                                        |\n|          密码           | `/^[a-z0-9-]{6,18}$/`                                          |\n|       十六进制值        | `/^#?([a-f0-9]{6}\\&#124;[a-f0-9]{3})$/`                            |\n|        电子邮箱         | `/^([a-z0-9*.-]+)@([\\da-z.-]+).([a-z.]{2,6})$/` `/^[a-z\\d]+(.[a-z\\d]+)@(\\da-z?)+(.{1,2}[a-z]+)+$/`*` |\n|           URL           | `/^(https?:\\/\\/)?([\\da-z.-]+).([a-z.]{2,6})([\\/\\w .-])*\\/?$/`*` |\n|         IP 地址         | `/((2[0-4]\\d\\|25[0-5]\\|[01]?\\d\\d?).){3}(2[0-4]\\d\\|25[0-5]\\|[01]?\\d\\d?)/` `/^(?:(?:25[0-5]\\|2[0-4][0-9]\\|[01]?[0-9][0-9]?).){3}(?:25[0-5]\\|2[0-4][0-9]\\|[01]?[0-9][0-9]?)$/` |\n|        HTML 标签        | `/^<([a-z]+)([^<]+)(?:>(.*)<\\/\\1>\\|\\s+\\/>)$/`                 |\n|      删除代码\\注释      | `(?<!http:\\|\\S)//.$`                                           |\n| Unicode编码中的汉字范围 | `/^[\\u2E80-\\u9FFF]+$/`                                         |","source":"_posts/ManualOfRegex.md","raw":"---\ntitle: 正则表达式手册\ndate: 2018-03-17 16:15:41\ntags: 正则表达式\n---\n# 表达式全集\n\n由于hexo的markdown的引擎太烂了  这里的格式会乱点\n有时间在换一个好一点的引擎   太乱了!! \n移步这里[格式好看的正则表达式手册](http://tool.oschina.net/uploads/apidocs/jquery/regexp.html)\n\n|     字符     | 描述                                                         |\n| :----------: | :----------------------------------------------------------- |\n|      \\       | 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“`n`”匹配字符“`n`”。“`\\n`”匹配一个换行符。串行“`\\`”匹配“`\\`”而“`(`”则匹配“`(`”。 |\n|      ^       | 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“`\\n`”或“`\\r`”之后的位置。 |\n|      $       | 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“`\\n`”或“`\\r`”之前的位置。 |\n|              | 匹配前面的子表达式零次或多次。例如，zo能匹配“`z`”以及“`zoo`”。*等价于{0,}。* |\n|      +       | 匹配前面的子表达式一次或多次。例如，“`zo+`”能匹配“`zo`”以及“`zoo`”，但不能匹配“`z`”。+等价于{1,}。 |\n|      ?       | 匹配前面的子表达式零次或一次。例如，“`do(es)?`”可以匹配“`does`”或“`does`”中的“`do`”。?等价于{0,1}。 |\n|     {n}      | n是一个非负整数。匹配确定的n次。例如，“`o{2}`”不能匹配“`Bob`”中的“`o`”，但是能匹配“`food`”中的两个o。 |\n|     {n,}     | n是一个非负整数。至少匹配n次。例如，“`o{2,}`”不能匹配“`Bob`”中的“`o`”，但能匹配“`foooood`”中的所有o。“`o{1,}`”等价于“`o+`”。“`o{0,}`”则等价于“`o`”。 |\n|    {n,m}     | m和n均为非负整数，其中n<=m。最少匹配n次且最多匹配m次。例如，“`o{1,3}`”将匹配“`fooooood`”中的前三个o。“`o{0,1}`”等价于“`o?`”。请注意在逗号和两个数之间不能有空格。 |\n|      ?       | 当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“`oooo`”，“`o+?`”将匹配单个“`o`”，而“`o+`”将匹配所有“`o`”。 |\n|      .       | 匹配除“`\\``n`”之外的任何单个字符。要匹配包括“`\\``n`”在内的任何字符，请使用像“`(.|\\n)`”的模式。 |\n|  (pattern)   | 匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“`(`”或“`)`”。 |\n| (?:pattern)  | 匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“`(|)`”来组合一个模式的各个部分是很有用。例如“`industr(?:y|ies)`”就是一个比“`industry|industries`”更简略的表达式。 |\n| (?=pattern)  | 正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“`Windows(?=95|98|NT|2000)`”能匹配“`Windows2000`”中的“`Windows`”，但不能匹配“`Windows3.1`”中的“`Windows`”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 |\n| (?!pattern)  | 正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“`Windows(?!95|98|NT|2000)`”能匹配“`Windows3.1`”中的“`Windows`”，但不能匹配“`Windows2000`”中的“`Windows`”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始 |\n| (?<=pattern) | 反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“`(?<=95|98|NT|2000)Windows`”能匹配“`2000Windows`”中的“`Windows`”，但不能匹配“`3.1Windows`”中的“`Windows`”。 |\n| (?<!pattern) | 反向否定预查，与正向否定预查类拟，只是方向相反。例如“`(?<!95|98|NT|2000)Windows`”能匹配“`3.1Windows`”中的“`Windows`”，但不能匹配“`2000Windows`”中的“`Windows`”。 |\n|     x\\|y     | 匹配x或y。例如，“`z|food`”能匹配“`z`”或“`food`”。“`(z|f)ood`”则匹配“`zood`”或“`food`”。 |\n|    [xyz]     | 字符集合。匹配所包含的任意一个字符。例如，“`[abc]`”可以匹配“`plain`”中的“`a`”。 |\n|    [^xyz]    | 负值字符集合。匹配未包含的任意字符。例如，“`[^abc]`”可以匹配“`plain`”中的“`p`”。 |\n|    [a-z]     | 字符范围。匹配指定范围内的任意字符。例如，“`[a-z]`”可以匹配“`a`”到“`z`”范围内的任意小写字母字符。 |\n|    [^a-z]    | 负值字符范围。匹配任何不在指定范围内的任意字符。例如，“`[^a-z]`”可以匹配任何不在“`a`”到“`z`”范围内的任意字符。 |\n|      \\b      | 匹配一个单词边界，也就是指单词和空格间的位置。例如，“`er\\b`”可以匹配“`never`”中的“`er`”，但不能匹配“`verb`”中的“`er`”。 |\n|      \\B      | 匹配非单词边界。“`er\\B`”能匹配“`verb`”中的“`er`”，但不能匹配“`never`”中的“`er`”。 |\n|     \\cx      | 匹配由x指明的控制字符。例如，\\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“`c`”字符。 |\n|      \\d      | 匹配一个数字字符。等价于[0-9]。                              |\n|      \\D      | 匹配一个非数字字符。等价于[^0-9]。                           |\n|      \\f      | 匹配一个换页符。等价于\\x0c和\\cL。                            |\n|      \\n      | 匹配一个换行符。等价于\\x0a和\\cJ。                            |\n|      \\r      | 匹配一个回车符。等价于\\x0d和\\cM。                            |\n|      \\s      | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \\f\\n\\r\\t\\v]。 |\n|      \\S      | 匹配任何非空白字符。等价于[^ \\f\\n\\r\\t\\v]。                   |\n|      \\t      | 匹配一个制表符。等价于\\x09和\\cI。                            |\n|      \\v      | 匹配一个垂直制表符。等价于\\x0b和\\cK。                        |\n|      \\w      | 匹配包括下划线的任何单词字符。等价于“`[A-Za-z0-9*]*`”。      |\n|      \\W      | 匹配任何非单词字符。等价于“`[^A-Za-z0-9]`”。                 |\n|     \\xn      | 匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“`\\x41`”匹配“`A`”。“`\\x041`”则等价于“`\\x04&1`”。正则表达式中可以使用ASCII编码。. |\n|     \\num     | 匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“`(.)\\1`”匹配两个连续的相同字符。 |\n|      \\n      | 标识一个八进制转义值或一个向后引用。如果\\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。 |\n|     \\nm      | 标识一个八进制转义值或一个向后引用。如果\\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\\nm将匹配八进制转义值nm。 |\n|     \\nml     | 如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。 |\n|     \\un      | 匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\\u00A9匹配版权符号（©）。 |\n\n# 常用正则表达式\n\n|||\n|-|-|\n|         用户名          | `/^[a-z0-9*-]{3,16}$/`                                        |\n|          密码           | `/^[a-z0-9-]{6,18}$/`                                          |\n|       十六进制值        | `/^#?([a-f0-9]{6}\\&#124;[a-f0-9]{3})$/`                            |\n|        电子邮箱         | `/^([a-z0-9*.-]+)@([\\da-z.-]+).([a-z.]{2,6})$/` `/^[a-z\\d]+(.[a-z\\d]+)@(\\da-z?)+(.{1,2}[a-z]+)+$/`*` |\n|           URL           | `/^(https?:\\/\\/)?([\\da-z.-]+).([a-z.]{2,6})([\\/\\w .-])*\\/?$/`*` |\n|         IP 地址         | `/((2[0-4]\\d\\|25[0-5]\\|[01]?\\d\\d?).){3}(2[0-4]\\d\\|25[0-5]\\|[01]?\\d\\d?)/` `/^(?:(?:25[0-5]\\|2[0-4][0-9]\\|[01]?[0-9][0-9]?).){3}(?:25[0-5]\\|2[0-4][0-9]\\|[01]?[0-9][0-9]?)$/` |\n|        HTML 标签        | `/^<([a-z]+)([^<]+)(?:>(.*)<\\/\\1>\\|\\s+\\/>)$/`                 |\n|      删除代码\\注释      | `(?<!http:\\|\\S)//.$`                                           |\n| Unicode编码中的汉字范围 | `/^[\\u2E80-\\u9FFF]+$/`                                         |","slug":"ManualOfRegex","published":1,"updated":"2018-09-23T08:00:49.258Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnyhsxno000eas1ow90ntrn9","content":"<h1 id=\"表达式全集\"><a href=\"#表达式全集\" class=\"headerlink\" title=\"表达式全集\"></a>表达式全集</h1><p>由于hexo的markdown的引擎太烂了  这里的格式会乱点<br>有时间在换一个好一点的引擎   太乱了!!<br>移步这里<a href=\"http://tool.oschina.net/uploads/apidocs/jquery/regexp.html\" target=\"_blank\" rel=\"noopener\">格式好看的正则表达式手册</a></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">字符</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">\\</td>\n<td style=\"text-align:left\">将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“<code>n</code>”匹配字符“<code>n</code>”。“<code>\\n</code>”匹配一个换行符。串行“<code>\\</code>”匹配“<code>\\</code>”而“<code>(</code>”则匹配“<code>(</code>”。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">^</td>\n<td style=\"text-align:left\">匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“<code>\\n</code>”或“<code>\\r</code>”之后的位置。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$</td>\n<td style=\"text-align:left\">匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“<code>\\n</code>”或“<code>\\r</code>”之前的位置。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:left\">匹配前面的子表达式零次或多次。例如，zo能匹配“<code>z</code>”以及“<code>zoo</code>”。<em>等价于{0,}。</em></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">+</td>\n<td style=\"text-align:left\">匹配前面的子表达式一次或多次。例如，“<code>zo+</code>”能匹配“<code>zo</code>”以及“<code>zoo</code>”，但不能匹配“<code>z</code>”。+等价于{1,}。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">?</td>\n<td style=\"text-align:left\">匹配前面的子表达式零次或一次。例如，“<code>do(es)?</code>”可以匹配“<code>does</code>”或“<code>does</code>”中的“<code>do</code>”。?等价于{0,1}。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">{n}</td>\n<td style=\"text-align:left\">n是一个非负整数。匹配确定的n次。例如，“<code>o{2}</code>”不能匹配“<code>Bob</code>”中的“<code>o</code>”，但是能匹配“<code>food</code>”中的两个o。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">{n,}</td>\n<td style=\"text-align:left\">n是一个非负整数。至少匹配n次。例如，“<code>o{2,}</code>”不能匹配“<code>Bob</code>”中的“<code>o</code>”，但能匹配“<code>foooood</code>”中的所有o。“<code>o{1,}</code>”等价于“<code>o+</code>”。“<code>o{0,}</code>”则等价于“<code>o</code>”。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">{n,m}</td>\n<td style=\"text-align:left\">m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“<code>o{1,3}</code>”将匹配“<code>fooooood</code>”中的前三个o。“<code>o{0,1}</code>”等价于“<code>o?</code>”。请注意在逗号和两个数之间不能有空格。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">?</td>\n<td style=\"text-align:left\">当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“<code>oooo</code>”，“<code>o+?</code>”将匹配单个“<code>o</code>”，而“<code>o+</code>”将匹配所有“<code>o</code>”。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">.</td>\n<td style=\"text-align:left\">匹配除“<code>\\`</code>n<code>”之外的任何单个字符。要匹配包括“</code>`<code>n</code>”在内的任何字符，请使用像“`(.</td>\n<td>\\n)`”的模式。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">(pattern)</td>\n<td style=\"text-align:left\">匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“<code>(</code>”或“<code>)</code>”。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">(?:pattern)</td>\n<td style=\"text-align:left\">匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“`(</td>\n<td>)<code>”来组合一个模式的各个部分是很有用。例如“</code>industr(?:y</td>\n<td>ies)<code>”就是一个比“</code>industry</td>\n<td>industries`”更简略的表达式。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">(?=pattern)</td>\n<td style=\"text-align:left\">正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“`Windows(?=95</td>\n<td>98</td>\n<td>NT</td>\n<td>2000)<code>”能匹配“</code>Windows2000<code>”中的“</code>Windows<code>”，但不能匹配“</code>Windows3.1<code>”中的“</code>Windows`”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">(?!pattern)</td>\n<td style=\"text-align:left\">正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“`Windows(?!95</td>\n<td>98</td>\n<td>NT</td>\n<td>2000)<code>”能匹配“</code>Windows3.1<code>”中的“</code>Windows<code>”，但不能匹配“</code>Windows2000<code>”中的“</code>Windows`”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">(?&lt;=pattern)</td>\n<td style=\"text-align:left\">反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“`(?&lt;=95</td>\n<td>98</td>\n<td>NT</td>\n<td>2000)Windows<code>”能匹配“</code>2000Windows<code>”中的“</code>Windows<code>”，但不能匹配“</code>3.1Windows<code>”中的“</code>Windows`”。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">(?&lt;!pattern)</td>\n<td style=\"text-align:left\">反向否定预查，与正向否定预查类拟，只是方向相反。例如“`(?&lt;!95</td>\n<td>98</td>\n<td>NT</td>\n<td>2000)Windows<code>”能匹配“</code>3.1Windows<code>”中的“</code>Windows<code>”，但不能匹配“</code>2000Windows<code>”中的“</code>Windows`”。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">x\\</td>\n<td style=\"text-align:left\">y</td>\n<td>匹配x或y。例如，“`z</td>\n<td>food<code>”能匹配“</code>z<code>”或“</code>food<code>”。“</code>(z</td>\n<td>f)ood<code>”则匹配“</code>zood<code>”或“</code>food`”。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">[xyz]</td>\n<td style=\"text-align:left\">字符集合。匹配所包含的任意一个字符。例如，“<code>[abc]</code>”可以匹配“<code>plain</code>”中的“<code>a</code>”。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">[^xyz]</td>\n<td style=\"text-align:left\">负值字符集合。匹配未包含的任意字符。例如，“<code>[^abc]</code>”可以匹配“<code>plain</code>”中的“<code>p</code>”。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">[a-z]</td>\n<td style=\"text-align:left\">字符范围。匹配指定范围内的任意字符。例如，“<code>[a-z]</code>”可以匹配“<code>a</code>”到“<code>z</code>”范围内的任意小写字母字符。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">[^a-z]</td>\n<td style=\"text-align:left\">负值字符范围。匹配任何不在指定范围内的任意字符。例如，“<code>[^a-z]</code>”可以匹配任何不在“<code>a</code>”到“<code>z</code>”范围内的任意字符。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\b</td>\n<td style=\"text-align:left\">匹配一个单词边界，也就是指单词和空格间的位置。例如，“<code>er\\b</code>”可以匹配“<code>never</code>”中的“<code>er</code>”，但不能匹配“<code>verb</code>”中的“<code>er</code>”。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\B</td>\n<td style=\"text-align:left\">匹配非单词边界。“<code>er\\B</code>”能匹配“<code>verb</code>”中的“<code>er</code>”，但不能匹配“<code>never</code>”中的“<code>er</code>”。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\cx</td>\n<td style=\"text-align:left\">匹配由x指明的控制字符。例如，\\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“<code>c</code>”字符。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\d</td>\n<td style=\"text-align:left\">匹配一个数字字符。等价于[0-9]。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\D</td>\n<td style=\"text-align:left\">匹配一个非数字字符。等价于[^0-9]。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\f</td>\n<td style=\"text-align:left\">匹配一个换页符。等价于\\x0c和\\cL。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\n</td>\n<td style=\"text-align:left\">匹配一个换行符。等价于\\x0a和\\cJ。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\r</td>\n<td style=\"text-align:left\">匹配一个回车符。等价于\\x0d和\\cM。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\s</td>\n<td style=\"text-align:left\">匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \\f\\n\\r\\t\\v]。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\S</td>\n<td style=\"text-align:left\">匹配任何非空白字符。等价于[^ \\f\\n\\r\\t\\v]。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\t</td>\n<td style=\"text-align:left\">匹配一个制表符。等价于\\x09和\\cI。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\v</td>\n<td style=\"text-align:left\">匹配一个垂直制表符。等价于\\x0b和\\cK。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\w</td>\n<td style=\"text-align:left\">匹配包括下划线的任何单词字符。等价于“<code>[A-Za-z0-9*]*</code>”。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\W</td>\n<td style=\"text-align:left\">匹配任何非单词字符。等价于“<code>[^A-Za-z0-9]</code>”。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\xn</td>\n<td style=\"text-align:left\">匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“<code>\\x41</code>”匹配“<code>A</code>”。“<code>\\x041</code>”则等价于“<code>\\x04&amp;1</code>”。正则表达式中可以使用ASCII编码。.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\num</td>\n<td style=\"text-align:left\">匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“<code>(.)\\1</code>”匹配两个连续的相同字符。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\n</td>\n<td style=\"text-align:left\">标识一个八进制转义值或一个向后引用。如果\\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\nm</td>\n<td style=\"text-align:left\">标识一个八进制转义值或一个向后引用。如果\\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\\nm将匹配八进制转义值nm。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\nml</td>\n<td style=\"text-align:left\">如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\un</td>\n<td style=\"text-align:left\">匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\\u00A9匹配版权符号（©）。</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"常用正则表达式\"><a href=\"#常用正则表达式\" class=\"headerlink\" title=\"常用正则表达式\"></a>常用正则表达式</h1><table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>用户名</td>\n<td><code>/^[a-z0-9*-]{3,16}$/</code></td>\n</tr>\n<tr>\n<td>密码</td>\n<td><code>/^[a-z0-9-]{6,18}$/</code></td>\n</tr>\n<tr>\n<td>十六进制值</td>\n<td><code>/^#?([a-f0-9]{6}\\&amp;#124;[a-f0-9]{3})$/</code></td>\n</tr>\n<tr>\n<td>电子邮箱</td>\n<td><code>/^([a-z0-9*.-]+)@([\\da-z.-]+).([a-z.]{2,6})$/</code> <code>/^[a-z\\d]+(.[a-z\\d]+)@(\\da-z?)+(.{1,2}[a-z]+)+$/</code>*`</td>\n</tr>\n<tr>\n<td>URL</td>\n<td><code>/^(https?:\\/\\/)?([\\da-z.-]+).([a-z.]{2,6})([\\/\\w .-])*\\/?$/</code>*`</td>\n</tr>\n<tr>\n<td>IP 地址</td>\n<td>`/((2[0-4]\\d\\</td>\n<td>25[0-5]\\</td>\n<td>[01]?\\d\\d?).){3}(2[0-4]\\d\\</td>\n<td>25[0-5]\\</td>\n<td>[01]?\\d\\d?)/<code></code>/^(?:(?:25[0-5]\\</td>\n<td>2[0-4][0-9]\\</td>\n<td>[01]?[0-9][0-9]?).){3}(?:25[0-5]\\</td>\n<td>2[0-4][0-9]\\</td>\n<td>[01]?[0-9][0-9]?)$/`</td>\n</tr>\n<tr>\n<td>HTML 标签</td>\n<td>`/^&lt;([a-z]+)([^&lt;]+)(?:&gt;(.*)&lt;\\/\\1&gt;\\</td>\n<td>\\s+\\/&gt;)$/`</td>\n</tr>\n<tr>\n<td>删除代码\\注释</td>\n<td>`(?&lt;!http:\\</td>\n<td>\\S)//.$`</td>\n</tr>\n<tr>\n<td>Unicode编码中的汉字范围</td>\n<td><code>/^[\\u2E80-\\u9FFF]+$/</code></td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"表达式全集\"><a href=\"#表达式全集\" class=\"headerlink\" title=\"表达式全集\"></a>表达式全集</h1><p>由于hexo的markdown的引擎太烂了  这里的格式会乱点<br>有时间在换一个好一点的引擎   太乱了!!<br>移步这里<a href=\"http://tool.oschina.net/uploads/apidocs/jquery/regexp.html\" target=\"_blank\" rel=\"noopener\">格式好看的正则表达式手册</a></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">字符</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">\\</td>\n<td style=\"text-align:left\">将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“<code>n</code>”匹配字符“<code>n</code>”。“<code>\\n</code>”匹配一个换行符。串行“<code>\\</code>”匹配“<code>\\</code>”而“<code>(</code>”则匹配“<code>(</code>”。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">^</td>\n<td style=\"text-align:left\">匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“<code>\\n</code>”或“<code>\\r</code>”之后的位置。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$</td>\n<td style=\"text-align:left\">匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“<code>\\n</code>”或“<code>\\r</code>”之前的位置。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:left\">匹配前面的子表达式零次或多次。例如，zo能匹配“<code>z</code>”以及“<code>zoo</code>”。<em>等价于{0,}。</em></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">+</td>\n<td style=\"text-align:left\">匹配前面的子表达式一次或多次。例如，“<code>zo+</code>”能匹配“<code>zo</code>”以及“<code>zoo</code>”，但不能匹配“<code>z</code>”。+等价于{1,}。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">?</td>\n<td style=\"text-align:left\">匹配前面的子表达式零次或一次。例如，“<code>do(es)?</code>”可以匹配“<code>does</code>”或“<code>does</code>”中的“<code>do</code>”。?等价于{0,1}。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">{n}</td>\n<td style=\"text-align:left\">n是一个非负整数。匹配确定的n次。例如，“<code>o{2}</code>”不能匹配“<code>Bob</code>”中的“<code>o</code>”，但是能匹配“<code>food</code>”中的两个o。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">{n,}</td>\n<td style=\"text-align:left\">n是一个非负整数。至少匹配n次。例如，“<code>o{2,}</code>”不能匹配“<code>Bob</code>”中的“<code>o</code>”，但能匹配“<code>foooood</code>”中的所有o。“<code>o{1,}</code>”等价于“<code>o+</code>”。“<code>o{0,}</code>”则等价于“<code>o</code>”。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">{n,m}</td>\n<td style=\"text-align:left\">m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“<code>o{1,3}</code>”将匹配“<code>fooooood</code>”中的前三个o。“<code>o{0,1}</code>”等价于“<code>o?</code>”。请注意在逗号和两个数之间不能有空格。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">?</td>\n<td style=\"text-align:left\">当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“<code>oooo</code>”，“<code>o+?</code>”将匹配单个“<code>o</code>”，而“<code>o+</code>”将匹配所有“<code>o</code>”。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">.</td>\n<td style=\"text-align:left\">匹配除“<code>\\`</code>n<code>”之外的任何单个字符。要匹配包括“</code>`<code>n</code>”在内的任何字符，请使用像“`(.</td>\n<td>\\n)`”的模式。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">(pattern)</td>\n<td style=\"text-align:left\">匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“<code>(</code>”或“<code>)</code>”。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">(?:pattern)</td>\n<td style=\"text-align:left\">匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“`(</td>\n<td>)<code>”来组合一个模式的各个部分是很有用。例如“</code>industr(?:y</td>\n<td>ies)<code>”就是一个比“</code>industry</td>\n<td>industries`”更简略的表达式。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">(?=pattern)</td>\n<td style=\"text-align:left\">正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“`Windows(?=95</td>\n<td>98</td>\n<td>NT</td>\n<td>2000)<code>”能匹配“</code>Windows2000<code>”中的“</code>Windows<code>”，但不能匹配“</code>Windows3.1<code>”中的“</code>Windows`”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">(?!pattern)</td>\n<td style=\"text-align:left\">正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“`Windows(?!95</td>\n<td>98</td>\n<td>NT</td>\n<td>2000)<code>”能匹配“</code>Windows3.1<code>”中的“</code>Windows<code>”，但不能匹配“</code>Windows2000<code>”中的“</code>Windows`”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">(?&lt;=pattern)</td>\n<td style=\"text-align:left\">反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“`(?&lt;=95</td>\n<td>98</td>\n<td>NT</td>\n<td>2000)Windows<code>”能匹配“</code>2000Windows<code>”中的“</code>Windows<code>”，但不能匹配“</code>3.1Windows<code>”中的“</code>Windows`”。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">(?&lt;!pattern)</td>\n<td style=\"text-align:left\">反向否定预查，与正向否定预查类拟，只是方向相反。例如“`(?&lt;!95</td>\n<td>98</td>\n<td>NT</td>\n<td>2000)Windows<code>”能匹配“</code>3.1Windows<code>”中的“</code>Windows<code>”，但不能匹配“</code>2000Windows<code>”中的“</code>Windows`”。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">x\\</td>\n<td style=\"text-align:left\">y</td>\n<td>匹配x或y。例如，“`z</td>\n<td>food<code>”能匹配“</code>z<code>”或“</code>food<code>”。“</code>(z</td>\n<td>f)ood<code>”则匹配“</code>zood<code>”或“</code>food`”。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">[xyz]</td>\n<td style=\"text-align:left\">字符集合。匹配所包含的任意一个字符。例如，“<code>[abc]</code>”可以匹配“<code>plain</code>”中的“<code>a</code>”。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">[^xyz]</td>\n<td style=\"text-align:left\">负值字符集合。匹配未包含的任意字符。例如，“<code>[^abc]</code>”可以匹配“<code>plain</code>”中的“<code>p</code>”。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">[a-z]</td>\n<td style=\"text-align:left\">字符范围。匹配指定范围内的任意字符。例如，“<code>[a-z]</code>”可以匹配“<code>a</code>”到“<code>z</code>”范围内的任意小写字母字符。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">[^a-z]</td>\n<td style=\"text-align:left\">负值字符范围。匹配任何不在指定范围内的任意字符。例如，“<code>[^a-z]</code>”可以匹配任何不在“<code>a</code>”到“<code>z</code>”范围内的任意字符。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\b</td>\n<td style=\"text-align:left\">匹配一个单词边界，也就是指单词和空格间的位置。例如，“<code>er\\b</code>”可以匹配“<code>never</code>”中的“<code>er</code>”，但不能匹配“<code>verb</code>”中的“<code>er</code>”。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\B</td>\n<td style=\"text-align:left\">匹配非单词边界。“<code>er\\B</code>”能匹配“<code>verb</code>”中的“<code>er</code>”，但不能匹配“<code>never</code>”中的“<code>er</code>”。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\cx</td>\n<td style=\"text-align:left\">匹配由x指明的控制字符。例如，\\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“<code>c</code>”字符。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\d</td>\n<td style=\"text-align:left\">匹配一个数字字符。等价于[0-9]。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\D</td>\n<td style=\"text-align:left\">匹配一个非数字字符。等价于[^0-9]。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\f</td>\n<td style=\"text-align:left\">匹配一个换页符。等价于\\x0c和\\cL。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\n</td>\n<td style=\"text-align:left\">匹配一个换行符。等价于\\x0a和\\cJ。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\r</td>\n<td style=\"text-align:left\">匹配一个回车符。等价于\\x0d和\\cM。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\s</td>\n<td style=\"text-align:left\">匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \\f\\n\\r\\t\\v]。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\S</td>\n<td style=\"text-align:left\">匹配任何非空白字符。等价于[^ \\f\\n\\r\\t\\v]。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\t</td>\n<td style=\"text-align:left\">匹配一个制表符。等价于\\x09和\\cI。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\v</td>\n<td style=\"text-align:left\">匹配一个垂直制表符。等价于\\x0b和\\cK。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\w</td>\n<td style=\"text-align:left\">匹配包括下划线的任何单词字符。等价于“<code>[A-Za-z0-9*]*</code>”。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\W</td>\n<td style=\"text-align:left\">匹配任何非单词字符。等价于“<code>[^A-Za-z0-9]</code>”。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\xn</td>\n<td style=\"text-align:left\">匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“<code>\\x41</code>”匹配“<code>A</code>”。“<code>\\x041</code>”则等价于“<code>\\x04&amp;1</code>”。正则表达式中可以使用ASCII编码。.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\num</td>\n<td style=\"text-align:left\">匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“<code>(.)\\1</code>”匹配两个连续的相同字符。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\n</td>\n<td style=\"text-align:left\">标识一个八进制转义值或一个向后引用。如果\\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\nm</td>\n<td style=\"text-align:left\">标识一个八进制转义值或一个向后引用。如果\\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\\nm将匹配八进制转义值nm。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\nml</td>\n<td style=\"text-align:left\">如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\un</td>\n<td style=\"text-align:left\">匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\\u00A9匹配版权符号（©）。</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"常用正则表达式\"><a href=\"#常用正则表达式\" class=\"headerlink\" title=\"常用正则表达式\"></a>常用正则表达式</h1><table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>用户名</td>\n<td><code>/^[a-z0-9*-]{3,16}$/</code></td>\n</tr>\n<tr>\n<td>密码</td>\n<td><code>/^[a-z0-9-]{6,18}$/</code></td>\n</tr>\n<tr>\n<td>十六进制值</td>\n<td><code>/^#?([a-f0-9]{6}\\&amp;#124;[a-f0-9]{3})$/</code></td>\n</tr>\n<tr>\n<td>电子邮箱</td>\n<td><code>/^([a-z0-9*.-]+)@([\\da-z.-]+).([a-z.]{2,6})$/</code> <code>/^[a-z\\d]+(.[a-z\\d]+)@(\\da-z?)+(.{1,2}[a-z]+)+$/</code>*`</td>\n</tr>\n<tr>\n<td>URL</td>\n<td><code>/^(https?:\\/\\/)?([\\da-z.-]+).([a-z.]{2,6})([\\/\\w .-])*\\/?$/</code>*`</td>\n</tr>\n<tr>\n<td>IP 地址</td>\n<td>`/((2[0-4]\\d\\</td>\n<td>25[0-5]\\</td>\n<td>[01]?\\d\\d?).){3}(2[0-4]\\d\\</td>\n<td>25[0-5]\\</td>\n<td>[01]?\\d\\d?)/<code></code>/^(?:(?:25[0-5]\\</td>\n<td>2[0-4][0-9]\\</td>\n<td>[01]?[0-9][0-9]?).){3}(?:25[0-5]\\</td>\n<td>2[0-4][0-9]\\</td>\n<td>[01]?[0-9][0-9]?)$/`</td>\n</tr>\n<tr>\n<td>HTML 标签</td>\n<td>`/^&lt;([a-z]+)([^&lt;]+)(?:&gt;(.*)&lt;\\/\\1&gt;\\</td>\n<td>\\s+\\/&gt;)$/`</td>\n</tr>\n<tr>\n<td>删除代码\\注释</td>\n<td>`(?&lt;!http:\\</td>\n<td>\\S)//.$`</td>\n</tr>\n<tr>\n<td>Unicode编码中的汉字范围</td>\n<td><code>/^[\\u2E80-\\u9FFF]+$/</code></td>\n</tr>\n</tbody>\n</table>\n"},{"title":"面试经历.","date":"2018-01-31T07:56:08.000Z","description":null,"toc":true,"_content":"\n> 总结下所有的面试, 这样才能**慢慢**进步呀,,,,\n\n## 哈尔滨某小公司 - C++岗实习 [现场面] - offer\n\n除了问一个多态,没有技术问题,大概是给答上了 意思对,但不专业\n\n-----\n小公司估计是真的没人了,,,,待遇实在...拒绝\n\n\n## 头条 - 后台开发实习生 [视频面试] 一面 - 跪\n\n可能是紧张吧,开始闲聊然后给了个编程题\n给一个化学表达式\n```math\neg: HMg_{_2}(H_2O(N_3Ag)_2)_3N_2\n```\n,让算每个元素有多少个.\n\n这种题本就不难 问题就是怎么处理括号 \n之前在hiho上还遇到过类似的问题http://www.hihocoder.com/contest/offers41/problem/2\n\n然后不知道紧张还是什么的就写的很乱,然后面试官提示递归,然后墨迹了好久才用stack写了下来.....\n\n因为我没有项目,就没有问项目.\n然后问我们学了数据库,操作系统,网络没有,,,,   嗯 学校确实讲过,但我没听过课...\n\n问了个进程调度,\n\n我就知道有个算法叫FIFO, 具体是啥还忘了, 然后说错了,,GG\n\n然后唠了两句面试官说结束,等HR通知,,,  嗯.感谢面试官浪费40+分钟陪我 hhhh.\n\n--------------------------\n\n总结:\n有点紧张. 代码能力差 ,**[数据库,操作系统,网络]** 知识严重匮乏.\n\n之前看面经说,遇到不会的或者把不准的都应该说**不会**. 下次注意.\n\n\n## 达内 - NOIP助教 现场面\n\n达内这个大家都懂.\n\n突然有天接到达内一个经理的电话,问我能不能去当助教,去教小朋友普及组的NOIP.\n我心想,这也还不错呀.\n然后去了,开始跟我吹了1个小时的牛逼,达内多么多么牛逼.怎么怎么地.\n然后给了我一份NOIP普及组的题让我做..\n\n说来惭愧,中文题面,我竟读错一道题卡了好久,,,然后花了1个多小时终于把4个题做出来了,最后一题还做得很麻烦...\n然后来了一个小伙子,谈了谈对NOIP的认识,以及我的学习情况.\n交上去给了一个小姐姐,然后看见三个人对着电脑看了半天..\n\n然后说一定要一年,但我最多只能半年,于是据.\n\n------------------------------\n体验美滋滋,没有麻烦的题目,没有操作系统,没有计算机网络,没有数据库.真棒 hhh\n\n## 深信服 - C/C++ 电话面试 一面-估计跪了\n\n深圳打来的电话, 不知道哪里人, 浓重的方言口音, 他说话我都要问好多遍才能听懂...交流真滴有障碍...\n\n一共22分钟,三个问题\n\n1 . 两个字符串,一个大串,一个小串,问小串是不是大串的子串(不连续)的.\n\n我回答了: 遍历大串,然后对小串维护一个遍历的指针就行了\n\n然后他说不是他想要的,问的是正则?\n\n我记得有正则查询可以模糊匹配,只要在两个相邻的字母中插进去就好了,,但我忘记了具体插什么,\n\n结束后一查知道是 `.*` [. 匹配任意非\\n的字符 *是0个或多个]\n\n2 . 给一个100万的字符串,然后找到最短的循环覆盖的子串.\n\n我开始以为是ABCABC这样的 最短就是ABC了 ,拿next数组直接做就行了,\n\n然后说了半天,最后知道,他说的可以是这样ABCABCAB,还可以是ABC\n\n想了想发现和之前的一样, 还是求next数组,然后就可以把结尾的AB给去掉了,然后就和之前一样了.\n\n然后不知怎么就陷入了一阵交流障碍,我不知道他说的啥,他不知道我说的啥.\n\n然后我发现他是想让我说一下next怎么求...\n\n想了想,不能画图 怎么说呀, 问写代码行吗, 额 他也看不见....\n\n然后勉强解释了下 维护两个指针,一个i遍历大串,j是维护匹配到的位置,balabala的,\n\n也不知道他明白没有...\n\n----------\n\n然后他问我用linux还是windows多,\n\n我说用过linux,但还是windows多.\n\n然后问我一个问题,我听成了python.. 我说我会python.....但他好像问的根本不是这个问题,,,\n\n---------\n3 . 最后问我进程的内存分布\n\n我不会呀..\n\n说了一个堆栈..就说不知道了, \n\n于是结束...\n\n目测GG\n\n\n---\n\n总结: 说好的12点,结果15点电话过来了,,,措手不及,以为没我事儿了呢,\n\n交流障碍导致前面两个问题说的不太好,而且电话面试真的不如视频面试呀,更别说现场面试了,,,后面确实不会, 操作系统,网络,数据库 多看看呀..\n\n\n## 阿里云, 分布式,大数据   - 基础平台研发工程师实习 电话面试 一面-跪了\n\nredis和MongoDB的区别。 谈一谈这两个数据库 。   (他以为我是自己搭建的数据库，，但我就是安装然后用的呀)\n说一下大数据: hadoop - HDFS，hive 和 MapReduce ，问哪个是存储的，脑抽说了个hive，，， 后来改正了，然后问HDFS里面都有什么，答NameNode 和 DataNode，\n问我还有什么，我不知道，他告诉我还有sdk。\n\n然后让我说竞赛中做过的经典，印象深刻的题目，想了好久，随便说了一个题，题目不怎么难，其实说的很模糊，而且说的时候还把那个题给弱化了，，记不太清那个题目了，\n\n然后问了我一个问题，现在都没想明白，说HDFS传3个副本，然后又客户在另一端访问这个。 然后是传完这**三**个副本告诉客户传完了有一个延迟时间，这**两**个副本告诉客户传完了有一个延迟时间，，\n两个的会比三个的地低，\n然后给初问题，给一个T，求N，M。 T是客户允许的最长延迟时间，N是副本总数，M是传完M个告诉客户传完了。\n我只知道可以通过传好多次 算一个副本的时间t，但是不会算大T， 跟概率，期望，有关\n\n\n最后让写了一个编程题，很简单的n个区间 问覆盖的长度总和是多少。 谈了50多分种 脑子有点蒙，写了好几分钟。。 但他看了好长时间，难道是我写的错啦？？。。\n\n然后问了面试官几个问题，\n大数据如何高效学习，论文，跟进\n分布式如何学习，\n\n他们这个是做底层的，，，\n\n然后就是如果通过了 下次面试是什么时候，，，，但估计没有下次了，，，，，\n\n--------\n虽然啥都不会，什么都没有答上来。 体验非常好的一次面试，面试官人特别好，面对我这样的垃圾面试人员，应该很无奈，但依然很耐心的面试我，最后还提了好多问题。\n\n但是很奇怪，这次竟然一点操作系统和数据结构的问题都没有问， 之前看到牛客网一个基础平台研发，问了这些问题的呀。\n\n## 瓜子二手车 后台研发实习生 现场一二面, 给了offer邀请.\n\n- 1面\n    自我介绍,没准备,随便说了下\n    唠了两句家常.\n\n    绳子不均匀,燃烧的问题,一根绳子1个小时烧完.\n    怎么找30分钟,75分钟.\n\n    说下栈和队列\n    双栈怎么实现队列\n\n    计算机网络的几个零碎的小问题,没记住.\n\n    然后写了两个代码题\n    - 交叉的链表,找交叉的位置,\n    链表的代码思路对,但是head节点没有val这点被我忘记了\n    - 单链表找倒数第k个节点,\n    \n    数据库索引怎么实现的 -> b+树\n    b+树为什么会快 -> 搜索树,有剪枝\n    非\\*\\*和\\*\\*的区别 -> 不知道,没听说过 (告诉我是 index 和 index+data的区别,名字想不起来了)\n    数据库事务的四个特性ACID -> 我分不清那个是哪个了,就举个例子说了,\n    还有两个数据库的问题,想不起来了,\n\n    问问题,问了技术栈和分布式的东西.\n\n- 2面\n    领我进去的小哥哥说是总监面\n\n    自我介绍.唠家常.\n\n    两个集合求交,写代码 谢了归并排序+二分, 然后过了会说了个更简单的方法,\n\n    几个小问题,没记住\n\n    给我写了几个词,让我谈一谈\n    - set,stack,链表,数组,map,hash\n    - tcp,udp,http,https,ftp\n\n    聊了聊最近在学习什么.说我基础薄弱..\n\n    问问题. 问了职业规划.答:选择做技术就一直做技术.\n \n ---\n可能因为是小公司吧,问的问题都比较简单.算法为了体现水平,学习了网上的套路,先给出一个不是很好的做法,然后再给一个优秀的做法.[斜眼笑]\n走的时候小哥哥看了看评价表和我说不错,应该很稳,让我回去等消息就行啦. \n面试官都很随和,出去的时候和一个工大研一的同来面试的小哥哥聊天才知道那个总监挺牛逼的.\n\n## 今日头条 后端研发实习生  - 12面 [GG]\n\n### 一面\n一面直接给了一个问题,\nS_0 = {1}\nS_0 = {1,2,1}\n...\nS_n = S_{n-1},n+1,S_{n-1}\n\n问: 1. |S_n|  开始嘴飘,想当然的就说了,,后来说对了 2^{n+1}-1\n            然后让我证明,,, 不会证,,,\n\n    2. 让实现一个函数int get_value(int n,int i) ,S_n的第i个元素,从0开始,,,,\n        然后我写了一个从1开始的,就被嘲讽了,,,然后一个变量打错,被指漏洞百出...\n        准备说的最优解还没有开始,就不理我了, (第i个数就是0~2^{n+1}-1的第i个数二进制小的最后一个一的长度,或者理解为lowbit(i)的二进制长度)\n\n然后有趣,hr给我打电话,委婉的告诉我挂了,,然后突然来了二面,,,,,\n\n### 二面\n好吧,二面,啥都不会呀 ...\n\n开始看了我一面写的代码,说风格太老了,,,现在C11已经不这么写了,,\n\n然后问我平时用的数据结构是stl的还是C11的,,讲道理我只知道STL的,不知道c11有什么数据结构,难道是传说中的那个能重写pushup,pushdown的内个??\n\n谈了谈我用到的那些数据结构,说我只用过基础的数据结构,,\n然后让说了一下vector的实现,我就说了一下仅了解的它为什么能像数组那个用,,\n\n然后问一堆c11的问题,动态指针什么的,不会\n\n其中夹杂着问\n\n问会计组么,,tm不会呀,说你问吧,我试试\n问了int是反码还是补码,隐隐约约记得是补码,磨磨唧唧说了,\n\n问socket编程, 不会, 没接触过.\n问多线程编程, 我说接触过一点点, 只写过多线程循环打印的.\n\n```\nclass Test{\n    private int a;\n    private int b;\n    int test(){};\n}\nstruct Test2{\n    int a;\n    char b;\n    char c;\n}\n\nsizeof(Test)是多少. 我说12 ,(不知道对错,开始答8然后他沉默就改了, **其实就是8** )  \nsizeof(Test2)是多少. 我说8 , 因为要内存对齐\n```\n\n让我写一个函数验证机器的大小端 表示不知道大小端是什么,\n```\nint main(){\n    int a = 1;\n    char s = *(char *)&a;\n    if(s == 1) puts(\"small\");\n    else       puts(\"big\");\n}\n```\nclass 和 struct的区别, 只知道class默认是private,struct默认是public, 问我还有什么 不知道\n\n问我sizeof(一个指针)是多少,不知道,叨咕了一个8,然后他告诉我32位机器是4,64位机器是8;\n\n给了一个代码\n```\nvoid test(int *p){\n    p = (int *)malloc(sizeof(int))\n}\n```\n问p改没改变\n\n蒙的改变, p指向了新开辟的那个地址.\n\n编程题,大数加法,不让用char a[],只让用string... 写的稍墨迹\n\n然后问string += 和 +的区别\n\n就是 a+=b 和a=a+b\n表示没看过string源码,也不了解string咋实现的,类比vector说了一下. 又错了\n\n问数据库, 我说了解的不是很深入, 然后就没问. (其实以后应该说,试一试,,)\n\n然后就问问题,唠家常了,,,,\n\n最后再见,\n\n结果在一个小时之内,听到了两次同一个hr小姐姐的拒绝电话,,,,\n\n-------------------------------\n体验是真几把刺激,面挂了一面还面了第二面,hhhh,于是二面的时候就很懵逼,,,\n\n但是确实啥都不会呀....\n\n总结就是多学习吧. \n\n但是有个大失误,问计网,操作系统,数据库的时候,应该说试一下的,,毕竟还是看了一些的呀,多少还是能答上来一点的,,\n\n## 美团 后台开发 (搞笑)\n\n开始自我介绍,聊了聊最近看什么数,还有数据库啥的\n\n十分钟过后,跟我说只要Java, 不合适, 嗯 ,然后88\n\n----------------------\n傻逼美团,怎么筛选的简历,岗位要求上不是写的4中语言之一吗,,,,,而且不准备培养实习生的吗,,还听说之前实习生一个转正的都没有??!\n\n## 吉比特 游戏开发(实习) \n\n### 一面\n\n自我介绍\n多线程\n内联函数和宏函数\npython闭包\nsocket编程\n函数内的malloc 存在哪里\n内联函数\n右值引用\n进程间通信\n连续子序列最大和\nvector\nset 和 map的底层数据结构 \nhash冲突解决\n内存泄漏解决\nC++调用函数\n虚析构函数\n一个文本相同的行去除, 保留第一个 (内存存的下/存不下)\n还有问题 记不起来了\n\n--------------------------------------\n表现很差呀, 算法也没有问，代码都没让写，，，\n\n\n## 腾讯 后台开发(实习)\n\n### 一面\n自我介绍,\n\n闲聊\n介绍了ACM比赛\n最近在干什么\n\n技术上的问了\n网络编程接触过没 ->没接触过\n数据一致性怎么保证 -> 不会\n两个文件都是100W个整数,找出相同的 -> 排序,然后归并的过程\n进程间通信 并举例说出场景 -> 管道不知道,剩下三个举例了,\n说说STL -> 说了下vector怎么保证可变长度而且复杂度还是O(1),map和set都是红黑树啥啥啥的\nnew/delete 和malloc/free的区别 -> 说没怎么用过后者,一直用前者,因为后者长.面试官笑..然后说了几个new/delete使用的时候需要注意的问题.\n谈到指针,问多线程删除map元素怎么办 -> 先回答把多个线程要删除的记下来,然后统一删除, 他说可以, 但是希望我在指针的方式考虑, 想了想不会, 他让我回去看下map的源码关于元素删除的部分, 看过之后会有想法.\n多线程有什么了解 -> 说了下ABC循环打印的那个, 然后就没有了\n高并发怎么处理, -> 读的不加锁,写的加锁\n接上个问我脏读怎么办 -> 我说加个时间戳,他说不太好,然后不会了\n对安全了解多少 -> 把只会的凯撒加密和RSA加密说了说\n对称加密和非对称加密 -> 忘记了,说不太清了,告诉他不强答\nC++的封装/继承/多态-> 说了说多态和继承,封装我觉得没啥说的呀,,\n\n还有几个问题,忘了\n\n非技术问题\n说给我安排一个任务,一周上线,这个任务我现在不会,怎么办 -> 我觉得时间够用,没有问题,2天时间学习,3天时间实现, 具体实施的时候先请教别人,翻论文 \n如果我现在时间很紧的赶一个任务,有人请教我会的东西,我怎么做 -> 甩给他相关的资料让他自己学习, 如果还不懂,粗浅的指点一下  还不懂,就对不起了,(这个很坑呀,步步紧逼)\n\n问问题\n就问了怎么学习linux,\n之前准备问的问题,都忘记问了\n\n----------------------------------\n面试官挺随和的, 开始挺紧张的 ,后来就不紧张了, 现场面试还是比电面/视频面舒服.\n过程就像实在闲聊\n还是什么都不会, 面试官让我把学习重心放在网络编程和安全这方面,说用到的多,学习的时候多看看源码.\n\n### 二面\n\n问的和一面差不多,\n多问了几个小问题而已\n\n数据库的东西问了很多, 但不会\n然后和一面有重复的问题,但是昨天回去查了下,答得比较完整\nHash处理冲突,解决办法\n内存泄露的时候如何定位 -> 说调用系统的函数监控内存\n内存分布 -> 有一个忘记了,其他的说的没问题\n进程调度算法 -> 先到先服务 , 短作业优先, 多级反馈队列\n接上个问现在系统的调度算法 -> 在提示说同时能音乐,处理网页这些 想起来时间片轮转算法,说了些, \nstd::sort()怎么实现的 -> 内省排序,\n接上个std::sort()什么时候采用插入排序,归并排序,快排 -> 举了什么时候插排会更快, 和归并是为了防止快排退化 balabala\n\n剩下的暂时想不起来了,\n\n\n----------------------------------\n面试官看起来挺年轻的, 数据库东西确实不太会, 而且又没让写代码, 以为凉凉了,,,\n5点多接到明天hr面的消息,\n\n\n## 旷视 Face++   后台实习生 \n\n### 一面\n\n就两个问题\n一个拓扑排序,拓扑序计数,\n一个二分check的问题\n\n开始网站打不开,只写了第二个的代码\n\n然后就问我最近学什么, 以后的方向什么的 聊了好久\n\n问了几个问题就结束了\n\n--------------------------------------\n感觉不错,面试官说重视的就是coding能力,其他的都可以在学,\n等消息\n~~智障,问面试官需要什么样的人才,说我这样的,一周后问面试官,说挂了~~\n\n## 京东云 C++(实习)\n\n### 一面\n刚面完腾讯的hr面回来到实验室扯了两句,就收到面试了\n\n给了个写代码的网页死活打不开,然后就改手写发照片了\n写了一个矩阵,一层一层输出的代码\n\n然后说了C++的stl\nvector的变长机制\n平衡树\n\ntcp的三次握手,四次挥手,为什么三次,为什么四次\n网络分层,说了下osi的七层\n问tcp在那层,不知道,猜了个网络层,,,然后面试官问tcp的t是什么,想起是transfer,说出了传输层\n\n然后还有几个问题,忘了\n\n日常问面试官问题结束\n---------------------------------\n面试官挺nice的\n\n### 二面\n感觉效率很高 上午面完下午5点就来二面了,\n\n面向对象编程谈谈\nC++ stl\n内存分布\n网络的那几个老生常谈的问题\n进程间通信\n数据库谈了谈\n\n一个linux 操作的问题,不会\n\n还有几个问题 忘了\n\n### hr面\n因为一二面是周五 周一去考科四的时候来的电话\n\n瞎聊天 结束\n","source":"_posts/ExperienceOfInterview.md","raw":"---\ntitle: 面试经历.\ndate: 2018-1-31 15:56:08\ncategories:  \ntags: [面试,C++,数据库,操作系统,计算机网络] #文章标签，可空，多标签请用格式，注意:后面有个空格\ndescription: \ntoc: true\n---\n\n> 总结下所有的面试, 这样才能**慢慢**进步呀,,,,\n\n## 哈尔滨某小公司 - C++岗实习 [现场面] - offer\n\n除了问一个多态,没有技术问题,大概是给答上了 意思对,但不专业\n\n-----\n小公司估计是真的没人了,,,,待遇实在...拒绝\n\n\n## 头条 - 后台开发实习生 [视频面试] 一面 - 跪\n\n可能是紧张吧,开始闲聊然后给了个编程题\n给一个化学表达式\n```math\neg: HMg_{_2}(H_2O(N_3Ag)_2)_3N_2\n```\n,让算每个元素有多少个.\n\n这种题本就不难 问题就是怎么处理括号 \n之前在hiho上还遇到过类似的问题http://www.hihocoder.com/contest/offers41/problem/2\n\n然后不知道紧张还是什么的就写的很乱,然后面试官提示递归,然后墨迹了好久才用stack写了下来.....\n\n因为我没有项目,就没有问项目.\n然后问我们学了数据库,操作系统,网络没有,,,,   嗯 学校确实讲过,但我没听过课...\n\n问了个进程调度,\n\n我就知道有个算法叫FIFO, 具体是啥还忘了, 然后说错了,,GG\n\n然后唠了两句面试官说结束,等HR通知,,,  嗯.感谢面试官浪费40+分钟陪我 hhhh.\n\n--------------------------\n\n总结:\n有点紧张. 代码能力差 ,**[数据库,操作系统,网络]** 知识严重匮乏.\n\n之前看面经说,遇到不会的或者把不准的都应该说**不会**. 下次注意.\n\n\n## 达内 - NOIP助教 现场面\n\n达内这个大家都懂.\n\n突然有天接到达内一个经理的电话,问我能不能去当助教,去教小朋友普及组的NOIP.\n我心想,这也还不错呀.\n然后去了,开始跟我吹了1个小时的牛逼,达内多么多么牛逼.怎么怎么地.\n然后给了我一份NOIP普及组的题让我做..\n\n说来惭愧,中文题面,我竟读错一道题卡了好久,,,然后花了1个多小时终于把4个题做出来了,最后一题还做得很麻烦...\n然后来了一个小伙子,谈了谈对NOIP的认识,以及我的学习情况.\n交上去给了一个小姐姐,然后看见三个人对着电脑看了半天..\n\n然后说一定要一年,但我最多只能半年,于是据.\n\n------------------------------\n体验美滋滋,没有麻烦的题目,没有操作系统,没有计算机网络,没有数据库.真棒 hhh\n\n## 深信服 - C/C++ 电话面试 一面-估计跪了\n\n深圳打来的电话, 不知道哪里人, 浓重的方言口音, 他说话我都要问好多遍才能听懂...交流真滴有障碍...\n\n一共22分钟,三个问题\n\n1 . 两个字符串,一个大串,一个小串,问小串是不是大串的子串(不连续)的.\n\n我回答了: 遍历大串,然后对小串维护一个遍历的指针就行了\n\n然后他说不是他想要的,问的是正则?\n\n我记得有正则查询可以模糊匹配,只要在两个相邻的字母中插进去就好了,,但我忘记了具体插什么,\n\n结束后一查知道是 `.*` [. 匹配任意非\\n的字符 *是0个或多个]\n\n2 . 给一个100万的字符串,然后找到最短的循环覆盖的子串.\n\n我开始以为是ABCABC这样的 最短就是ABC了 ,拿next数组直接做就行了,\n\n然后说了半天,最后知道,他说的可以是这样ABCABCAB,还可以是ABC\n\n想了想发现和之前的一样, 还是求next数组,然后就可以把结尾的AB给去掉了,然后就和之前一样了.\n\n然后不知怎么就陷入了一阵交流障碍,我不知道他说的啥,他不知道我说的啥.\n\n然后我发现他是想让我说一下next怎么求...\n\n想了想,不能画图 怎么说呀, 问写代码行吗, 额 他也看不见....\n\n然后勉强解释了下 维护两个指针,一个i遍历大串,j是维护匹配到的位置,balabala的,\n\n也不知道他明白没有...\n\n----------\n\n然后他问我用linux还是windows多,\n\n我说用过linux,但还是windows多.\n\n然后问我一个问题,我听成了python.. 我说我会python.....但他好像问的根本不是这个问题,,,\n\n---------\n3 . 最后问我进程的内存分布\n\n我不会呀..\n\n说了一个堆栈..就说不知道了, \n\n于是结束...\n\n目测GG\n\n\n---\n\n总结: 说好的12点,结果15点电话过来了,,,措手不及,以为没我事儿了呢,\n\n交流障碍导致前面两个问题说的不太好,而且电话面试真的不如视频面试呀,更别说现场面试了,,,后面确实不会, 操作系统,网络,数据库 多看看呀..\n\n\n## 阿里云, 分布式,大数据   - 基础平台研发工程师实习 电话面试 一面-跪了\n\nredis和MongoDB的区别。 谈一谈这两个数据库 。   (他以为我是自己搭建的数据库，，但我就是安装然后用的呀)\n说一下大数据: hadoop - HDFS，hive 和 MapReduce ，问哪个是存储的，脑抽说了个hive，，， 后来改正了，然后问HDFS里面都有什么，答NameNode 和 DataNode，\n问我还有什么，我不知道，他告诉我还有sdk。\n\n然后让我说竞赛中做过的经典，印象深刻的题目，想了好久，随便说了一个题，题目不怎么难，其实说的很模糊，而且说的时候还把那个题给弱化了，，记不太清那个题目了，\n\n然后问了我一个问题，现在都没想明白，说HDFS传3个副本，然后又客户在另一端访问这个。 然后是传完这**三**个副本告诉客户传完了有一个延迟时间，这**两**个副本告诉客户传完了有一个延迟时间，，\n两个的会比三个的地低，\n然后给初问题，给一个T，求N，M。 T是客户允许的最长延迟时间，N是副本总数，M是传完M个告诉客户传完了。\n我只知道可以通过传好多次 算一个副本的时间t，但是不会算大T， 跟概率，期望，有关\n\n\n最后让写了一个编程题，很简单的n个区间 问覆盖的长度总和是多少。 谈了50多分种 脑子有点蒙，写了好几分钟。。 但他看了好长时间，难道是我写的错啦？？。。\n\n然后问了面试官几个问题，\n大数据如何高效学习，论文，跟进\n分布式如何学习，\n\n他们这个是做底层的，，，\n\n然后就是如果通过了 下次面试是什么时候，，，，但估计没有下次了，，，，，\n\n--------\n虽然啥都不会，什么都没有答上来。 体验非常好的一次面试，面试官人特别好，面对我这样的垃圾面试人员，应该很无奈，但依然很耐心的面试我，最后还提了好多问题。\n\n但是很奇怪，这次竟然一点操作系统和数据结构的问题都没有问， 之前看到牛客网一个基础平台研发，问了这些问题的呀。\n\n## 瓜子二手车 后台研发实习生 现场一二面, 给了offer邀请.\n\n- 1面\n    自我介绍,没准备,随便说了下\n    唠了两句家常.\n\n    绳子不均匀,燃烧的问题,一根绳子1个小时烧完.\n    怎么找30分钟,75分钟.\n\n    说下栈和队列\n    双栈怎么实现队列\n\n    计算机网络的几个零碎的小问题,没记住.\n\n    然后写了两个代码题\n    - 交叉的链表,找交叉的位置,\n    链表的代码思路对,但是head节点没有val这点被我忘记了\n    - 单链表找倒数第k个节点,\n    \n    数据库索引怎么实现的 -> b+树\n    b+树为什么会快 -> 搜索树,有剪枝\n    非\\*\\*和\\*\\*的区别 -> 不知道,没听说过 (告诉我是 index 和 index+data的区别,名字想不起来了)\n    数据库事务的四个特性ACID -> 我分不清那个是哪个了,就举个例子说了,\n    还有两个数据库的问题,想不起来了,\n\n    问问题,问了技术栈和分布式的东西.\n\n- 2面\n    领我进去的小哥哥说是总监面\n\n    自我介绍.唠家常.\n\n    两个集合求交,写代码 谢了归并排序+二分, 然后过了会说了个更简单的方法,\n\n    几个小问题,没记住\n\n    给我写了几个词,让我谈一谈\n    - set,stack,链表,数组,map,hash\n    - tcp,udp,http,https,ftp\n\n    聊了聊最近在学习什么.说我基础薄弱..\n\n    问问题. 问了职业规划.答:选择做技术就一直做技术.\n \n ---\n可能因为是小公司吧,问的问题都比较简单.算法为了体现水平,学习了网上的套路,先给出一个不是很好的做法,然后再给一个优秀的做法.[斜眼笑]\n走的时候小哥哥看了看评价表和我说不错,应该很稳,让我回去等消息就行啦. \n面试官都很随和,出去的时候和一个工大研一的同来面试的小哥哥聊天才知道那个总监挺牛逼的.\n\n## 今日头条 后端研发实习生  - 12面 [GG]\n\n### 一面\n一面直接给了一个问题,\nS_0 = {1}\nS_0 = {1,2,1}\n...\nS_n = S_{n-1},n+1,S_{n-1}\n\n问: 1. |S_n|  开始嘴飘,想当然的就说了,,后来说对了 2^{n+1}-1\n            然后让我证明,,, 不会证,,,\n\n    2. 让实现一个函数int get_value(int n,int i) ,S_n的第i个元素,从0开始,,,,\n        然后我写了一个从1开始的,就被嘲讽了,,,然后一个变量打错,被指漏洞百出...\n        准备说的最优解还没有开始,就不理我了, (第i个数就是0~2^{n+1}-1的第i个数二进制小的最后一个一的长度,或者理解为lowbit(i)的二进制长度)\n\n然后有趣,hr给我打电话,委婉的告诉我挂了,,然后突然来了二面,,,,,\n\n### 二面\n好吧,二面,啥都不会呀 ...\n\n开始看了我一面写的代码,说风格太老了,,,现在C11已经不这么写了,,\n\n然后问我平时用的数据结构是stl的还是C11的,,讲道理我只知道STL的,不知道c11有什么数据结构,难道是传说中的那个能重写pushup,pushdown的内个??\n\n谈了谈我用到的那些数据结构,说我只用过基础的数据结构,,\n然后让说了一下vector的实现,我就说了一下仅了解的它为什么能像数组那个用,,\n\n然后问一堆c11的问题,动态指针什么的,不会\n\n其中夹杂着问\n\n问会计组么,,tm不会呀,说你问吧,我试试\n问了int是反码还是补码,隐隐约约记得是补码,磨磨唧唧说了,\n\n问socket编程, 不会, 没接触过.\n问多线程编程, 我说接触过一点点, 只写过多线程循环打印的.\n\n```\nclass Test{\n    private int a;\n    private int b;\n    int test(){};\n}\nstruct Test2{\n    int a;\n    char b;\n    char c;\n}\n\nsizeof(Test)是多少. 我说12 ,(不知道对错,开始答8然后他沉默就改了, **其实就是8** )  \nsizeof(Test2)是多少. 我说8 , 因为要内存对齐\n```\n\n让我写一个函数验证机器的大小端 表示不知道大小端是什么,\n```\nint main(){\n    int a = 1;\n    char s = *(char *)&a;\n    if(s == 1) puts(\"small\");\n    else       puts(\"big\");\n}\n```\nclass 和 struct的区别, 只知道class默认是private,struct默认是public, 问我还有什么 不知道\n\n问我sizeof(一个指针)是多少,不知道,叨咕了一个8,然后他告诉我32位机器是4,64位机器是8;\n\n给了一个代码\n```\nvoid test(int *p){\n    p = (int *)malloc(sizeof(int))\n}\n```\n问p改没改变\n\n蒙的改变, p指向了新开辟的那个地址.\n\n编程题,大数加法,不让用char a[],只让用string... 写的稍墨迹\n\n然后问string += 和 +的区别\n\n就是 a+=b 和a=a+b\n表示没看过string源码,也不了解string咋实现的,类比vector说了一下. 又错了\n\n问数据库, 我说了解的不是很深入, 然后就没问. (其实以后应该说,试一试,,)\n\n然后就问问题,唠家常了,,,,\n\n最后再见,\n\n结果在一个小时之内,听到了两次同一个hr小姐姐的拒绝电话,,,,\n\n-------------------------------\n体验是真几把刺激,面挂了一面还面了第二面,hhhh,于是二面的时候就很懵逼,,,\n\n但是确实啥都不会呀....\n\n总结就是多学习吧. \n\n但是有个大失误,问计网,操作系统,数据库的时候,应该说试一下的,,毕竟还是看了一些的呀,多少还是能答上来一点的,,\n\n## 美团 后台开发 (搞笑)\n\n开始自我介绍,聊了聊最近看什么数,还有数据库啥的\n\n十分钟过后,跟我说只要Java, 不合适, 嗯 ,然后88\n\n----------------------\n傻逼美团,怎么筛选的简历,岗位要求上不是写的4中语言之一吗,,,,,而且不准备培养实习生的吗,,还听说之前实习生一个转正的都没有??!\n\n## 吉比特 游戏开发(实习) \n\n### 一面\n\n自我介绍\n多线程\n内联函数和宏函数\npython闭包\nsocket编程\n函数内的malloc 存在哪里\n内联函数\n右值引用\n进程间通信\n连续子序列最大和\nvector\nset 和 map的底层数据结构 \nhash冲突解决\n内存泄漏解决\nC++调用函数\n虚析构函数\n一个文本相同的行去除, 保留第一个 (内存存的下/存不下)\n还有问题 记不起来了\n\n--------------------------------------\n表现很差呀, 算法也没有问，代码都没让写，，，\n\n\n## 腾讯 后台开发(实习)\n\n### 一面\n自我介绍,\n\n闲聊\n介绍了ACM比赛\n最近在干什么\n\n技术上的问了\n网络编程接触过没 ->没接触过\n数据一致性怎么保证 -> 不会\n两个文件都是100W个整数,找出相同的 -> 排序,然后归并的过程\n进程间通信 并举例说出场景 -> 管道不知道,剩下三个举例了,\n说说STL -> 说了下vector怎么保证可变长度而且复杂度还是O(1),map和set都是红黑树啥啥啥的\nnew/delete 和malloc/free的区别 -> 说没怎么用过后者,一直用前者,因为后者长.面试官笑..然后说了几个new/delete使用的时候需要注意的问题.\n谈到指针,问多线程删除map元素怎么办 -> 先回答把多个线程要删除的记下来,然后统一删除, 他说可以, 但是希望我在指针的方式考虑, 想了想不会, 他让我回去看下map的源码关于元素删除的部分, 看过之后会有想法.\n多线程有什么了解 -> 说了下ABC循环打印的那个, 然后就没有了\n高并发怎么处理, -> 读的不加锁,写的加锁\n接上个问我脏读怎么办 -> 我说加个时间戳,他说不太好,然后不会了\n对安全了解多少 -> 把只会的凯撒加密和RSA加密说了说\n对称加密和非对称加密 -> 忘记了,说不太清了,告诉他不强答\nC++的封装/继承/多态-> 说了说多态和继承,封装我觉得没啥说的呀,,\n\n还有几个问题,忘了\n\n非技术问题\n说给我安排一个任务,一周上线,这个任务我现在不会,怎么办 -> 我觉得时间够用,没有问题,2天时间学习,3天时间实现, 具体实施的时候先请教别人,翻论文 \n如果我现在时间很紧的赶一个任务,有人请教我会的东西,我怎么做 -> 甩给他相关的资料让他自己学习, 如果还不懂,粗浅的指点一下  还不懂,就对不起了,(这个很坑呀,步步紧逼)\n\n问问题\n就问了怎么学习linux,\n之前准备问的问题,都忘记问了\n\n----------------------------------\n面试官挺随和的, 开始挺紧张的 ,后来就不紧张了, 现场面试还是比电面/视频面舒服.\n过程就像实在闲聊\n还是什么都不会, 面试官让我把学习重心放在网络编程和安全这方面,说用到的多,学习的时候多看看源码.\n\n### 二面\n\n问的和一面差不多,\n多问了几个小问题而已\n\n数据库的东西问了很多, 但不会\n然后和一面有重复的问题,但是昨天回去查了下,答得比较完整\nHash处理冲突,解决办法\n内存泄露的时候如何定位 -> 说调用系统的函数监控内存\n内存分布 -> 有一个忘记了,其他的说的没问题\n进程调度算法 -> 先到先服务 , 短作业优先, 多级反馈队列\n接上个问现在系统的调度算法 -> 在提示说同时能音乐,处理网页这些 想起来时间片轮转算法,说了些, \nstd::sort()怎么实现的 -> 内省排序,\n接上个std::sort()什么时候采用插入排序,归并排序,快排 -> 举了什么时候插排会更快, 和归并是为了防止快排退化 balabala\n\n剩下的暂时想不起来了,\n\n\n----------------------------------\n面试官看起来挺年轻的, 数据库东西确实不太会, 而且又没让写代码, 以为凉凉了,,,\n5点多接到明天hr面的消息,\n\n\n## 旷视 Face++   后台实习生 \n\n### 一面\n\n就两个问题\n一个拓扑排序,拓扑序计数,\n一个二分check的问题\n\n开始网站打不开,只写了第二个的代码\n\n然后就问我最近学什么, 以后的方向什么的 聊了好久\n\n问了几个问题就结束了\n\n--------------------------------------\n感觉不错,面试官说重视的就是coding能力,其他的都可以在学,\n等消息\n~~智障,问面试官需要什么样的人才,说我这样的,一周后问面试官,说挂了~~\n\n## 京东云 C++(实习)\n\n### 一面\n刚面完腾讯的hr面回来到实验室扯了两句,就收到面试了\n\n给了个写代码的网页死活打不开,然后就改手写发照片了\n写了一个矩阵,一层一层输出的代码\n\n然后说了C++的stl\nvector的变长机制\n平衡树\n\ntcp的三次握手,四次挥手,为什么三次,为什么四次\n网络分层,说了下osi的七层\n问tcp在那层,不知道,猜了个网络层,,,然后面试官问tcp的t是什么,想起是transfer,说出了传输层\n\n然后还有几个问题,忘了\n\n日常问面试官问题结束\n---------------------------------\n面试官挺nice的\n\n### 二面\n感觉效率很高 上午面完下午5点就来二面了,\n\n面向对象编程谈谈\nC++ stl\n内存分布\n网络的那几个老生常谈的问题\n进程间通信\n数据库谈了谈\n\n一个linux 操作的问题,不会\n\n还有几个问题 忘了\n\n### hr面\n因为一二面是周五 周一去考科四的时候来的电话\n\n瞎聊天 结束\n","slug":"ExperienceOfInterview","published":1,"updated":"2018-09-23T07:59:28.604Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnyhsxnr000fas1ogy9ykrsm","content":"<blockquote>\n<p>总结下所有的面试, 这样才能<strong>慢慢</strong>进步呀,,,,</p>\n</blockquote>\n<h2 id=\"哈尔滨某小公司-C-岗实习-现场面-offer\"><a href=\"#哈尔滨某小公司-C-岗实习-现场面-offer\" class=\"headerlink\" title=\"哈尔滨某小公司 - C++岗实习 [现场面] - offer\"></a>哈尔滨某小公司 - C++岗实习 [现场面] - offer</h2><p>除了问一个多态,没有技术问题,大概是给答上了 意思对,但不专业</p>\n<hr>\n<p>小公司估计是真的没人了,,,,待遇实在…拒绝</p>\n<h2 id=\"头条-后台开发实习生-视频面试-一面-跪\"><a href=\"#头条-后台开发实习生-视频面试-一面-跪\" class=\"headerlink\" title=\"头条 - 后台开发实习生 [视频面试] 一面 - 跪\"></a>头条 - 后台开发实习生 [视频面试] 一面 - 跪</h2><p>可能是紧张吧,开始闲聊然后给了个编程题<br>给一个化学表达式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg: HMg_&#123;_2&#125;(H_2O(N_3Ag)_2)_3N_2</span><br></pre></td></tr></table></figure></p>\n<p>,让算每个元素有多少个.</p>\n<p>这种题本就不难 问题就是怎么处理括号<br>之前在hiho上还遇到过类似的问题<a href=\"http://www.hihocoder.com/contest/offers41/problem/2\" target=\"_blank\" rel=\"noopener\">http://www.hihocoder.com/contest/offers41/problem/2</a></p>\n<p>然后不知道紧张还是什么的就写的很乱,然后面试官提示递归,然后墨迹了好久才用stack写了下来…..</p>\n<p>因为我没有项目,就没有问项目.<br>然后问我们学了数据库,操作系统,网络没有,,,,   嗯 学校确实讲过,但我没听过课…</p>\n<p>问了个进程调度,</p>\n<p>我就知道有个算法叫FIFO, 具体是啥还忘了, 然后说错了,,GG</p>\n<p>然后唠了两句面试官说结束,等HR通知,,,  嗯.感谢面试官浪费40+分钟陪我 hhhh.</p>\n<hr>\n<p>总结:<br>有点紧张. 代码能力差 ,<strong>[数据库,操作系统,网络]</strong> 知识严重匮乏.</p>\n<p>之前看面经说,遇到不会的或者把不准的都应该说<strong>不会</strong>. 下次注意.</p>\n<h2 id=\"达内-NOIP助教-现场面\"><a href=\"#达内-NOIP助教-现场面\" class=\"headerlink\" title=\"达内 - NOIP助教 现场面\"></a>达内 - NOIP助教 现场面</h2><p>达内这个大家都懂.</p>\n<p>突然有天接到达内一个经理的电话,问我能不能去当助教,去教小朋友普及组的NOIP.<br>我心想,这也还不错呀.<br>然后去了,开始跟我吹了1个小时的牛逼,达内多么多么牛逼.怎么怎么地.<br>然后给了我一份NOIP普及组的题让我做..</p>\n<p>说来惭愧,中文题面,我竟读错一道题卡了好久,,,然后花了1个多小时终于把4个题做出来了,最后一题还做得很麻烦…<br>然后来了一个小伙子,谈了谈对NOIP的认识,以及我的学习情况.<br>交上去给了一个小姐姐,然后看见三个人对着电脑看了半天..</p>\n<p>然后说一定要一年,但我最多只能半年,于是据.</p>\n<hr>\n<p>体验美滋滋,没有麻烦的题目,没有操作系统,没有计算机网络,没有数据库.真棒 hhh</p>\n<h2 id=\"深信服-C-C-电话面试-一面-估计跪了\"><a href=\"#深信服-C-C-电话面试-一面-估计跪了\" class=\"headerlink\" title=\"深信服 - C/C++ 电话面试 一面-估计跪了\"></a>深信服 - C/C++ 电话面试 一面-估计跪了</h2><p>深圳打来的电话, 不知道哪里人, 浓重的方言口音, 他说话我都要问好多遍才能听懂…交流真滴有障碍…</p>\n<p>一共22分钟,三个问题</p>\n<p>1 . 两个字符串,一个大串,一个小串,问小串是不是大串的子串(不连续)的.</p>\n<p>我回答了: 遍历大串,然后对小串维护一个遍历的指针就行了</p>\n<p>然后他说不是他想要的,问的是正则?</p>\n<p>我记得有正则查询可以模糊匹配,只要在两个相邻的字母中插进去就好了,,但我忘记了具体插什么,</p>\n<p>结束后一查知道是 <code>.*</code> [. 匹配任意非\\n的字符 *是0个或多个]</p>\n<p>2 . 给一个100万的字符串,然后找到最短的循环覆盖的子串.</p>\n<p>我开始以为是ABCABC这样的 最短就是ABC了 ,拿next数组直接做就行了,</p>\n<p>然后说了半天,最后知道,他说的可以是这样ABCABCAB,还可以是ABC</p>\n<p>想了想发现和之前的一样, 还是求next数组,然后就可以把结尾的AB给去掉了,然后就和之前一样了.</p>\n<p>然后不知怎么就陷入了一阵交流障碍,我不知道他说的啥,他不知道我说的啥.</p>\n<p>然后我发现他是想让我说一下next怎么求…</p>\n<p>想了想,不能画图 怎么说呀, 问写代码行吗, 额 他也看不见….</p>\n<p>然后勉强解释了下 维护两个指针,一个i遍历大串,j是维护匹配到的位置,balabala的,</p>\n<p>也不知道他明白没有…</p>\n<hr>\n<p>然后他问我用linux还是windows多,</p>\n<p>我说用过linux,但还是windows多.</p>\n<p>然后问我一个问题,我听成了python.. 我说我会python…..但他好像问的根本不是这个问题,,,</p>\n<hr>\n<p>3 . 最后问我进程的内存分布</p>\n<p>我不会呀..</p>\n<p>说了一个堆栈..就说不知道了, </p>\n<p>于是结束…</p>\n<p>目测GG</p>\n<hr>\n<p>总结: 说好的12点,结果15点电话过来了,,,措手不及,以为没我事儿了呢,</p>\n<p>交流障碍导致前面两个问题说的不太好,而且电话面试真的不如视频面试呀,更别说现场面试了,,,后面确实不会, 操作系统,网络,数据库 多看看呀..</p>\n<h2 id=\"阿里云-分布式-大数据-基础平台研发工程师实习-电话面试-一面-跪了\"><a href=\"#阿里云-分布式-大数据-基础平台研发工程师实习-电话面试-一面-跪了\" class=\"headerlink\" title=\"阿里云, 分布式,大数据   - 基础平台研发工程师实习 电话面试 一面-跪了\"></a>阿里云, 分布式,大数据   - 基础平台研发工程师实习 电话面试 一面-跪了</h2><p>redis和MongoDB的区别。 谈一谈这两个数据库 。   (他以为我是自己搭建的数据库，，但我就是安装然后用的呀)<br>说一下大数据: hadoop - HDFS，hive 和 MapReduce ，问哪个是存储的，脑抽说了个hive，，， 后来改正了，然后问HDFS里面都有什么，答NameNode 和 DataNode，<br>问我还有什么，我不知道，他告诉我还有sdk。</p>\n<p>然后让我说竞赛中做过的经典，印象深刻的题目，想了好久，随便说了一个题，题目不怎么难，其实说的很模糊，而且说的时候还把那个题给弱化了，，记不太清那个题目了，</p>\n<p>然后问了我一个问题，现在都没想明白，说HDFS传3个副本，然后又客户在另一端访问这个。 然后是传完这<strong>三</strong>个副本告诉客户传完了有一个延迟时间，这<strong>两</strong>个副本告诉客户传完了有一个延迟时间，，<br>两个的会比三个的地低，<br>然后给初问题，给一个T，求N，M。 T是客户允许的最长延迟时间，N是副本总数，M是传完M个告诉客户传完了。<br>我只知道可以通过传好多次 算一个副本的时间t，但是不会算大T， 跟概率，期望，有关</p>\n<p>最后让写了一个编程题，很简单的n个区间 问覆盖的长度总和是多少。 谈了50多分种 脑子有点蒙，写了好几分钟。。 但他看了好长时间，难道是我写的错啦？？。。</p>\n<p>然后问了面试官几个问题，<br>大数据如何高效学习，论文，跟进<br>分布式如何学习，</p>\n<p>他们这个是做底层的，，，</p>\n<p>然后就是如果通过了 下次面试是什么时候，，，，但估计没有下次了，，，，，</p>\n<hr>\n<p>虽然啥都不会，什么都没有答上来。 体验非常好的一次面试，面试官人特别好，面对我这样的垃圾面试人员，应该很无奈，但依然很耐心的面试我，最后还提了好多问题。</p>\n<p>但是很奇怪，这次竟然一点操作系统和数据结构的问题都没有问， 之前看到牛客网一个基础平台研发，问了这些问题的呀。</p>\n<h2 id=\"瓜子二手车-后台研发实习生-现场一二面-给了offer邀请\"><a href=\"#瓜子二手车-后台研发实习生-现场一二面-给了offer邀请\" class=\"headerlink\" title=\"瓜子二手车 后台研发实习生 现场一二面, 给了offer邀请.\"></a>瓜子二手车 后台研发实习生 现场一二面, 给了offer邀请.</h2><ul>\n<li><p>1面<br>  自我介绍,没准备,随便说了下<br>  唠了两句家常.</p>\n<p>  绳子不均匀,燃烧的问题,一根绳子1个小时烧完.<br>  怎么找30分钟,75分钟.</p>\n<p>  说下栈和队列<br>  双栈怎么实现队列</p>\n<p>  计算机网络的几个零碎的小问题,没记住.</p>\n<p>  然后写了两个代码题</p>\n<ul>\n<li>交叉的链表,找交叉的位置,<br>链表的代码思路对,但是head节点没有val这点被我忘记了</li>\n<li><p>单链表找倒数第k个节点,</p>\n<p>数据库索引怎么实现的 -&gt; b+树<br>b+树为什么会快 -&gt; 搜索树,有剪枝<br>非**和**的区别 -&gt; 不知道,没听说过 (告诉我是 index 和 index+data的区别,名字想不起来了)<br>数据库事务的四个特性ACID -&gt; 我分不清那个是哪个了,就举个例子说了,<br>还有两个数据库的问题,想不起来了,</p>\n<p>问问题,问了技术栈和分布式的东西.</p>\n</li>\n</ul>\n</li>\n<li><p>2面<br>  领我进去的小哥哥说是总监面</p>\n<p>  自我介绍.唠家常.</p>\n<p>  两个集合求交,写代码 谢了归并排序+二分, 然后过了会说了个更简单的方法,</p>\n<p>  几个小问题,没记住</p>\n<p>  给我写了几个词,让我谈一谈</p>\n<ul>\n<li>set,stack,链表,数组,map,hash</li>\n<li><p>tcp,udp,http,https,ftp</p>\n<p>聊了聊最近在学习什么.说我基础薄弱..</p>\n<p>问问题. 问了职业规划.答:选择做技术就一直做技术.</p>\n</li>\n</ul>\n<hr>\n<p>可能因为是小公司吧,问的问题都比较简单.算法为了体现水平,学习了网上的套路,先给出一个不是很好的做法,然后再给一个优秀的做法.[斜眼笑]<br>走的时候小哥哥看了看评价表和我说不错,应该很稳,让我回去等消息就行啦.<br>面试官都很随和,出去的时候和一个工大研一的同来面试的小哥哥聊天才知道那个总监挺牛逼的.</p>\n</li>\n</ul>\n<h2 id=\"今日头条-后端研发实习生-12面-GG\"><a href=\"#今日头条-后端研发实习生-12面-GG\" class=\"headerlink\" title=\"今日头条 后端研发实习生  - 12面 [GG]\"></a>今日头条 后端研发实习生  - 12面 [GG]</h2><h3 id=\"一面\"><a href=\"#一面\" class=\"headerlink\" title=\"一面\"></a>一面</h3><p>一面直接给了一个问题,<br>S_0 = {1}<br>S_0 = {1,2,1}<br>…<br>S_n = S_{n-1},n+1,S_{n-1}</p>\n<p>问: 1. |S_n|  开始嘴飘,想当然的就说了,,后来说对了 2^{n+1}-1<br>            然后让我证明,,, 不会证,,,</p>\n<pre><code>2. 让实现一个函数int get_value(int n,int i) ,S_n的第i个元素,从0开始,,,,\n    然后我写了一个从1开始的,就被嘲讽了,,,然后一个变量打错,被指漏洞百出...\n    准备说的最优解还没有开始,就不理我了, (第i个数就是0~2^{n+1}-1的第i个数二进制小的最后一个一的长度,或者理解为lowbit(i)的二进制长度)\n</code></pre><p>然后有趣,hr给我打电话,委婉的告诉我挂了,,然后突然来了二面,,,,,</p>\n<h3 id=\"二面\"><a href=\"#二面\" class=\"headerlink\" title=\"二面\"></a>二面</h3><p>好吧,二面,啥都不会呀 …</p>\n<p>开始看了我一面写的代码,说风格太老了,,,现在C11已经不这么写了,,</p>\n<p>然后问我平时用的数据结构是stl的还是C11的,,讲道理我只知道STL的,不知道c11有什么数据结构,难道是传说中的那个能重写pushup,pushdown的内个??</p>\n<p>谈了谈我用到的那些数据结构,说我只用过基础的数据结构,,<br>然后让说了一下vector的实现,我就说了一下仅了解的它为什么能像数组那个用,,</p>\n<p>然后问一堆c11的问题,动态指针什么的,不会</p>\n<p>其中夹杂着问</p>\n<p>问会计组么,,tm不会呀,说你问吧,我试试<br>问了int是反码还是补码,隐隐约约记得是补码,磨磨唧唧说了,</p>\n<p>问socket编程, 不会, 没接触过.<br>问多线程编程, 我说接触过一点点, 只写过多线程循环打印的.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Test&#123;</span><br><span class=\"line\">    private int a;</span><br><span class=\"line\">    private int b;</span><br><span class=\"line\">    int test()&#123;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">struct Test2&#123;</span><br><span class=\"line\">    int a;</span><br><span class=\"line\">    char b;</span><br><span class=\"line\">    char c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">sizeof(Test)是多少. 我说12 ,(不知道对错,开始答8然后他沉默就改了, **其实就是8** )  </span><br><span class=\"line\">sizeof(Test2)是多少. 我说8 , 因为要内存对齐</span><br></pre></td></tr></table></figure>\n<p>让我写一个函数验证机器的大小端 表示不知道大小端是什么,<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    int a = 1;</span><br><span class=\"line\">    char s = *(char *)&amp;a;</span><br><span class=\"line\">    if(s == 1) puts(&quot;small&quot;);</span><br><span class=\"line\">    else       puts(&quot;big&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>class 和 struct的区别, 只知道class默认是private,struct默认是public, 问我还有什么 不知道</p>\n<p>问我sizeof(一个指针)是多少,不知道,叨咕了一个8,然后他告诉我32位机器是4,64位机器是8;</p>\n<p>给了一个代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void test(int *p)&#123;</span><br><span class=\"line\">    p = (int *)malloc(sizeof(int))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>问p改没改变</p>\n<p>蒙的改变, p指向了新开辟的那个地址.</p>\n<p>编程题,大数加法,不让用char a[],只让用string… 写的稍墨迹</p>\n<p>然后问string += 和 +的区别</p>\n<p>就是 a+=b 和a=a+b<br>表示没看过string源码,也不了解string咋实现的,类比vector说了一下. 又错了</p>\n<p>问数据库, 我说了解的不是很深入, 然后就没问. (其实以后应该说,试一试,,)</p>\n<p>然后就问问题,唠家常了,,,,</p>\n<p>最后再见,</p>\n<p>结果在一个小时之内,听到了两次同一个hr小姐姐的拒绝电话,,,,</p>\n<hr>\n<p>体验是真几把刺激,面挂了一面还面了第二面,hhhh,于是二面的时候就很懵逼,,,</p>\n<p>但是确实啥都不会呀….</p>\n<p>总结就是多学习吧. </p>\n<p>但是有个大失误,问计网,操作系统,数据库的时候,应该说试一下的,,毕竟还是看了一些的呀,多少还是能答上来一点的,,</p>\n<h2 id=\"美团-后台开发-搞笑\"><a href=\"#美团-后台开发-搞笑\" class=\"headerlink\" title=\"美团 后台开发 (搞笑)\"></a>美团 后台开发 (搞笑)</h2><p>开始自我介绍,聊了聊最近看什么数,还有数据库啥的</p>\n<p>十分钟过后,跟我说只要Java, 不合适, 嗯 ,然后88</p>\n<hr>\n<p>傻逼美团,怎么筛选的简历,岗位要求上不是写的4中语言之一吗,,,,,而且不准备培养实习生的吗,,还听说之前实习生一个转正的都没有??!</p>\n<h2 id=\"吉比特-游戏开发-实习\"><a href=\"#吉比特-游戏开发-实习\" class=\"headerlink\" title=\"吉比特 游戏开发(实习)\"></a>吉比特 游戏开发(实习)</h2><h3 id=\"一面-1\"><a href=\"#一面-1\" class=\"headerlink\" title=\"一面\"></a>一面</h3><p>自我介绍<br>多线程<br>内联函数和宏函数<br>python闭包<br>socket编程<br>函数内的malloc 存在哪里<br>内联函数<br>右值引用<br>进程间通信<br>连续子序列最大和<br>vector<br>set 和 map的底层数据结构<br>hash冲突解决<br>内存泄漏解决<br>C++调用函数<br>虚析构函数<br>一个文本相同的行去除, 保留第一个 (内存存的下/存不下)<br>还有问题 记不起来了</p>\n<hr>\n<p>表现很差呀, 算法也没有问，代码都没让写，，，</p>\n<h2 id=\"腾讯-后台开发-实习\"><a href=\"#腾讯-后台开发-实习\" class=\"headerlink\" title=\"腾讯 后台开发(实习)\"></a>腾讯 后台开发(实习)</h2><h3 id=\"一面-2\"><a href=\"#一面-2\" class=\"headerlink\" title=\"一面\"></a>一面</h3><p>自我介绍,</p>\n<p>闲聊<br>介绍了ACM比赛<br>最近在干什么</p>\n<p>技术上的问了<br>网络编程接触过没 -&gt;没接触过<br>数据一致性怎么保证 -&gt; 不会<br>两个文件都是100W个整数,找出相同的 -&gt; 排序,然后归并的过程<br>进程间通信 并举例说出场景 -&gt; 管道不知道,剩下三个举例了,<br>说说STL -&gt; 说了下vector怎么保证可变长度而且复杂度还是O(1),map和set都是红黑树啥啥啥的<br>new/delete 和malloc/free的区别 -&gt; 说没怎么用过后者,一直用前者,因为后者长.面试官笑..然后说了几个new/delete使用的时候需要注意的问题.<br>谈到指针,问多线程删除map元素怎么办 -&gt; 先回答把多个线程要删除的记下来,然后统一删除, 他说可以, 但是希望我在指针的方式考虑, 想了想不会, 他让我回去看下map的源码关于元素删除的部分, 看过之后会有想法.<br>多线程有什么了解 -&gt; 说了下ABC循环打印的那个, 然后就没有了<br>高并发怎么处理, -&gt; 读的不加锁,写的加锁<br>接上个问我脏读怎么办 -&gt; 我说加个时间戳,他说不太好,然后不会了<br>对安全了解多少 -&gt; 把只会的凯撒加密和RSA加密说了说<br>对称加密和非对称加密 -&gt; 忘记了,说不太清了,告诉他不强答<br>C++的封装/继承/多态-&gt; 说了说多态和继承,封装我觉得没啥说的呀,,</p>\n<p>还有几个问题,忘了</p>\n<p>非技术问题<br>说给我安排一个任务,一周上线,这个任务我现在不会,怎么办 -&gt; 我觉得时间够用,没有问题,2天时间学习,3天时间实现, 具体实施的时候先请教别人,翻论文<br>如果我现在时间很紧的赶一个任务,有人请教我会的东西,我怎么做 -&gt; 甩给他相关的资料让他自己学习, 如果还不懂,粗浅的指点一下  还不懂,就对不起了,(这个很坑呀,步步紧逼)</p>\n<p>问问题<br>就问了怎么学习linux,<br>之前准备问的问题,都忘记问了</p>\n<hr>\n<p>面试官挺随和的, 开始挺紧张的 ,后来就不紧张了, 现场面试还是比电面/视频面舒服.<br>过程就像实在闲聊<br>还是什么都不会, 面试官让我把学习重心放在网络编程和安全这方面,说用到的多,学习的时候多看看源码.</p>\n<h3 id=\"二面-1\"><a href=\"#二面-1\" class=\"headerlink\" title=\"二面\"></a>二面</h3><p>问的和一面差不多,<br>多问了几个小问题而已</p>\n<p>数据库的东西问了很多, 但不会<br>然后和一面有重复的问题,但是昨天回去查了下,答得比较完整<br>Hash处理冲突,解决办法<br>内存泄露的时候如何定位 -&gt; 说调用系统的函数监控内存<br>内存分布 -&gt; 有一个忘记了,其他的说的没问题<br>进程调度算法 -&gt; 先到先服务 , 短作业优先, 多级反馈队列<br>接上个问现在系统的调度算法 -&gt; 在提示说同时能音乐,处理网页这些 想起来时间片轮转算法,说了些,<br>std::sort()怎么实现的 -&gt; 内省排序,<br>接上个std::sort()什么时候采用插入排序,归并排序,快排 -&gt; 举了什么时候插排会更快, 和归并是为了防止快排退化 balabala</p>\n<p>剩下的暂时想不起来了,</p>\n<hr>\n<p>面试官看起来挺年轻的, 数据库东西确实不太会, 而且又没让写代码, 以为凉凉了,,,<br>5点多接到明天hr面的消息,</p>\n<h2 id=\"旷视-Face-后台实习生\"><a href=\"#旷视-Face-后台实习生\" class=\"headerlink\" title=\"旷视 Face++   后台实习生\"></a>旷视 Face++   后台实习生</h2><h3 id=\"一面-3\"><a href=\"#一面-3\" class=\"headerlink\" title=\"一面\"></a>一面</h3><p>就两个问题<br>一个拓扑排序,拓扑序计数,<br>一个二分check的问题</p>\n<p>开始网站打不开,只写了第二个的代码</p>\n<p>然后就问我最近学什么, 以后的方向什么的 聊了好久</p>\n<p>问了几个问题就结束了</p>\n<hr>\n<p>感觉不错,面试官说重视的就是coding能力,其他的都可以在学,<br>等消息<br><del>智障,问面试官需要什么样的人才,说我这样的,一周后问面试官,说挂了</del></p>\n<h2 id=\"京东云-C-实习\"><a href=\"#京东云-C-实习\" class=\"headerlink\" title=\"京东云 C++(实习)\"></a>京东云 C++(实习)</h2><h3 id=\"一面-4\"><a href=\"#一面-4\" class=\"headerlink\" title=\"一面\"></a>一面</h3><p>刚面完腾讯的hr面回来到实验室扯了两句,就收到面试了</p>\n<p>给了个写代码的网页死活打不开,然后就改手写发照片了<br>写了一个矩阵,一层一层输出的代码</p>\n<p>然后说了C++的stl<br>vector的变长机制<br>平衡树</p>\n<p>tcp的三次握手,四次挥手,为什么三次,为什么四次<br>网络分层,说了下osi的七层<br>问tcp在那层,不知道,猜了个网络层,,,然后面试官问tcp的t是什么,想起是transfer,说出了传输层</p>\n<p>然后还有几个问题,忘了</p>\n<h2 id=\"日常问面试官问题结束\"><a href=\"#日常问面试官问题结束\" class=\"headerlink\" title=\"日常问面试官问题结束\"></a>日常问面试官问题结束</h2><p>面试官挺nice的</p>\n<h3 id=\"二面-2\"><a href=\"#二面-2\" class=\"headerlink\" title=\"二面\"></a>二面</h3><p>感觉效率很高 上午面完下午5点就来二面了,</p>\n<p>面向对象编程谈谈<br>C++ stl<br>内存分布<br>网络的那几个老生常谈的问题<br>进程间通信<br>数据库谈了谈</p>\n<p>一个linux 操作的问题,不会</p>\n<p>还有几个问题 忘了</p>\n<h3 id=\"hr面\"><a href=\"#hr面\" class=\"headerlink\" title=\"hr面\"></a>hr面</h3><p>因为一二面是周五 周一去考科四的时候来的电话</p>\n<p>瞎聊天 结束</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>总结下所有的面试, 这样才能<strong>慢慢</strong>进步呀,,,,</p>\n</blockquote>\n<h2 id=\"哈尔滨某小公司-C-岗实习-现场面-offer\"><a href=\"#哈尔滨某小公司-C-岗实习-现场面-offer\" class=\"headerlink\" title=\"哈尔滨某小公司 - C++岗实习 [现场面] - offer\"></a>哈尔滨某小公司 - C++岗实习 [现场面] - offer</h2><p>除了问一个多态,没有技术问题,大概是给答上了 意思对,但不专业</p>\n<hr>\n<p>小公司估计是真的没人了,,,,待遇实在…拒绝</p>\n<h2 id=\"头条-后台开发实习生-视频面试-一面-跪\"><a href=\"#头条-后台开发实习生-视频面试-一面-跪\" class=\"headerlink\" title=\"头条 - 后台开发实习生 [视频面试] 一面 - 跪\"></a>头条 - 后台开发实习生 [视频面试] 一面 - 跪</h2><p>可能是紧张吧,开始闲聊然后给了个编程题<br>给一个化学表达式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg: HMg_&#123;_2&#125;(H_2O(N_3Ag)_2)_3N_2</span><br></pre></td></tr></table></figure></p>\n<p>,让算每个元素有多少个.</p>\n<p>这种题本就不难 问题就是怎么处理括号<br>之前在hiho上还遇到过类似的问题<a href=\"http://www.hihocoder.com/contest/offers41/problem/2\" target=\"_blank\" rel=\"noopener\">http://www.hihocoder.com/contest/offers41/problem/2</a></p>\n<p>然后不知道紧张还是什么的就写的很乱,然后面试官提示递归,然后墨迹了好久才用stack写了下来…..</p>\n<p>因为我没有项目,就没有问项目.<br>然后问我们学了数据库,操作系统,网络没有,,,,   嗯 学校确实讲过,但我没听过课…</p>\n<p>问了个进程调度,</p>\n<p>我就知道有个算法叫FIFO, 具体是啥还忘了, 然后说错了,,GG</p>\n<p>然后唠了两句面试官说结束,等HR通知,,,  嗯.感谢面试官浪费40+分钟陪我 hhhh.</p>\n<hr>\n<p>总结:<br>有点紧张. 代码能力差 ,<strong>[数据库,操作系统,网络]</strong> 知识严重匮乏.</p>\n<p>之前看面经说,遇到不会的或者把不准的都应该说<strong>不会</strong>. 下次注意.</p>\n<h2 id=\"达内-NOIP助教-现场面\"><a href=\"#达内-NOIP助教-现场面\" class=\"headerlink\" title=\"达内 - NOIP助教 现场面\"></a>达内 - NOIP助教 现场面</h2><p>达内这个大家都懂.</p>\n<p>突然有天接到达内一个经理的电话,问我能不能去当助教,去教小朋友普及组的NOIP.<br>我心想,这也还不错呀.<br>然后去了,开始跟我吹了1个小时的牛逼,达内多么多么牛逼.怎么怎么地.<br>然后给了我一份NOIP普及组的题让我做..</p>\n<p>说来惭愧,中文题面,我竟读错一道题卡了好久,,,然后花了1个多小时终于把4个题做出来了,最后一题还做得很麻烦…<br>然后来了一个小伙子,谈了谈对NOIP的认识,以及我的学习情况.<br>交上去给了一个小姐姐,然后看见三个人对着电脑看了半天..</p>\n<p>然后说一定要一年,但我最多只能半年,于是据.</p>\n<hr>\n<p>体验美滋滋,没有麻烦的题目,没有操作系统,没有计算机网络,没有数据库.真棒 hhh</p>\n<h2 id=\"深信服-C-C-电话面试-一面-估计跪了\"><a href=\"#深信服-C-C-电话面试-一面-估计跪了\" class=\"headerlink\" title=\"深信服 - C/C++ 电话面试 一面-估计跪了\"></a>深信服 - C/C++ 电话面试 一面-估计跪了</h2><p>深圳打来的电话, 不知道哪里人, 浓重的方言口音, 他说话我都要问好多遍才能听懂…交流真滴有障碍…</p>\n<p>一共22分钟,三个问题</p>\n<p>1 . 两个字符串,一个大串,一个小串,问小串是不是大串的子串(不连续)的.</p>\n<p>我回答了: 遍历大串,然后对小串维护一个遍历的指针就行了</p>\n<p>然后他说不是他想要的,问的是正则?</p>\n<p>我记得有正则查询可以模糊匹配,只要在两个相邻的字母中插进去就好了,,但我忘记了具体插什么,</p>\n<p>结束后一查知道是 <code>.*</code> [. 匹配任意非\\n的字符 *是0个或多个]</p>\n<p>2 . 给一个100万的字符串,然后找到最短的循环覆盖的子串.</p>\n<p>我开始以为是ABCABC这样的 最短就是ABC了 ,拿next数组直接做就行了,</p>\n<p>然后说了半天,最后知道,他说的可以是这样ABCABCAB,还可以是ABC</p>\n<p>想了想发现和之前的一样, 还是求next数组,然后就可以把结尾的AB给去掉了,然后就和之前一样了.</p>\n<p>然后不知怎么就陷入了一阵交流障碍,我不知道他说的啥,他不知道我说的啥.</p>\n<p>然后我发现他是想让我说一下next怎么求…</p>\n<p>想了想,不能画图 怎么说呀, 问写代码行吗, 额 他也看不见….</p>\n<p>然后勉强解释了下 维护两个指针,一个i遍历大串,j是维护匹配到的位置,balabala的,</p>\n<p>也不知道他明白没有…</p>\n<hr>\n<p>然后他问我用linux还是windows多,</p>\n<p>我说用过linux,但还是windows多.</p>\n<p>然后问我一个问题,我听成了python.. 我说我会python…..但他好像问的根本不是这个问题,,,</p>\n<hr>\n<p>3 . 最后问我进程的内存分布</p>\n<p>我不会呀..</p>\n<p>说了一个堆栈..就说不知道了, </p>\n<p>于是结束…</p>\n<p>目测GG</p>\n<hr>\n<p>总结: 说好的12点,结果15点电话过来了,,,措手不及,以为没我事儿了呢,</p>\n<p>交流障碍导致前面两个问题说的不太好,而且电话面试真的不如视频面试呀,更别说现场面试了,,,后面确实不会, 操作系统,网络,数据库 多看看呀..</p>\n<h2 id=\"阿里云-分布式-大数据-基础平台研发工程师实习-电话面试-一面-跪了\"><a href=\"#阿里云-分布式-大数据-基础平台研发工程师实习-电话面试-一面-跪了\" class=\"headerlink\" title=\"阿里云, 分布式,大数据   - 基础平台研发工程师实习 电话面试 一面-跪了\"></a>阿里云, 分布式,大数据   - 基础平台研发工程师实习 电话面试 一面-跪了</h2><p>redis和MongoDB的区别。 谈一谈这两个数据库 。   (他以为我是自己搭建的数据库，，但我就是安装然后用的呀)<br>说一下大数据: hadoop - HDFS，hive 和 MapReduce ，问哪个是存储的，脑抽说了个hive，，， 后来改正了，然后问HDFS里面都有什么，答NameNode 和 DataNode，<br>问我还有什么，我不知道，他告诉我还有sdk。</p>\n<p>然后让我说竞赛中做过的经典，印象深刻的题目，想了好久，随便说了一个题，题目不怎么难，其实说的很模糊，而且说的时候还把那个题给弱化了，，记不太清那个题目了，</p>\n<p>然后问了我一个问题，现在都没想明白，说HDFS传3个副本，然后又客户在另一端访问这个。 然后是传完这<strong>三</strong>个副本告诉客户传完了有一个延迟时间，这<strong>两</strong>个副本告诉客户传完了有一个延迟时间，，<br>两个的会比三个的地低，<br>然后给初问题，给一个T，求N，M。 T是客户允许的最长延迟时间，N是副本总数，M是传完M个告诉客户传完了。<br>我只知道可以通过传好多次 算一个副本的时间t，但是不会算大T， 跟概率，期望，有关</p>\n<p>最后让写了一个编程题，很简单的n个区间 问覆盖的长度总和是多少。 谈了50多分种 脑子有点蒙，写了好几分钟。。 但他看了好长时间，难道是我写的错啦？？。。</p>\n<p>然后问了面试官几个问题，<br>大数据如何高效学习，论文，跟进<br>分布式如何学习，</p>\n<p>他们这个是做底层的，，，</p>\n<p>然后就是如果通过了 下次面试是什么时候，，，，但估计没有下次了，，，，，</p>\n<hr>\n<p>虽然啥都不会，什么都没有答上来。 体验非常好的一次面试，面试官人特别好，面对我这样的垃圾面试人员，应该很无奈，但依然很耐心的面试我，最后还提了好多问题。</p>\n<p>但是很奇怪，这次竟然一点操作系统和数据结构的问题都没有问， 之前看到牛客网一个基础平台研发，问了这些问题的呀。</p>\n<h2 id=\"瓜子二手车-后台研发实习生-现场一二面-给了offer邀请\"><a href=\"#瓜子二手车-后台研发实习生-现场一二面-给了offer邀请\" class=\"headerlink\" title=\"瓜子二手车 后台研发实习生 现场一二面, 给了offer邀请.\"></a>瓜子二手车 后台研发实习生 现场一二面, 给了offer邀请.</h2><ul>\n<li><p>1面<br>  自我介绍,没准备,随便说了下<br>  唠了两句家常.</p>\n<p>  绳子不均匀,燃烧的问题,一根绳子1个小时烧完.<br>  怎么找30分钟,75分钟.</p>\n<p>  说下栈和队列<br>  双栈怎么实现队列</p>\n<p>  计算机网络的几个零碎的小问题,没记住.</p>\n<p>  然后写了两个代码题</p>\n<ul>\n<li>交叉的链表,找交叉的位置,<br>链表的代码思路对,但是head节点没有val这点被我忘记了</li>\n<li><p>单链表找倒数第k个节点,</p>\n<p>数据库索引怎么实现的 -&gt; b+树<br>b+树为什么会快 -&gt; 搜索树,有剪枝<br>非**和**的区别 -&gt; 不知道,没听说过 (告诉我是 index 和 index+data的区别,名字想不起来了)<br>数据库事务的四个特性ACID -&gt; 我分不清那个是哪个了,就举个例子说了,<br>还有两个数据库的问题,想不起来了,</p>\n<p>问问题,问了技术栈和分布式的东西.</p>\n</li>\n</ul>\n</li>\n<li><p>2面<br>  领我进去的小哥哥说是总监面</p>\n<p>  自我介绍.唠家常.</p>\n<p>  两个集合求交,写代码 谢了归并排序+二分, 然后过了会说了个更简单的方法,</p>\n<p>  几个小问题,没记住</p>\n<p>  给我写了几个词,让我谈一谈</p>\n<ul>\n<li>set,stack,链表,数组,map,hash</li>\n<li><p>tcp,udp,http,https,ftp</p>\n<p>聊了聊最近在学习什么.说我基础薄弱..</p>\n<p>问问题. 问了职业规划.答:选择做技术就一直做技术.</p>\n</li>\n</ul>\n<hr>\n<p>可能因为是小公司吧,问的问题都比较简单.算法为了体现水平,学习了网上的套路,先给出一个不是很好的做法,然后再给一个优秀的做法.[斜眼笑]<br>走的时候小哥哥看了看评价表和我说不错,应该很稳,让我回去等消息就行啦.<br>面试官都很随和,出去的时候和一个工大研一的同来面试的小哥哥聊天才知道那个总监挺牛逼的.</p>\n</li>\n</ul>\n<h2 id=\"今日头条-后端研发实习生-12面-GG\"><a href=\"#今日头条-后端研发实习生-12面-GG\" class=\"headerlink\" title=\"今日头条 后端研发实习生  - 12面 [GG]\"></a>今日头条 后端研发实习生  - 12面 [GG]</h2><h3 id=\"一面\"><a href=\"#一面\" class=\"headerlink\" title=\"一面\"></a>一面</h3><p>一面直接给了一个问题,<br>S_0 = {1}<br>S_0 = {1,2,1}<br>…<br>S_n = S_{n-1},n+1,S_{n-1}</p>\n<p>问: 1. |S_n|  开始嘴飘,想当然的就说了,,后来说对了 2^{n+1}-1<br>            然后让我证明,,, 不会证,,,</p>\n<pre><code>2. 让实现一个函数int get_value(int n,int i) ,S_n的第i个元素,从0开始,,,,\n    然后我写了一个从1开始的,就被嘲讽了,,,然后一个变量打错,被指漏洞百出...\n    准备说的最优解还没有开始,就不理我了, (第i个数就是0~2^{n+1}-1的第i个数二进制小的最后一个一的长度,或者理解为lowbit(i)的二进制长度)\n</code></pre><p>然后有趣,hr给我打电话,委婉的告诉我挂了,,然后突然来了二面,,,,,</p>\n<h3 id=\"二面\"><a href=\"#二面\" class=\"headerlink\" title=\"二面\"></a>二面</h3><p>好吧,二面,啥都不会呀 …</p>\n<p>开始看了我一面写的代码,说风格太老了,,,现在C11已经不这么写了,,</p>\n<p>然后问我平时用的数据结构是stl的还是C11的,,讲道理我只知道STL的,不知道c11有什么数据结构,难道是传说中的那个能重写pushup,pushdown的内个??</p>\n<p>谈了谈我用到的那些数据结构,说我只用过基础的数据结构,,<br>然后让说了一下vector的实现,我就说了一下仅了解的它为什么能像数组那个用,,</p>\n<p>然后问一堆c11的问题,动态指针什么的,不会</p>\n<p>其中夹杂着问</p>\n<p>问会计组么,,tm不会呀,说你问吧,我试试<br>问了int是反码还是补码,隐隐约约记得是补码,磨磨唧唧说了,</p>\n<p>问socket编程, 不会, 没接触过.<br>问多线程编程, 我说接触过一点点, 只写过多线程循环打印的.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Test&#123;</span><br><span class=\"line\">    private int a;</span><br><span class=\"line\">    private int b;</span><br><span class=\"line\">    int test()&#123;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">struct Test2&#123;</span><br><span class=\"line\">    int a;</span><br><span class=\"line\">    char b;</span><br><span class=\"line\">    char c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">sizeof(Test)是多少. 我说12 ,(不知道对错,开始答8然后他沉默就改了, **其实就是8** )  </span><br><span class=\"line\">sizeof(Test2)是多少. 我说8 , 因为要内存对齐</span><br></pre></td></tr></table></figure>\n<p>让我写一个函数验证机器的大小端 表示不知道大小端是什么,<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    int a = 1;</span><br><span class=\"line\">    char s = *(char *)&amp;a;</span><br><span class=\"line\">    if(s == 1) puts(&quot;small&quot;);</span><br><span class=\"line\">    else       puts(&quot;big&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>class 和 struct的区别, 只知道class默认是private,struct默认是public, 问我还有什么 不知道</p>\n<p>问我sizeof(一个指针)是多少,不知道,叨咕了一个8,然后他告诉我32位机器是4,64位机器是8;</p>\n<p>给了一个代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void test(int *p)&#123;</span><br><span class=\"line\">    p = (int *)malloc(sizeof(int))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>问p改没改变</p>\n<p>蒙的改变, p指向了新开辟的那个地址.</p>\n<p>编程题,大数加法,不让用char a[],只让用string… 写的稍墨迹</p>\n<p>然后问string += 和 +的区别</p>\n<p>就是 a+=b 和a=a+b<br>表示没看过string源码,也不了解string咋实现的,类比vector说了一下. 又错了</p>\n<p>问数据库, 我说了解的不是很深入, 然后就没问. (其实以后应该说,试一试,,)</p>\n<p>然后就问问题,唠家常了,,,,</p>\n<p>最后再见,</p>\n<p>结果在一个小时之内,听到了两次同一个hr小姐姐的拒绝电话,,,,</p>\n<hr>\n<p>体验是真几把刺激,面挂了一面还面了第二面,hhhh,于是二面的时候就很懵逼,,,</p>\n<p>但是确实啥都不会呀….</p>\n<p>总结就是多学习吧. </p>\n<p>但是有个大失误,问计网,操作系统,数据库的时候,应该说试一下的,,毕竟还是看了一些的呀,多少还是能答上来一点的,,</p>\n<h2 id=\"美团-后台开发-搞笑\"><a href=\"#美团-后台开发-搞笑\" class=\"headerlink\" title=\"美团 后台开发 (搞笑)\"></a>美团 后台开发 (搞笑)</h2><p>开始自我介绍,聊了聊最近看什么数,还有数据库啥的</p>\n<p>十分钟过后,跟我说只要Java, 不合适, 嗯 ,然后88</p>\n<hr>\n<p>傻逼美团,怎么筛选的简历,岗位要求上不是写的4中语言之一吗,,,,,而且不准备培养实习生的吗,,还听说之前实习生一个转正的都没有??!</p>\n<h2 id=\"吉比特-游戏开发-实习\"><a href=\"#吉比特-游戏开发-实习\" class=\"headerlink\" title=\"吉比特 游戏开发(实习)\"></a>吉比特 游戏开发(实习)</h2><h3 id=\"一面-1\"><a href=\"#一面-1\" class=\"headerlink\" title=\"一面\"></a>一面</h3><p>自我介绍<br>多线程<br>内联函数和宏函数<br>python闭包<br>socket编程<br>函数内的malloc 存在哪里<br>内联函数<br>右值引用<br>进程间通信<br>连续子序列最大和<br>vector<br>set 和 map的底层数据结构<br>hash冲突解决<br>内存泄漏解决<br>C++调用函数<br>虚析构函数<br>一个文本相同的行去除, 保留第一个 (内存存的下/存不下)<br>还有问题 记不起来了</p>\n<hr>\n<p>表现很差呀, 算法也没有问，代码都没让写，，，</p>\n<h2 id=\"腾讯-后台开发-实习\"><a href=\"#腾讯-后台开发-实习\" class=\"headerlink\" title=\"腾讯 后台开发(实习)\"></a>腾讯 后台开发(实习)</h2><h3 id=\"一面-2\"><a href=\"#一面-2\" class=\"headerlink\" title=\"一面\"></a>一面</h3><p>自我介绍,</p>\n<p>闲聊<br>介绍了ACM比赛<br>最近在干什么</p>\n<p>技术上的问了<br>网络编程接触过没 -&gt;没接触过<br>数据一致性怎么保证 -&gt; 不会<br>两个文件都是100W个整数,找出相同的 -&gt; 排序,然后归并的过程<br>进程间通信 并举例说出场景 -&gt; 管道不知道,剩下三个举例了,<br>说说STL -&gt; 说了下vector怎么保证可变长度而且复杂度还是O(1),map和set都是红黑树啥啥啥的<br>new/delete 和malloc/free的区别 -&gt; 说没怎么用过后者,一直用前者,因为后者长.面试官笑..然后说了几个new/delete使用的时候需要注意的问题.<br>谈到指针,问多线程删除map元素怎么办 -&gt; 先回答把多个线程要删除的记下来,然后统一删除, 他说可以, 但是希望我在指针的方式考虑, 想了想不会, 他让我回去看下map的源码关于元素删除的部分, 看过之后会有想法.<br>多线程有什么了解 -&gt; 说了下ABC循环打印的那个, 然后就没有了<br>高并发怎么处理, -&gt; 读的不加锁,写的加锁<br>接上个问我脏读怎么办 -&gt; 我说加个时间戳,他说不太好,然后不会了<br>对安全了解多少 -&gt; 把只会的凯撒加密和RSA加密说了说<br>对称加密和非对称加密 -&gt; 忘记了,说不太清了,告诉他不强答<br>C++的封装/继承/多态-&gt; 说了说多态和继承,封装我觉得没啥说的呀,,</p>\n<p>还有几个问题,忘了</p>\n<p>非技术问题<br>说给我安排一个任务,一周上线,这个任务我现在不会,怎么办 -&gt; 我觉得时间够用,没有问题,2天时间学习,3天时间实现, 具体实施的时候先请教别人,翻论文<br>如果我现在时间很紧的赶一个任务,有人请教我会的东西,我怎么做 -&gt; 甩给他相关的资料让他自己学习, 如果还不懂,粗浅的指点一下  还不懂,就对不起了,(这个很坑呀,步步紧逼)</p>\n<p>问问题<br>就问了怎么学习linux,<br>之前准备问的问题,都忘记问了</p>\n<hr>\n<p>面试官挺随和的, 开始挺紧张的 ,后来就不紧张了, 现场面试还是比电面/视频面舒服.<br>过程就像实在闲聊<br>还是什么都不会, 面试官让我把学习重心放在网络编程和安全这方面,说用到的多,学习的时候多看看源码.</p>\n<h3 id=\"二面-1\"><a href=\"#二面-1\" class=\"headerlink\" title=\"二面\"></a>二面</h3><p>问的和一面差不多,<br>多问了几个小问题而已</p>\n<p>数据库的东西问了很多, 但不会<br>然后和一面有重复的问题,但是昨天回去查了下,答得比较完整<br>Hash处理冲突,解决办法<br>内存泄露的时候如何定位 -&gt; 说调用系统的函数监控内存<br>内存分布 -&gt; 有一个忘记了,其他的说的没问题<br>进程调度算法 -&gt; 先到先服务 , 短作业优先, 多级反馈队列<br>接上个问现在系统的调度算法 -&gt; 在提示说同时能音乐,处理网页这些 想起来时间片轮转算法,说了些,<br>std::sort()怎么实现的 -&gt; 内省排序,<br>接上个std::sort()什么时候采用插入排序,归并排序,快排 -&gt; 举了什么时候插排会更快, 和归并是为了防止快排退化 balabala</p>\n<p>剩下的暂时想不起来了,</p>\n<hr>\n<p>面试官看起来挺年轻的, 数据库东西确实不太会, 而且又没让写代码, 以为凉凉了,,,<br>5点多接到明天hr面的消息,</p>\n<h2 id=\"旷视-Face-后台实习生\"><a href=\"#旷视-Face-后台实习生\" class=\"headerlink\" title=\"旷视 Face++   后台实习生\"></a>旷视 Face++   后台实习生</h2><h3 id=\"一面-3\"><a href=\"#一面-3\" class=\"headerlink\" title=\"一面\"></a>一面</h3><p>就两个问题<br>一个拓扑排序,拓扑序计数,<br>一个二分check的问题</p>\n<p>开始网站打不开,只写了第二个的代码</p>\n<p>然后就问我最近学什么, 以后的方向什么的 聊了好久</p>\n<p>问了几个问题就结束了</p>\n<hr>\n<p>感觉不错,面试官说重视的就是coding能力,其他的都可以在学,<br>等消息<br><del>智障,问面试官需要什么样的人才,说我这样的,一周后问面试官,说挂了</del></p>\n<h2 id=\"京东云-C-实习\"><a href=\"#京东云-C-实习\" class=\"headerlink\" title=\"京东云 C++(实习)\"></a>京东云 C++(实习)</h2><h3 id=\"一面-4\"><a href=\"#一面-4\" class=\"headerlink\" title=\"一面\"></a>一面</h3><p>刚面完腾讯的hr面回来到实验室扯了两句,就收到面试了</p>\n<p>给了个写代码的网页死活打不开,然后就改手写发照片了<br>写了一个矩阵,一层一层输出的代码</p>\n<p>然后说了C++的stl<br>vector的变长机制<br>平衡树</p>\n<p>tcp的三次握手,四次挥手,为什么三次,为什么四次<br>网络分层,说了下osi的七层<br>问tcp在那层,不知道,猜了个网络层,,,然后面试官问tcp的t是什么,想起是transfer,说出了传输层</p>\n<p>然后还有几个问题,忘了</p>\n<h2 id=\"日常问面试官问题结束\"><a href=\"#日常问面试官问题结束\" class=\"headerlink\" title=\"日常问面试官问题结束\"></a>日常问面试官问题结束</h2><p>面试官挺nice的</p>\n<h3 id=\"二面-2\"><a href=\"#二面-2\" class=\"headerlink\" title=\"二面\"></a>二面</h3><p>感觉效率很高 上午面完下午5点就来二面了,</p>\n<p>面向对象编程谈谈<br>C++ stl<br>内存分布<br>网络的那几个老生常谈的问题<br>进程间通信<br>数据库谈了谈</p>\n<p>一个linux 操作的问题,不会</p>\n<p>还有几个问题 忘了</p>\n<h3 id=\"hr面\"><a href=\"#hr面\" class=\"headerlink\" title=\"hr面\"></a>hr面</h3><p>因为一二面是周五 周一去考科四的时候来的电话</p>\n<p>瞎聊天 结束</p>\n"},{"title":"面试学习.","date":"2018-01-29T04:44:08.000Z","description":null,"toc":true,"_content":"\n> 记录下我针对面试的学习\n\n## 算法/编程题\n\n### a\n\n####  [√][荷兰国旗问题](http://acm.nyist.edu.cn/JudgeOnline/problem.php?pid=268)\n\n 噗 , 被高大上的名字给吓到了,其实就是简单的C语言入门题.\n\n####  实现一个LRU算法\n####  [√]双栈实现一个队列\n[实现代码](https://github.com/tabris233/slove-problems/blob/master/2018-1/29/QUEUE-two%20stack.cpp)\n\n####  [√]编程题\n问题: 两个数组 A 表示一串螺丝 B 表示一串螺帽 螺丝和螺帽能够配对，但是A中螺丝之间不能比较大小，B中螺帽之间也不能比较大小，螺丝和螺帽可以比较大小，返回所有螺丝和螺帽的对应关系，要求复杂度小于O(n^2)\n\n解: 类似快速排序,一个和另一个比较就可以了.\n[code](https://github.com/tabris233/slove-problems/blob/master/2018-1/30/%E8%9E%BA%E4%B8%9D%E5%92%8C%E8%9E%BA%E5%B8%BD.cpp)\n####  今日头条笔试真题\nhttps://www.nowcoder.com/test/8537140/summary\n\n## 基础知识\n\n### 算法与数据结构\n\n\n\n### 操作系统\n\n#### 一个进程\n一个进程是**PCB结构与程序与数据的组合**\n\n#### [-]产生死锁的必要条件\n- 互斥条件: 即某个资源在一段时间内只能由一个进程占有,不能同事被两个或两个以上的进程占有.这种独占资源如CD-ROM驱动器,打印机等等,必须在占有该资源的进程主动释放它之后,其他进程才能占有该资源.这是有资源本身的属性所决定的.如独木桥就是一种独占资源,两方的人不能同时过桥.\n\n- 不可抢占条件: 进程所获得的资源在未使用完毕之前,资源申请者不能强行地从资源占有者中夺取资源.而只能由该资源的占有者进程自行释放.如过独木桥的人自己不能强迫对方后退,也不能非法地将对方退下桥,必须是桥上的人自己过桥后空出桥面(即主动释放占有资源),对方的人才能过桥.\n\n- 占有且申请条件: 进程至少已经占有一个资源,但又申请新的资源; 由于该资源已经被另外进程占有,此时该进程阻塞; 但是,它在等待新资源之时,扔继续占用已占有的资源.还以过独木桥为例,甲乙两人在桥上相遇. 甲走过一段桥面(即占有了一些资源),还需要走其余的桥面(申请新的资源),但那部分桥面被已占有(已走过一段桥面).甲过不去,前进不能,又不后退;乙也处于同样的状况.\n\n- 循环等待条件: 存在一个进程等待序列{P1,P2, ... ,Pn}, 其中P1等待P2所占有的某一资源, P2等待P3所占有的某一源, ...... ,而Pn等待P1所占有的某一资源形成一个进程循环等待环.就像前面的过独木桥问题,甲等待乙占有的桥面,而乙有等待甲占有的桥面, 从而彼此循环等待.\n\n#### [-]死锁预防\n- 打破互斥条件: 即允许进程同事访问某些资源.但是,有的资源不允许被同时访问的,像打印机等等.这是由资源本身的属性所决定的. 所以,这种办法并无实用价值\n\n- 打破不可抢占条件: 即允许进程强行从占有者哪里夺取某些资源. 就是说, 当一个进程已占有了某些资源,他又申请新的资源,但不能立即被满足,它必须释放所占有的全部资源, 以后再重新申请. 他所释放的资源可以分配给其他进程.这就相当于该进程占有的资源被隐蔽性地强占了. 这种预防死锁的方法实现起来困难,会降低系统性能.\n\n- 打破占有且申请条件: 可以实行资源预先分配策略. 即进程在运行前一次地向系统申请它所需要的全部资源. 如果某个进程所需的全部资源得不到满足,则不分配任何资源,此进程在不运行.只有当系统能够满足当前进程的全部资源需求时,才一次性地将所申请的资源全部分配给该进程. 由于运行的进程已占有它所需要的全部资源所以不会发生占有资源有申请资源的现象, 因此不会发生死锁. 但是,这种策略也有如下缺点:\n    - 在许多情况下,一个进程在执行之前不可能知道它所需要的全部资源. 这是由于进程在执行时是动态的,不可预测的.\n    - 资源利用率低.无论所分资源何时用到,一个进程只有在占有所需要的全部资源后才能执行.即使有些资源最后才被该进程用到一次,但该进程生存期间一直占有他们,造成长期占着不用的状况.这显然是一种极大的资源浪费.\n    - 降低了进程的并发性.因为资源有限,又加上存在浪费,能分配到所需全部资源的进程个数就必然少了.\n- 打破循环等待条件:**实行资源有序分配策略**.采用这种策略,即把资源事先分类编号,按号分配,使进程在申请,占用资源是不会形成环路.所有进程对资源的请求必须严格按字元序号递增的顺序提出.进程占用了小号资源,才能申请大耗资源,就不会产生环路, 从而预防了死锁.这种策略与前面的策略相比, 资源的利用率和系统的吞吐量都有了很大的提高,但是也存在一下缺点:\n    - 限制了进程对资源的请求,同事给系统中所有资源合理编号也是件困难时,并增加了系统的开销.\n    - 为了遵循按编号申请的次序,在不使用的资源也需要提前申请,从而增加了进程对资源的占用时间.\n\n#### 死锁避免\n- 银行家算法\n系统给当前进程分配资源时,先检查是否安全.\n在满足当前的进程X资源申请后,是否还能有足够的资源去满足下一个距最大资源需求最近的进程(如某进程最大需要5个单位资源,已拥有1个,还需4个),若可以满足,则继续检查下一个距最大资源需求最近的进程,若均能满足所有进程,则表示为安全,可以允许给当前进程X分配其所需的资源申请,否则让该进程X进入等待.\n- 哲学家进餐问题\n\n#### [-]进程和线程的区别\n\n>定义\n>**进程**是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.\n>**线程**是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.\n>关系\n>一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.\n>相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。\n>区别\n>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。\n>>简而言之,一个程序至少有一个进程,一个进程至少有一个线程.\n>线程的划分尺度小于进程，使得多线程程序的并发性高。\n>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。\n>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。\n>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。\n>优缺点\n>线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。\n\n#### []进程间通信\n\n####### 为什么需要进程间通信？？\n\n进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程）之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源（例如打开的文件描述符）。\n\n\n\n但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程间通信( IPC：Inter Processes Communication )。\n\n进程间通信的目的：\n\n- 数据传输：一个进程需要将它的数据发送给另一个进程。\n- 通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。\n- 资源共享：多个进程之间共享同样的资源。为了做到这一点，需要内核提供互斥和同步机制。\n- 进程控制：有些进程希望完全控制另一个进程的执行（如 Debug 进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。\nLinux 操作系统支持的主要进程间通信的通信机制：\n\n![进程间通信-1](../images/StudyOfInterview/jcjtx.jpg '进程间通信')\n\n###### [进程间通信(IPC)介绍](https://www.cnblogs.com/CheeseZH/p/5264465.html)\n\n#### []进程调度\n\n#### []进程的内存分布\n\n|||\n|-|-|\n|代码段|全局常量（const）、字符串常量、函数以及编译时可决定的某些东西|\n|数据段|存储初始化的全局变量 和 初始化的静态变量(全局和局部)|\n|BSS段|存储未初始化的全局变量 和 未初始化的静态变量(全局和局部)|\n|堆|动态分配的区域（malloc、new等）|\n|栈|l临时声明的局部变量(初始化以及未初始化的,但不包含静态变量),局部常量(const)|\n|命令行参数和环境变量|顾名思义|\n\n![](https://images2015.cnblogs.com/blog/978007/201702/978007-20170208113706760-1208301174.png)\n\n\n#### 进程调度\n\n- 先来先服务 （FCFS，first come first served） \n在所有调度算法中，最简单的是非抢占式的FCFS算法。 \n算法原理：进程按照它们请求CPU的顺序使用CPU.就像你买东西去排队，谁第一个排，谁就先被执行，在它执行的过程中，不会中断它。当其他人也想进入内存被执行，就要排队等着，如果在执行过程中出现一些事，他现在不想排队了，下一个排队的就补上。此时如果他又想排队了，只能站到队尾去。 \n算法优点：易于理解且实现简单，只需要一个队列(FIFO)，且相当公平 \n算法缺点：比较有利于长进程，而不利于短进程，有利于CPU 繁忙的进程，而不利于I/O 繁忙的进程\n\n- 最短作业优先（SJF, Shortest Job First） \n短作业优先（SJF, Shortest Job First）又称为“短进程优先”SPN(Shortest Process Next)；这是对FCFS算法的改进，其目标是减少平均周转时间。 \n算法原理：对预计执行时间短的进程优先分派处理机。通常后来的短进程不抢先正在执行的进程。 \n算法优点：相比FCFS 算法，该算法可改善平均周转时间和平均带权周转时间，缩短进程的等待时间，提高系统的吞吐量。 \n算法缺点：对长进程非常不利，可能长时间得不到执行，且未能依据进程的紧迫程度来划分执行的优先级，以及难以准确估计进程的执行时间，从而影响调度性能。\n\n- 最高响应比优先法(HRRN，Highest Response Ratio Next) \n最高响应比优先法(HRRN，Highest Response Ratio Next)是对FCFS方式和SJF方式的一种综合平衡。FCFS方式只考虑每个作业的等待时间而未考虑执行时间的长短，而SJF方式只考虑执行时间而未考虑等待时间的长短。因此，这两种调度算法在某些极端情况下会带来某些不便。HRN调度策略同时考虑每个作业的等待时间长短和估计需要的执行时间长短，从中选出响应比最高的作业投入执行。这样，即使是长作业，随着它等待时间的增加，W / T也就随着增加，也就有机会获得调度执行。这种算法是介于FCFS和SJF之间的一种折中算法。 \n算法原理：响应比R定义如下： R =(W+T)/T = 1+W/T \n其中T为该作业估计需要的执行时间，W为作业在后备状态队列中的等待时间。每当要进行作业调度时，系统计算每个作业的响应比，选择其中R最大者投入执行。 \n算法优点：由于长作业也有机会投入运行，在同一时间内处理的作业数显然要少于SJF法，从而采用HRRN方式时其吞吐量将小于采用SJF 法时的吞吐量。 \n算法缺点：由于每次调度前要计算响应比，系统开销也要相应增加。\n\n- 时间片轮转算法（RR，Round-Robin） \n 该算法采用剥夺策略。时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称RR调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。 \n算法原理：让就绪进程以FCFS 的方式按时间片轮流使用CPU 的调度方式，即将系统中所有的就绪进程按照FCFS 原则，排成一个队列，每次调度时将CPU 分派给队首进程，让其执行一个时间片，时间片的长度从几个ms 到几百ms。在一个时间片结束时，发生时钟中断，调度程序据此暂停当前进程的执行，将其送到就绪队列的末尾，并通过上下文切换执行当前的队首进程，进程可以未使用完一个时间片，就出让CPU（如阻塞）。 \n 算法优点：时间片轮转调度算法的特点是简单易行、平均响应时间短。 \n算法缺点：不利于处理紧急作业。在时间片轮转算法中，时间片的大小对系统性能的影响很大，因此时间片的大小应选择恰当 \n 怎样确定时间片的大小：\n  - 时间片大小的确定 \n    1.系统对响应时间的要求 \n    2.就绪队列中进程的数目 \n    3.系统的处理力\n\n- 多级反馈队列(Multilevel Feedback Queue) \n多级反馈队列调度算法是一种CPU处理机调度算法，UNIX操作系统采取的便是这种调度算法。 \n多级反馈队列调度算法描述： \n　　1、进程在进入待调度的队列等待时，首先进入优先级最高的Q1等待。 \n　　2、首先调度优先级高的队列中的进程。若高优先级中队列中已没有调度的进程，则调度次优先级队列中的进程。例如：Q1,Q2,Q3三个队列，只有在Q1中没有进程等待时才去调度Q2，同理，只有Q1,Q2都为空时才会去调度Q3。 \n　　3、对于同一个队列中的各个进程，按照时间片轮转法调度。比如Q1队列的时间片为N，那么Q1中的作业在经历了N个时间片后若还没有完成，则进入Q2队列等待，若Q2的时间片用完后作业还不能完成，一直进入下一级队列，直至完成。 \n　　4、在低优先级的队列中的进程在运行时，又有新到达的作业，那么在运行完这个时间片后，CPU马上分配给新到达的作业（抢占式）。 \n　　在多级反馈队列调度算法中，如果规定第一个队列的时间片略大于多数人机交互所需之处理时间时，便能够较好的满足各种类型用户的需要。\n\n### 计算机网络\n\n#### []TCP和UDP区别\n||TCP|UDP|\n|-|-|---|\n|传输|提供面向连接的、可靠地数据流传输|提供的是非面向连接的、不可靠的数据流传输|\n|传输单位|TCP报文段|用户数据报|\n|安全性|TCP注重数据安全性|UDP数据传输快，因为不需要链接等待，少了许多操作，但是起安全性却一般|\n||||\n|协议|FTP:定义了文件传输协议,使用21端口;|DNS: 用于域名解析服务,将域名地址转换成IP地址.DNS用的是53号端口.|\n|协议|Telnet: 一种用于远程登录的端口,使用23端口,用户可以以自己的身份远程连接到计算机上,可提供基于DOS模式下的通信服务|SNMP: 简单网络管理协议,使用161端口,是用来管理网络十倍的.由于网络设备很多,无连接的服务就体现出其优势.|\n|协议|SMTP: 邮件传送协议,用于发送邮件.服务端开放的是25号端口|TFTP(Trival File Transfer Protocal): 简单文件传输协议,该协议在熟知端口69上使用UDP服务|\n|协议|POP3: 它是和SMTP对应,POP3用于接收邮件.POP3协议所用的是110端口||\n|协议|HTTP: 是从Web服务器传输超文本到本地浏览器的传送协议||\n\n[详细介绍,戳<<<--](http://blog.csdn.net/li_ning_/article/details/52117463)\n\n>TCP与UDP区别总结：\n>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接\n>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保   证可靠交付\n>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）\n>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信\n>TCP首部开销20字节;UDP的首部开销小，只有8个字节\n>TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道\n\n#### [-]TCP三次握手/四次挥手\n\n[详细介绍,戳<<<---](http://blog.csdn.net/qzcsu/article/details/72861891)\n[更亲民的介绍,戳<<<---](https://www.cnblogs.com/myvin/p/4862167.html)\n\n建立连接的过程是利用客户服务器模式,假设主机A为客户端,主机B为服务端\n- TCP的三次握手过程：主机Ａ向Ｂ发送链接请求; -> 主机B对收到的主机A的报文段进行确认; -> 主机A再次对主机B的确认进行确认\n- 采用三次握手是为了防止失效的链接请求报文段突然有传送到主机B,因而产生错误.失效的链接请求报文段是指: 主机A出的连接请求没有收到主机B的确认,于是经过一段时间后,主机A又重新向主机B发送连接请求,且建立成功,顺序完成数据传输. 考虑这样一个特殊情况,主机A第一次发送的连接请求并没有丢失,而是因为网络节点导致延迟到达主机B,主机B以为是主机又发起的新连接,于是主机B同意连接,并向主机A发回确认,但是此时主机A根本不会理会,主机B就一直在等待主机A发送数据，导致主机Ｂ的资源浪费．\n- 采用两次握手不行, 原因就是上面说的实效的连接请求的特殊情况.\n\n#### TCP里的一些机制\n\n#### OSI,TCP/IP,五层协议的体系结构,以及各层协议\n\nOSI分层(7层): 物理层,数据链路层,网络层,传输层,会话层,表示层,应用层.\nTCP/IP分层(4层): 网络接口层,网际层,运输层,应用层.\n五层协议(5层): 物理层,数据链路层,网络层,运输层,应用层.\n\n每一层的协议如下:\n物理层: RJ45,CLOCK,IEEE802.3(中继器,集线器)\n数据链路: POP,FR,HDLC,VLAN,MAX(网桥,交换机)\n网络层: IP,UCMP,ARP,RARP,OSPF,IPX,RIP,IGRP(路由器)\n传输层: TCP,UDP,SPX\n会话层: NFS,SQL,NETBIOS,RPC\n表示层: JPEG,MPEG,ASII\n应用层: FTP,DNS,Telnet,SMTP,HTTP,WWW,NFS\n\n每一层的作用如下\n\n物理层: 通过媒介传输比特,确定机械及电器规范(比特Bit)\n数据链路: 将比特组装成帧和点到点的传递(帧Frame)\n网络层: 负责数据包从源到宿的传递和网际互联(包PackeT)\n传输层: 提供端到端的可靠报文传递和错误回复(段Segment)\n会话层: 简历,管理和中智慧化(会话协议数据单元SPDU)\n表示层: 对数据进行翻译,加密和压缩(表示协议数据单元PPDU)\n应用层: 允许方位OSI环境的手段(应用协议数据单元APDU)\n\n#### IP地址的分类\nA类地址: 以0开头, 第一个字节范围1~127(1.0.0.0~127.255.255.255);\nB类地址: 以10开头, 第一个字节范围128~191(128.0.0.0~191.255.255.255);\nC类地址: 以110开头, 第一个字节范围192~223(192.0.0.0~223.255.255.255);\nD类地址: 以1110开头, 第一个字节范围224~239(224.0.0.0~239.255.255.255);\nE类地址: 保留\n\n一种A,B,C是基本类,D,E类作为多播和保留使用.\n以下是留用的内部私有地址:\nA类 10.0.0.0  -- 10.255.255.255\nB类 182.16.00 -- 192.31.255.255\nC类 192.168.0.0 -- 192.168.255.255\n\nIP地址与子网掩码相与(&)得到网络号\nip 192.168.2.110\n&\nsubmask:255.255.255.0\n.---------------------------------\n网络号 192.168.2.0\n\n注: 主机号,全是0的网络号(例如192.168.2.0),主机号全为1的为广播地址(192.168.2.255)\n\n#### ARP是地址解析协议,简单语言解释一下工作原理.\n\n- 首先,每个主机都会在自己的ARP缓冲区中建立一个ARP列表,以表示IP地址和MAC地址之间的对应关系.\n- 当源主机要发送数据时,首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址,如果有,则直接发送数据,如果没有,就向本网段的所有主机发送ARP数据包,该数据包包括的内容有: 源主机的IP地址,源主机的MAC地址,目的主机的IP地址.\n- 当本网络中的所有主机收到该ARP数据包时,首先检查数据包中的IP地址是否是自己的IP地址,如果不是,则忽略该数据包,,如果是,则首先从数据包中去除源主机的IP和MAC地址写入到ARP列表中,如果已经存在,则覆盖,然后将自己的MAC地址写入ARP响应包中,告诉源主机自己是它想要找的MAC地址\n- 源主机收到ARP响应后.将目的主机的IP和MAC地址写入ARP列表,并利用此信息发送数据. 如果源主机一直没有收到ARP相应数据包,表示ARP查询失败.\n\n广播发送ARP请求,单播发送ARP相应. \n\n#### RARP协议\nRARP是逆地址解析协议,作用是完成硬件地址到IP地址的映射,主要用于无盘工作站,因为给无盘工作站配置的IP地址不能保存. \n工作流畅: 在网络中配置一台RARP服务器,里面保存者IP地址和MAC地址的映射关系,当无盘工作站启动后,就封装一个RARP数据包,里面有其MAC地址,然后广播到网络上去,当服务器收到请求包后,就查找对应的MAC地址的IP地址装入响应报文中发回给请求者. 因为需要广播请求报文,因此RARP只能用于具有广播能力的网络.\n\n#### 各种协议的介绍\n\n- **ICMP协议**: 因特网控制报文协议.它是TCP/IP协议族的一个自协议,用于在IP主机/路由器之间传递控制消息.\n- **TFTP协议**: 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议,提供不复杂,开销不大的文件传输服务.\n- **HTTP协议**: 超文本传输协议,是一个属于应用层的面向对象的协议,由于其简捷,快速的方式,适用于分布式超媒体信息系统\n- **NAT协议**: 网络地址转换属介入广域网(WAN)技术,是一种将私有(保留)地址转化为合法IP地址的转换技术.\n- **DHCP协议**: 动态主机配置协议,给用户或者内部网络管理员作为对所有计算机作中央管理的手段.\n\n#### 在浏览器中输入www.baidu.com后执行的全部过程\n\n- 1. 客户端浏览器通过DNS解析到www.baidu.com的IP地址为220.181.27.48, 通过这个IP地址找到客户端到服务器的路径. 客户端浏览器发起一个HTTP回话到220.181.27.48, 然后通过TCP进行封装数据包, 输入到网络层.\n- 2. 在客户端的传输层,把HTTP回话请求分成报文段,添加源和目的端口, 如服务器使用80端口监听客户端的请求, 客户端有系统随机选择一个端口如5000, 与服务器进行交换,服务器吧相应的请求返回给客户端的5000端口. 然后使用IP层的IP地址查找目的端.\n- 3. 客户端的网络层不用关心应用层或者传输层的东西, 主要做到的是通过查找路由表确定如何到达服务器,期间可能经过多个路由器,这些都是有路由器来完成的工作, 我不做过多的描述, 无非就是通过查找路由表决定通过哪个路径到达服务器.\n- 4. 客户端的链路层, 包通过链路层发送到路由器, 通过邻居协议查找给定IP地址的MAC地址,然后发送ARP请求查找到目的地址, 如果得到回应后就可以使用ARP的请求应答交换的IP数据包,现在就可以传输了,然后发送IP数据包到达服务器的地址.\n\n#### DNS域名系统,简单描述其工作原理\n\n当DNS客户机需要在程序中使用名称时, 它会查询DNS服务器来解析该名称. 客户机发送的每条查询信息包括三条信息: 包括: 指定的DNS域名,DNS域名的指定类型. 基于UDP服务,端口53. 该应用一般不直接为用户使用, 而是为其他应用服务,如 HTTP,SMTO等在其中需要完成主机名到地址的转换.\n\n#### 了解交换机,路由器,网关的概念, 并知道各自的用途\n\n- **交换机**\n在计算机网络系统中,交换机是针对共享工作模式的弱点而推出的.交换机拥有一条高带宽的背部总线和内部交换矩阵.交换机的所有的端口都挂接在这条背部总线上,当控制电路收到数据包以后,处理端口会查找内存中的地址对照表以确定目的端口.目的MAC若不存在,交换机才广播到所有的端口, 接手端口回应后交换机会'学习'新的地址,并把它添加入内部地址表中.\n交换机工作于OSI参考模型的第二层,即数据链路层. 交换机内部的CPU会在每个端口成功连接时,通过ARP协议学习它的MAC地址,保存成一张ARP表. 在今后的通讯中, 发往该MAC地址的数据包将仅送往其对应的端口,而不是所有端口. 因此,交换机可用于划分数据链路层广播,即冲突域; 但它不能划分网络层广播, 即广播域.\n交换机被广泛应用于二层网络交换,俗称'二层交换机'.\n交换机的种类有: 二层交换机,三层交换机,四层交换机,七层交换机分别工作在OSI七层模型中的第二层,第三层,第四层和第七层,并因此而得名.\n\n- 路由器\n路由器(Router)是一种计算机网络设备,提供了路由与传送两种重要机制,可以决定数据包从来源端到目的端所经过的路由路径(host到host之间的传输路径),这个过程称为**路由**; 将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行),这成为**传动**. 路由工作在OSI模型的第三层 -> 即网络层,例如网际协议.\n路由器的一个作用是连通不同的网络另一个作用是选择信息传送的线路. 路由器与交换机的差别, 路由器是属于OSI第三层的产品,交换机是OSI第二层的产品(这里至二层交换机)\n\n- 网关\n网关(Gateway), 网关顾名思义就是连接两个网络的设备,区别与路由器(由于历史的原因,许多有关TCP/IP的文献曾经把网络层使用的路由器成为网关,在今天很多局域网采用的都是路由器来接入网络,因此现在通常指的网关就是路由器的IP),经常在家庭中或者小型企业网络中使用,用于连接局域网和Internet. 网关也经常把一种协议转成另一种协议的设备,比如语音网关.\n在传统TCP/IP术语中,网络设备只分成两种,一种为网关(Gateway),另一种称为主机(host). 网关能在网络间传递数据包,但主机不能传送数据包.在主机(又称终端系统,end system)中,数据包需经过TCP/IP四层协议处理,但是在网关(又称中介系统,intermediate system)只需要到达网际层(Internet layer),决定路径之后就可以传送. 在当时,网关(Gateway)和路由(Router)还没有区别.\n在现代网络术语中,网关(Gateway)和路由(Router)的定义不同,网关(Gateway)能在不同协议间移动数据,而路由器(Router)是在不同网络间移动数据,相当于传统所说的IP网关(IP Gateway).\n网关是连接两个网络的设备,对于语音网关来说,它可以连接PSTN网络和以太网,这就相当于VOIP,把不同电话的模拟信号通过网关而转换成数字信号,而且加入协议再去传输. 在到了接收端的时候再通过网关还原成模拟的电话信号,最后才能在电话机上听到.\n对于以太网中的网关只能转发三层以上数据包,这一点和路由是一样的.而不同的是网关中并没有路由表,他只能按照预先设定的不同网段来进行转发.网关最重要的一层就是端口映射,子网内用户在外网看来只是外网的IP地址对应着不同的端口,这样看来就会保护子网内的用户.\n\n### C/C++\n\n#### BSS段的功能\n\n#### char *p1 = \"123\" 与char p2[]=\"123\",其中p1,p2区别\n\n答: 常量是存储在内存中的,\n*p1 是指针 指向\"123\"中的\"1\"的地址\np2[] 是数组 本质是在堆栈中定义的一段内存\n\n#### sizeof(struct{char c;int a;}) = ?\n\n答: 4\n\n内存对其,整体占得内存一定是**最大数据元素的整数倍**.\n这里最大的是int(4字节)整体就是(4*n字节)\n大概是这个样子\n|int|char|\n△△△△|△---|\n\n#### 多线程编程经验\n\n#### C++网络编程\n\n#### C++11新增了什么,了解的有哪些.\n\n#### [√]const关键字作用.\n[好文](https://www.cnblogs.com/chogen/p/4574118.html)\n####  [-]多态/虚函数\n\n[介绍](https://www.cnblogs.com/qiaoconglovelife/p/5128523.html)\n\n### Java\n\n####  [√]HashMap\n\n[介绍链接](https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653191907&idx=1&sn=876860c5a9a6710ead5dd8de37403ffc&chksm=8c990c39bbee852f71c9dfc587fd70d10b0eab1cca17123c0a68bf1e16d46d71717712b91509&scene=38#wechat_redirect)\n\n#### Synchronze 和 Lock的区别和用法\n\nSynchronze(隐式锁) | Lock(显示锁)\n-|-\n在需要同步的对象中加入此控制,synchronize可以加在方法上,也可以加在特定代码块中,括号中表示需要所得对象|需要显示指定起始位置和终止位置.一般使用ReentrantLock类作为锁,多个线程中必须要使用一个ReentrantLock类作为对象才能保证锁的生效.且在加锁和解锁处需要通过lock()和unlock()显示指出.所以一般会在finally块中写unlock()以防死锁\n托管给JVM执行的|java写的控制锁代码\n采用的的CPU的悲观锁机制,即线程获得的是独占锁.独占锁意味着其他线程只能依靠阻塞来等待线程释放锁|乐观锁方式,每次不加锁而是假设没有冲突而去完成某项操作,如果因为冲突失败就重试,直到成功为止.乐观锁实现的机制就是CAS操作(Compare and Swap)\n\nPs: 在Java1.5中, syncchronize是性能低效的,因为这是一个重量级操作,需要调用操作接口,导致有可能加锁消耗的系统时间比加锁以外的操作还多. 相比之下使用Java提供的Lock对象,性能更高一些.但是到了Java1.6,发生了变化. synchronize在语义上很清晰,可以进行很多优化,有适应自旋,锁消除,锁粗化,轻量级锁,偏向锁等等. 导致在Java1.6上synchronize的性能并不比Lock差.\n\n#### 乐观锁,悲观锁\n\n- **乐观锁（ Optimistic Locking ）** 相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。而乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。\n- **悲观锁（Pessimistic Lock）**，正如其名，具有强烈的独占和排他特性。它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。\n\n### Linux \n\n#### 进程的内存分布\n\n名称|内容\n-|-\n代码段|可执行代码\n数据段|已初始化全局变量,已初始化全局静态变量,局部静态变量,常量数据\nBSS段|未初始化全局变量,未初始化全局静态变量\n栈|局部变量,函数参数\n堆|动态内存分配\n\n\n\n#### 那个命令可以常看内存使用情况\n答: \ntop\nfree [-h]\n<!-- ps aux --sort -rss -->\n#### touch有什么用\n\n答: 两个作用\n- 一,用于吧已存在文件的时间标签更新为系统当前的时间(默认方式),它们的数据将原封不动地保留下来;\n- 二,用来创建新的空文件\n\n#### 僵尸进程,孤儿进程,守护进程\n\n[详细介绍](https://blog.csdn.net/gogokongyin/article/details/51340432)\n\n- **僵尸进程:** 在fork()/execve()过程中,假设子进程结束时父进程仍存在,而父进程fork()之前既没安装SIGCHLD信号处理函数调用waitpid()等待子进程结束,又没有显示忽略该信号,则子进程成为僵尸进程.\n\n- **孤儿进程:** 一个父进程退出,而它的一个或多个子进程还在运行,那么那些子进程将成为孤儿进程. 孤儿进程将被init进程(进程号为1)所收养,并由init进程对他们完成状态收集工作. \n\n- **守护进程:** Linux系统中的守护进程是一种运行在后台的进程. 而守护进程,也就是通常说的Daemon进程. 它通常独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件. Linux大多数服务器进程就是用这种守护进程实现的, 例如Web服务.守护进程常常在系统引导装入时启动, 在系统关闭时终止. 守护进程最大的特点是运行在后台,与终端无连接, 除非特殊情况下, 用户不能操作守护进程.\n\n### python\n\n### 大数据\n\n#### MongoDB vs Redis\n\nMongoDB和Redis都是NoSQL，采用结构型数据存储。二者在使用场景中，存在一定的区别，这也主要由于二者在内存映射的处理过程，持久化的处理方法不同。\n\n MongoDB建议集群部署，更多的考虑到集群方案，Redis更偏重于进程顺序写入，虽然支持集群，也仅限于主-从模式。\n\n \n\n比较指标\t|MongoDB(v2.4.9)\t|Redis(v2.4.17)\t|比较说明\n-|-|-|-\n实现语言\t|c++\t|c/c++\t|-\n协议\t|BSON,自定义二进制\t|类telnet\t|-\n性能\t|依赖内存,TPS{(transaction per second)代表每秒执行的事务数量}较高\t|依赖内存,TPS非常高\t|Redis优于MongoDB\n可操作性\t|丰富的数据表达,索引;最类似于关系型数据库,支持丰富的查询语句\t|数据丰富,较少的IO\t|MongoDB优于Redis\n内存及存储\t|适合大数据量存储,依赖系统虚拟内存,采用镜像文件存储;内存占用率比较高,官方建议独立部署在64位系统\t|Redis2.0后支持虚拟内存特性(VM) 突破物理内存限制;数据可以设置时效性,类似于memcache\t|不同的应用场景,各有千秋\n可用性|\t支持master-slave,replicatset(内部采用paxos选举算法,自动故障恢复),auto sharding机制,对客户端屏蔽了故障转移和切片机制\t|依赖客户端来实现分布式读写;主从复制时,每次从节点重新连接主节点都要依赖整个快照,无增量复制;不支持auto sharding,需要依赖程序设定一致性hash机制\t|MongoDB优于Redis；单点问题上,MongoDB应用简单,相对用户透明,Redis比较复杂,需要客户端主动解决.(MongoDB一般使用replicasets和sharding相结合,replicasets侧重高可用性以及高可靠,sharding侧重性能,水平扩展)\n可靠性|\t从1.8版本后,采用binlog方式(类似Mysql) 支持持久化\t|依赖快照进行持久化;AOF增强可靠性;增强性的同时,影响访问性能\t|-\n一致性|\t不支持事务,靠客户端保证\t|支持事务,比较脆,仅能保证事务中的操作按顺序执行\t|Redis优于MongoDB\n数据分析|\t内置数据分析功能(mapreduce)\t|不支持\t|MongoDB优于Redis\n应用场景|\t海量数据的访问效率提升\t|较小数据量的性能和运算\t|MongoDB优于Redis\n\n\n### 数据库\n\n#### 数据库事务的四大特性(ACID)\n\n- **原子性(Atomicity)**\n事务是数据库的逻辑工作单位,它对数据库的修改要么全部执行,要么全部不执行.\n- **一致性(Consistemcy)**\n事务前后,数据库的状态都满足所有的完整性约束\n- **隔离性(lsolation)**\n并发执行的事务是隔离的,一个不影响一个.如果有两个事务,运行在相同的时间内,执行相同的功能,事务的隔离性将确保每一事务在系统中认为只有该事物在使用系统. 这种属性有时称为串行化,为了防止事务操作间的混淆,必须串行化或序列化请求,使得在同一时间仅有y一个请求用于统一数据.通过设置数据库的**隔离级别**,可以达到不同的隔离效果.\n- 持久性(Durability)\n在事务完成后,该事务所对数据库所作的更改便持久的保存在数据库之中,并不会被回滚.\n\n#### 并发事务引起的问题\n\n- **更新丢失**\n两个事务都同时更新一行数据，但是第二个事务却中途失败退出，导致对数据的两个修改都失效了。这是因为系统没有执行任何的锁操作，因此并发事务并没有被隔离开来。\n\n- **脏读**\n脏读又称无效数据读出。一个事务读取另外一个事务还没有提交的数据叫脏读。\n例如：事务T1修改了一行数据，但是还没有提交，这时候事务T2读取了被事务T1修改后的数据，之后事务T1因为某种原因Rollback了，那么事务T2读取的数据就是脏的。\n\n## 设计题/系统题\n\n### .\n\n#### []设计一个ID分配器\n\n#### .\n\n\n## 技术无关\n\n### .\n\n#### 能抗住压力么 \n\n答:作为应届生,本就应该吃苦耐劳学技术,人都是逼出来的,有压力才有动力,这点压力不算什么.\n\n#### 有女朋友么\n答: 没有,一心向学,不找女朋友浪费时间.(TM是找不到好不2333)\n\n#### 你有什么问题吗\n\n1. 这个岗位做的主要业务是什么\n2. 岗位的技术栈\n3. 招这个岗位的校招或者实习生更看重哪方面的能力\n","source":"_posts/StudyOfInterview.md","raw":"---\ntitle: 面试学习.\ndate: 2018-1-29 12:44:08\ncategories:  \ntags: [面试,C++,大数据,操作系统,计算机网络] #文章标签，可空，多标签请用格式，注意:后面有个空格\ndescription: \ntoc: true\n---\n\n> 记录下我针对面试的学习\n\n## 算法/编程题\n\n### a\n\n####  [√][荷兰国旗问题](http://acm.nyist.edu.cn/JudgeOnline/problem.php?pid=268)\n\n 噗 , 被高大上的名字给吓到了,其实就是简单的C语言入门题.\n\n####  实现一个LRU算法\n####  [√]双栈实现一个队列\n[实现代码](https://github.com/tabris233/slove-problems/blob/master/2018-1/29/QUEUE-two%20stack.cpp)\n\n####  [√]编程题\n问题: 两个数组 A 表示一串螺丝 B 表示一串螺帽 螺丝和螺帽能够配对，但是A中螺丝之间不能比较大小，B中螺帽之间也不能比较大小，螺丝和螺帽可以比较大小，返回所有螺丝和螺帽的对应关系，要求复杂度小于O(n^2)\n\n解: 类似快速排序,一个和另一个比较就可以了.\n[code](https://github.com/tabris233/slove-problems/blob/master/2018-1/30/%E8%9E%BA%E4%B8%9D%E5%92%8C%E8%9E%BA%E5%B8%BD.cpp)\n####  今日头条笔试真题\nhttps://www.nowcoder.com/test/8537140/summary\n\n## 基础知识\n\n### 算法与数据结构\n\n\n\n### 操作系统\n\n#### 一个进程\n一个进程是**PCB结构与程序与数据的组合**\n\n#### [-]产生死锁的必要条件\n- 互斥条件: 即某个资源在一段时间内只能由一个进程占有,不能同事被两个或两个以上的进程占有.这种独占资源如CD-ROM驱动器,打印机等等,必须在占有该资源的进程主动释放它之后,其他进程才能占有该资源.这是有资源本身的属性所决定的.如独木桥就是一种独占资源,两方的人不能同时过桥.\n\n- 不可抢占条件: 进程所获得的资源在未使用完毕之前,资源申请者不能强行地从资源占有者中夺取资源.而只能由该资源的占有者进程自行释放.如过独木桥的人自己不能强迫对方后退,也不能非法地将对方退下桥,必须是桥上的人自己过桥后空出桥面(即主动释放占有资源),对方的人才能过桥.\n\n- 占有且申请条件: 进程至少已经占有一个资源,但又申请新的资源; 由于该资源已经被另外进程占有,此时该进程阻塞; 但是,它在等待新资源之时,扔继续占用已占有的资源.还以过独木桥为例,甲乙两人在桥上相遇. 甲走过一段桥面(即占有了一些资源),还需要走其余的桥面(申请新的资源),但那部分桥面被已占有(已走过一段桥面).甲过不去,前进不能,又不后退;乙也处于同样的状况.\n\n- 循环等待条件: 存在一个进程等待序列{P1,P2, ... ,Pn}, 其中P1等待P2所占有的某一资源, P2等待P3所占有的某一源, ...... ,而Pn等待P1所占有的某一资源形成一个进程循环等待环.就像前面的过独木桥问题,甲等待乙占有的桥面,而乙有等待甲占有的桥面, 从而彼此循环等待.\n\n#### [-]死锁预防\n- 打破互斥条件: 即允许进程同事访问某些资源.但是,有的资源不允许被同时访问的,像打印机等等.这是由资源本身的属性所决定的. 所以,这种办法并无实用价值\n\n- 打破不可抢占条件: 即允许进程强行从占有者哪里夺取某些资源. 就是说, 当一个进程已占有了某些资源,他又申请新的资源,但不能立即被满足,它必须释放所占有的全部资源, 以后再重新申请. 他所释放的资源可以分配给其他进程.这就相当于该进程占有的资源被隐蔽性地强占了. 这种预防死锁的方法实现起来困难,会降低系统性能.\n\n- 打破占有且申请条件: 可以实行资源预先分配策略. 即进程在运行前一次地向系统申请它所需要的全部资源. 如果某个进程所需的全部资源得不到满足,则不分配任何资源,此进程在不运行.只有当系统能够满足当前进程的全部资源需求时,才一次性地将所申请的资源全部分配给该进程. 由于运行的进程已占有它所需要的全部资源所以不会发生占有资源有申请资源的现象, 因此不会发生死锁. 但是,这种策略也有如下缺点:\n    - 在许多情况下,一个进程在执行之前不可能知道它所需要的全部资源. 这是由于进程在执行时是动态的,不可预测的.\n    - 资源利用率低.无论所分资源何时用到,一个进程只有在占有所需要的全部资源后才能执行.即使有些资源最后才被该进程用到一次,但该进程生存期间一直占有他们,造成长期占着不用的状况.这显然是一种极大的资源浪费.\n    - 降低了进程的并发性.因为资源有限,又加上存在浪费,能分配到所需全部资源的进程个数就必然少了.\n- 打破循环等待条件:**实行资源有序分配策略**.采用这种策略,即把资源事先分类编号,按号分配,使进程在申请,占用资源是不会形成环路.所有进程对资源的请求必须严格按字元序号递增的顺序提出.进程占用了小号资源,才能申请大耗资源,就不会产生环路, 从而预防了死锁.这种策略与前面的策略相比, 资源的利用率和系统的吞吐量都有了很大的提高,但是也存在一下缺点:\n    - 限制了进程对资源的请求,同事给系统中所有资源合理编号也是件困难时,并增加了系统的开销.\n    - 为了遵循按编号申请的次序,在不使用的资源也需要提前申请,从而增加了进程对资源的占用时间.\n\n#### 死锁避免\n- 银行家算法\n系统给当前进程分配资源时,先检查是否安全.\n在满足当前的进程X资源申请后,是否还能有足够的资源去满足下一个距最大资源需求最近的进程(如某进程最大需要5个单位资源,已拥有1个,还需4个),若可以满足,则继续检查下一个距最大资源需求最近的进程,若均能满足所有进程,则表示为安全,可以允许给当前进程X分配其所需的资源申请,否则让该进程X进入等待.\n- 哲学家进餐问题\n\n#### [-]进程和线程的区别\n\n>定义\n>**进程**是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.\n>**线程**是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.\n>关系\n>一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.\n>相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。\n>区别\n>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。\n>>简而言之,一个程序至少有一个进程,一个进程至少有一个线程.\n>线程的划分尺度小于进程，使得多线程程序的并发性高。\n>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。\n>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。\n>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。\n>优缺点\n>线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。\n\n#### []进程间通信\n\n####### 为什么需要进程间通信？？\n\n进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程）之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源（例如打开的文件描述符）。\n\n\n\n但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程间通信( IPC：Inter Processes Communication )。\n\n进程间通信的目的：\n\n- 数据传输：一个进程需要将它的数据发送给另一个进程。\n- 通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。\n- 资源共享：多个进程之间共享同样的资源。为了做到这一点，需要内核提供互斥和同步机制。\n- 进程控制：有些进程希望完全控制另一个进程的执行（如 Debug 进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。\nLinux 操作系统支持的主要进程间通信的通信机制：\n\n![进程间通信-1](../images/StudyOfInterview/jcjtx.jpg '进程间通信')\n\n###### [进程间通信(IPC)介绍](https://www.cnblogs.com/CheeseZH/p/5264465.html)\n\n#### []进程调度\n\n#### []进程的内存分布\n\n|||\n|-|-|\n|代码段|全局常量（const）、字符串常量、函数以及编译时可决定的某些东西|\n|数据段|存储初始化的全局变量 和 初始化的静态变量(全局和局部)|\n|BSS段|存储未初始化的全局变量 和 未初始化的静态变量(全局和局部)|\n|堆|动态分配的区域（malloc、new等）|\n|栈|l临时声明的局部变量(初始化以及未初始化的,但不包含静态变量),局部常量(const)|\n|命令行参数和环境变量|顾名思义|\n\n![](https://images2015.cnblogs.com/blog/978007/201702/978007-20170208113706760-1208301174.png)\n\n\n#### 进程调度\n\n- 先来先服务 （FCFS，first come first served） \n在所有调度算法中，最简单的是非抢占式的FCFS算法。 \n算法原理：进程按照它们请求CPU的顺序使用CPU.就像你买东西去排队，谁第一个排，谁就先被执行，在它执行的过程中，不会中断它。当其他人也想进入内存被执行，就要排队等着，如果在执行过程中出现一些事，他现在不想排队了，下一个排队的就补上。此时如果他又想排队了，只能站到队尾去。 \n算法优点：易于理解且实现简单，只需要一个队列(FIFO)，且相当公平 \n算法缺点：比较有利于长进程，而不利于短进程，有利于CPU 繁忙的进程，而不利于I/O 繁忙的进程\n\n- 最短作业优先（SJF, Shortest Job First） \n短作业优先（SJF, Shortest Job First）又称为“短进程优先”SPN(Shortest Process Next)；这是对FCFS算法的改进，其目标是减少平均周转时间。 \n算法原理：对预计执行时间短的进程优先分派处理机。通常后来的短进程不抢先正在执行的进程。 \n算法优点：相比FCFS 算法，该算法可改善平均周转时间和平均带权周转时间，缩短进程的等待时间，提高系统的吞吐量。 \n算法缺点：对长进程非常不利，可能长时间得不到执行，且未能依据进程的紧迫程度来划分执行的优先级，以及难以准确估计进程的执行时间，从而影响调度性能。\n\n- 最高响应比优先法(HRRN，Highest Response Ratio Next) \n最高响应比优先法(HRRN，Highest Response Ratio Next)是对FCFS方式和SJF方式的一种综合平衡。FCFS方式只考虑每个作业的等待时间而未考虑执行时间的长短，而SJF方式只考虑执行时间而未考虑等待时间的长短。因此，这两种调度算法在某些极端情况下会带来某些不便。HRN调度策略同时考虑每个作业的等待时间长短和估计需要的执行时间长短，从中选出响应比最高的作业投入执行。这样，即使是长作业，随着它等待时间的增加，W / T也就随着增加，也就有机会获得调度执行。这种算法是介于FCFS和SJF之间的一种折中算法。 \n算法原理：响应比R定义如下： R =(W+T)/T = 1+W/T \n其中T为该作业估计需要的执行时间，W为作业在后备状态队列中的等待时间。每当要进行作业调度时，系统计算每个作业的响应比，选择其中R最大者投入执行。 \n算法优点：由于长作业也有机会投入运行，在同一时间内处理的作业数显然要少于SJF法，从而采用HRRN方式时其吞吐量将小于采用SJF 法时的吞吐量。 \n算法缺点：由于每次调度前要计算响应比，系统开销也要相应增加。\n\n- 时间片轮转算法（RR，Round-Robin） \n 该算法采用剥夺策略。时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称RR调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。 \n算法原理：让就绪进程以FCFS 的方式按时间片轮流使用CPU 的调度方式，即将系统中所有的就绪进程按照FCFS 原则，排成一个队列，每次调度时将CPU 分派给队首进程，让其执行一个时间片，时间片的长度从几个ms 到几百ms。在一个时间片结束时，发生时钟中断，调度程序据此暂停当前进程的执行，将其送到就绪队列的末尾，并通过上下文切换执行当前的队首进程，进程可以未使用完一个时间片，就出让CPU（如阻塞）。 \n 算法优点：时间片轮转调度算法的特点是简单易行、平均响应时间短。 \n算法缺点：不利于处理紧急作业。在时间片轮转算法中，时间片的大小对系统性能的影响很大，因此时间片的大小应选择恰当 \n 怎样确定时间片的大小：\n  - 时间片大小的确定 \n    1.系统对响应时间的要求 \n    2.就绪队列中进程的数目 \n    3.系统的处理力\n\n- 多级反馈队列(Multilevel Feedback Queue) \n多级反馈队列调度算法是一种CPU处理机调度算法，UNIX操作系统采取的便是这种调度算法。 \n多级反馈队列调度算法描述： \n　　1、进程在进入待调度的队列等待时，首先进入优先级最高的Q1等待。 \n　　2、首先调度优先级高的队列中的进程。若高优先级中队列中已没有调度的进程，则调度次优先级队列中的进程。例如：Q1,Q2,Q3三个队列，只有在Q1中没有进程等待时才去调度Q2，同理，只有Q1,Q2都为空时才会去调度Q3。 \n　　3、对于同一个队列中的各个进程，按照时间片轮转法调度。比如Q1队列的时间片为N，那么Q1中的作业在经历了N个时间片后若还没有完成，则进入Q2队列等待，若Q2的时间片用完后作业还不能完成，一直进入下一级队列，直至完成。 \n　　4、在低优先级的队列中的进程在运行时，又有新到达的作业，那么在运行完这个时间片后，CPU马上分配给新到达的作业（抢占式）。 \n　　在多级反馈队列调度算法中，如果规定第一个队列的时间片略大于多数人机交互所需之处理时间时，便能够较好的满足各种类型用户的需要。\n\n### 计算机网络\n\n#### []TCP和UDP区别\n||TCP|UDP|\n|-|-|---|\n|传输|提供面向连接的、可靠地数据流传输|提供的是非面向连接的、不可靠的数据流传输|\n|传输单位|TCP报文段|用户数据报|\n|安全性|TCP注重数据安全性|UDP数据传输快，因为不需要链接等待，少了许多操作，但是起安全性却一般|\n||||\n|协议|FTP:定义了文件传输协议,使用21端口;|DNS: 用于域名解析服务,将域名地址转换成IP地址.DNS用的是53号端口.|\n|协议|Telnet: 一种用于远程登录的端口,使用23端口,用户可以以自己的身份远程连接到计算机上,可提供基于DOS模式下的通信服务|SNMP: 简单网络管理协议,使用161端口,是用来管理网络十倍的.由于网络设备很多,无连接的服务就体现出其优势.|\n|协议|SMTP: 邮件传送协议,用于发送邮件.服务端开放的是25号端口|TFTP(Trival File Transfer Protocal): 简单文件传输协议,该协议在熟知端口69上使用UDP服务|\n|协议|POP3: 它是和SMTP对应,POP3用于接收邮件.POP3协议所用的是110端口||\n|协议|HTTP: 是从Web服务器传输超文本到本地浏览器的传送协议||\n\n[详细介绍,戳<<<--](http://blog.csdn.net/li_ning_/article/details/52117463)\n\n>TCP与UDP区别总结：\n>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接\n>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保   证可靠交付\n>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）\n>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信\n>TCP首部开销20字节;UDP的首部开销小，只有8个字节\n>TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道\n\n#### [-]TCP三次握手/四次挥手\n\n[详细介绍,戳<<<---](http://blog.csdn.net/qzcsu/article/details/72861891)\n[更亲民的介绍,戳<<<---](https://www.cnblogs.com/myvin/p/4862167.html)\n\n建立连接的过程是利用客户服务器模式,假设主机A为客户端,主机B为服务端\n- TCP的三次握手过程：主机Ａ向Ｂ发送链接请求; -> 主机B对收到的主机A的报文段进行确认; -> 主机A再次对主机B的确认进行确认\n- 采用三次握手是为了防止失效的链接请求报文段突然有传送到主机B,因而产生错误.失效的链接请求报文段是指: 主机A出的连接请求没有收到主机B的确认,于是经过一段时间后,主机A又重新向主机B发送连接请求,且建立成功,顺序完成数据传输. 考虑这样一个特殊情况,主机A第一次发送的连接请求并没有丢失,而是因为网络节点导致延迟到达主机B,主机B以为是主机又发起的新连接,于是主机B同意连接,并向主机A发回确认,但是此时主机A根本不会理会,主机B就一直在等待主机A发送数据，导致主机Ｂ的资源浪费．\n- 采用两次握手不行, 原因就是上面说的实效的连接请求的特殊情况.\n\n#### TCP里的一些机制\n\n#### OSI,TCP/IP,五层协议的体系结构,以及各层协议\n\nOSI分层(7层): 物理层,数据链路层,网络层,传输层,会话层,表示层,应用层.\nTCP/IP分层(4层): 网络接口层,网际层,运输层,应用层.\n五层协议(5层): 物理层,数据链路层,网络层,运输层,应用层.\n\n每一层的协议如下:\n物理层: RJ45,CLOCK,IEEE802.3(中继器,集线器)\n数据链路: POP,FR,HDLC,VLAN,MAX(网桥,交换机)\n网络层: IP,UCMP,ARP,RARP,OSPF,IPX,RIP,IGRP(路由器)\n传输层: TCP,UDP,SPX\n会话层: NFS,SQL,NETBIOS,RPC\n表示层: JPEG,MPEG,ASII\n应用层: FTP,DNS,Telnet,SMTP,HTTP,WWW,NFS\n\n每一层的作用如下\n\n物理层: 通过媒介传输比特,确定机械及电器规范(比特Bit)\n数据链路: 将比特组装成帧和点到点的传递(帧Frame)\n网络层: 负责数据包从源到宿的传递和网际互联(包PackeT)\n传输层: 提供端到端的可靠报文传递和错误回复(段Segment)\n会话层: 简历,管理和中智慧化(会话协议数据单元SPDU)\n表示层: 对数据进行翻译,加密和压缩(表示协议数据单元PPDU)\n应用层: 允许方位OSI环境的手段(应用协议数据单元APDU)\n\n#### IP地址的分类\nA类地址: 以0开头, 第一个字节范围1~127(1.0.0.0~127.255.255.255);\nB类地址: 以10开头, 第一个字节范围128~191(128.0.0.0~191.255.255.255);\nC类地址: 以110开头, 第一个字节范围192~223(192.0.0.0~223.255.255.255);\nD类地址: 以1110开头, 第一个字节范围224~239(224.0.0.0~239.255.255.255);\nE类地址: 保留\n\n一种A,B,C是基本类,D,E类作为多播和保留使用.\n以下是留用的内部私有地址:\nA类 10.0.0.0  -- 10.255.255.255\nB类 182.16.00 -- 192.31.255.255\nC类 192.168.0.0 -- 192.168.255.255\n\nIP地址与子网掩码相与(&)得到网络号\nip 192.168.2.110\n&\nsubmask:255.255.255.0\n.---------------------------------\n网络号 192.168.2.0\n\n注: 主机号,全是0的网络号(例如192.168.2.0),主机号全为1的为广播地址(192.168.2.255)\n\n#### ARP是地址解析协议,简单语言解释一下工作原理.\n\n- 首先,每个主机都会在自己的ARP缓冲区中建立一个ARP列表,以表示IP地址和MAC地址之间的对应关系.\n- 当源主机要发送数据时,首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址,如果有,则直接发送数据,如果没有,就向本网段的所有主机发送ARP数据包,该数据包包括的内容有: 源主机的IP地址,源主机的MAC地址,目的主机的IP地址.\n- 当本网络中的所有主机收到该ARP数据包时,首先检查数据包中的IP地址是否是自己的IP地址,如果不是,则忽略该数据包,,如果是,则首先从数据包中去除源主机的IP和MAC地址写入到ARP列表中,如果已经存在,则覆盖,然后将自己的MAC地址写入ARP响应包中,告诉源主机自己是它想要找的MAC地址\n- 源主机收到ARP响应后.将目的主机的IP和MAC地址写入ARP列表,并利用此信息发送数据. 如果源主机一直没有收到ARP相应数据包,表示ARP查询失败.\n\n广播发送ARP请求,单播发送ARP相应. \n\n#### RARP协议\nRARP是逆地址解析协议,作用是完成硬件地址到IP地址的映射,主要用于无盘工作站,因为给无盘工作站配置的IP地址不能保存. \n工作流畅: 在网络中配置一台RARP服务器,里面保存者IP地址和MAC地址的映射关系,当无盘工作站启动后,就封装一个RARP数据包,里面有其MAC地址,然后广播到网络上去,当服务器收到请求包后,就查找对应的MAC地址的IP地址装入响应报文中发回给请求者. 因为需要广播请求报文,因此RARP只能用于具有广播能力的网络.\n\n#### 各种协议的介绍\n\n- **ICMP协议**: 因特网控制报文协议.它是TCP/IP协议族的一个自协议,用于在IP主机/路由器之间传递控制消息.\n- **TFTP协议**: 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议,提供不复杂,开销不大的文件传输服务.\n- **HTTP协议**: 超文本传输协议,是一个属于应用层的面向对象的协议,由于其简捷,快速的方式,适用于分布式超媒体信息系统\n- **NAT协议**: 网络地址转换属介入广域网(WAN)技术,是一种将私有(保留)地址转化为合法IP地址的转换技术.\n- **DHCP协议**: 动态主机配置协议,给用户或者内部网络管理员作为对所有计算机作中央管理的手段.\n\n#### 在浏览器中输入www.baidu.com后执行的全部过程\n\n- 1. 客户端浏览器通过DNS解析到www.baidu.com的IP地址为220.181.27.48, 通过这个IP地址找到客户端到服务器的路径. 客户端浏览器发起一个HTTP回话到220.181.27.48, 然后通过TCP进行封装数据包, 输入到网络层.\n- 2. 在客户端的传输层,把HTTP回话请求分成报文段,添加源和目的端口, 如服务器使用80端口监听客户端的请求, 客户端有系统随机选择一个端口如5000, 与服务器进行交换,服务器吧相应的请求返回给客户端的5000端口. 然后使用IP层的IP地址查找目的端.\n- 3. 客户端的网络层不用关心应用层或者传输层的东西, 主要做到的是通过查找路由表确定如何到达服务器,期间可能经过多个路由器,这些都是有路由器来完成的工作, 我不做过多的描述, 无非就是通过查找路由表决定通过哪个路径到达服务器.\n- 4. 客户端的链路层, 包通过链路层发送到路由器, 通过邻居协议查找给定IP地址的MAC地址,然后发送ARP请求查找到目的地址, 如果得到回应后就可以使用ARP的请求应答交换的IP数据包,现在就可以传输了,然后发送IP数据包到达服务器的地址.\n\n#### DNS域名系统,简单描述其工作原理\n\n当DNS客户机需要在程序中使用名称时, 它会查询DNS服务器来解析该名称. 客户机发送的每条查询信息包括三条信息: 包括: 指定的DNS域名,DNS域名的指定类型. 基于UDP服务,端口53. 该应用一般不直接为用户使用, 而是为其他应用服务,如 HTTP,SMTO等在其中需要完成主机名到地址的转换.\n\n#### 了解交换机,路由器,网关的概念, 并知道各自的用途\n\n- **交换机**\n在计算机网络系统中,交换机是针对共享工作模式的弱点而推出的.交换机拥有一条高带宽的背部总线和内部交换矩阵.交换机的所有的端口都挂接在这条背部总线上,当控制电路收到数据包以后,处理端口会查找内存中的地址对照表以确定目的端口.目的MAC若不存在,交换机才广播到所有的端口, 接手端口回应后交换机会'学习'新的地址,并把它添加入内部地址表中.\n交换机工作于OSI参考模型的第二层,即数据链路层. 交换机内部的CPU会在每个端口成功连接时,通过ARP协议学习它的MAC地址,保存成一张ARP表. 在今后的通讯中, 发往该MAC地址的数据包将仅送往其对应的端口,而不是所有端口. 因此,交换机可用于划分数据链路层广播,即冲突域; 但它不能划分网络层广播, 即广播域.\n交换机被广泛应用于二层网络交换,俗称'二层交换机'.\n交换机的种类有: 二层交换机,三层交换机,四层交换机,七层交换机分别工作在OSI七层模型中的第二层,第三层,第四层和第七层,并因此而得名.\n\n- 路由器\n路由器(Router)是一种计算机网络设备,提供了路由与传送两种重要机制,可以决定数据包从来源端到目的端所经过的路由路径(host到host之间的传输路径),这个过程称为**路由**; 将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行),这成为**传动**. 路由工作在OSI模型的第三层 -> 即网络层,例如网际协议.\n路由器的一个作用是连通不同的网络另一个作用是选择信息传送的线路. 路由器与交换机的差别, 路由器是属于OSI第三层的产品,交换机是OSI第二层的产品(这里至二层交换机)\n\n- 网关\n网关(Gateway), 网关顾名思义就是连接两个网络的设备,区别与路由器(由于历史的原因,许多有关TCP/IP的文献曾经把网络层使用的路由器成为网关,在今天很多局域网采用的都是路由器来接入网络,因此现在通常指的网关就是路由器的IP),经常在家庭中或者小型企业网络中使用,用于连接局域网和Internet. 网关也经常把一种协议转成另一种协议的设备,比如语音网关.\n在传统TCP/IP术语中,网络设备只分成两种,一种为网关(Gateway),另一种称为主机(host). 网关能在网络间传递数据包,但主机不能传送数据包.在主机(又称终端系统,end system)中,数据包需经过TCP/IP四层协议处理,但是在网关(又称中介系统,intermediate system)只需要到达网际层(Internet layer),决定路径之后就可以传送. 在当时,网关(Gateway)和路由(Router)还没有区别.\n在现代网络术语中,网关(Gateway)和路由(Router)的定义不同,网关(Gateway)能在不同协议间移动数据,而路由器(Router)是在不同网络间移动数据,相当于传统所说的IP网关(IP Gateway).\n网关是连接两个网络的设备,对于语音网关来说,它可以连接PSTN网络和以太网,这就相当于VOIP,把不同电话的模拟信号通过网关而转换成数字信号,而且加入协议再去传输. 在到了接收端的时候再通过网关还原成模拟的电话信号,最后才能在电话机上听到.\n对于以太网中的网关只能转发三层以上数据包,这一点和路由是一样的.而不同的是网关中并没有路由表,他只能按照预先设定的不同网段来进行转发.网关最重要的一层就是端口映射,子网内用户在外网看来只是外网的IP地址对应着不同的端口,这样看来就会保护子网内的用户.\n\n### C/C++\n\n#### BSS段的功能\n\n#### char *p1 = \"123\" 与char p2[]=\"123\",其中p1,p2区别\n\n答: 常量是存储在内存中的,\n*p1 是指针 指向\"123\"中的\"1\"的地址\np2[] 是数组 本质是在堆栈中定义的一段内存\n\n#### sizeof(struct{char c;int a;}) = ?\n\n答: 4\n\n内存对其,整体占得内存一定是**最大数据元素的整数倍**.\n这里最大的是int(4字节)整体就是(4*n字节)\n大概是这个样子\n|int|char|\n△△△△|△---|\n\n#### 多线程编程经验\n\n#### C++网络编程\n\n#### C++11新增了什么,了解的有哪些.\n\n#### [√]const关键字作用.\n[好文](https://www.cnblogs.com/chogen/p/4574118.html)\n####  [-]多态/虚函数\n\n[介绍](https://www.cnblogs.com/qiaoconglovelife/p/5128523.html)\n\n### Java\n\n####  [√]HashMap\n\n[介绍链接](https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653191907&idx=1&sn=876860c5a9a6710ead5dd8de37403ffc&chksm=8c990c39bbee852f71c9dfc587fd70d10b0eab1cca17123c0a68bf1e16d46d71717712b91509&scene=38#wechat_redirect)\n\n#### Synchronze 和 Lock的区别和用法\n\nSynchronze(隐式锁) | Lock(显示锁)\n-|-\n在需要同步的对象中加入此控制,synchronize可以加在方法上,也可以加在特定代码块中,括号中表示需要所得对象|需要显示指定起始位置和终止位置.一般使用ReentrantLock类作为锁,多个线程中必须要使用一个ReentrantLock类作为对象才能保证锁的生效.且在加锁和解锁处需要通过lock()和unlock()显示指出.所以一般会在finally块中写unlock()以防死锁\n托管给JVM执行的|java写的控制锁代码\n采用的的CPU的悲观锁机制,即线程获得的是独占锁.独占锁意味着其他线程只能依靠阻塞来等待线程释放锁|乐观锁方式,每次不加锁而是假设没有冲突而去完成某项操作,如果因为冲突失败就重试,直到成功为止.乐观锁实现的机制就是CAS操作(Compare and Swap)\n\nPs: 在Java1.5中, syncchronize是性能低效的,因为这是一个重量级操作,需要调用操作接口,导致有可能加锁消耗的系统时间比加锁以外的操作还多. 相比之下使用Java提供的Lock对象,性能更高一些.但是到了Java1.6,发生了变化. synchronize在语义上很清晰,可以进行很多优化,有适应自旋,锁消除,锁粗化,轻量级锁,偏向锁等等. 导致在Java1.6上synchronize的性能并不比Lock差.\n\n#### 乐观锁,悲观锁\n\n- **乐观锁（ Optimistic Locking ）** 相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。而乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。\n- **悲观锁（Pessimistic Lock）**，正如其名，具有强烈的独占和排他特性。它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。\n\n### Linux \n\n#### 进程的内存分布\n\n名称|内容\n-|-\n代码段|可执行代码\n数据段|已初始化全局变量,已初始化全局静态变量,局部静态变量,常量数据\nBSS段|未初始化全局变量,未初始化全局静态变量\n栈|局部变量,函数参数\n堆|动态内存分配\n\n\n\n#### 那个命令可以常看内存使用情况\n答: \ntop\nfree [-h]\n<!-- ps aux --sort -rss -->\n#### touch有什么用\n\n答: 两个作用\n- 一,用于吧已存在文件的时间标签更新为系统当前的时间(默认方式),它们的数据将原封不动地保留下来;\n- 二,用来创建新的空文件\n\n#### 僵尸进程,孤儿进程,守护进程\n\n[详细介绍](https://blog.csdn.net/gogokongyin/article/details/51340432)\n\n- **僵尸进程:** 在fork()/execve()过程中,假设子进程结束时父进程仍存在,而父进程fork()之前既没安装SIGCHLD信号处理函数调用waitpid()等待子进程结束,又没有显示忽略该信号,则子进程成为僵尸进程.\n\n- **孤儿进程:** 一个父进程退出,而它的一个或多个子进程还在运行,那么那些子进程将成为孤儿进程. 孤儿进程将被init进程(进程号为1)所收养,并由init进程对他们完成状态收集工作. \n\n- **守护进程:** Linux系统中的守护进程是一种运行在后台的进程. 而守护进程,也就是通常说的Daemon进程. 它通常独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件. Linux大多数服务器进程就是用这种守护进程实现的, 例如Web服务.守护进程常常在系统引导装入时启动, 在系统关闭时终止. 守护进程最大的特点是运行在后台,与终端无连接, 除非特殊情况下, 用户不能操作守护进程.\n\n### python\n\n### 大数据\n\n#### MongoDB vs Redis\n\nMongoDB和Redis都是NoSQL，采用结构型数据存储。二者在使用场景中，存在一定的区别，这也主要由于二者在内存映射的处理过程，持久化的处理方法不同。\n\n MongoDB建议集群部署，更多的考虑到集群方案，Redis更偏重于进程顺序写入，虽然支持集群，也仅限于主-从模式。\n\n \n\n比较指标\t|MongoDB(v2.4.9)\t|Redis(v2.4.17)\t|比较说明\n-|-|-|-\n实现语言\t|c++\t|c/c++\t|-\n协议\t|BSON,自定义二进制\t|类telnet\t|-\n性能\t|依赖内存,TPS{(transaction per second)代表每秒执行的事务数量}较高\t|依赖内存,TPS非常高\t|Redis优于MongoDB\n可操作性\t|丰富的数据表达,索引;最类似于关系型数据库,支持丰富的查询语句\t|数据丰富,较少的IO\t|MongoDB优于Redis\n内存及存储\t|适合大数据量存储,依赖系统虚拟内存,采用镜像文件存储;内存占用率比较高,官方建议独立部署在64位系统\t|Redis2.0后支持虚拟内存特性(VM) 突破物理内存限制;数据可以设置时效性,类似于memcache\t|不同的应用场景,各有千秋\n可用性|\t支持master-slave,replicatset(内部采用paxos选举算法,自动故障恢复),auto sharding机制,对客户端屏蔽了故障转移和切片机制\t|依赖客户端来实现分布式读写;主从复制时,每次从节点重新连接主节点都要依赖整个快照,无增量复制;不支持auto sharding,需要依赖程序设定一致性hash机制\t|MongoDB优于Redis；单点问题上,MongoDB应用简单,相对用户透明,Redis比较复杂,需要客户端主动解决.(MongoDB一般使用replicasets和sharding相结合,replicasets侧重高可用性以及高可靠,sharding侧重性能,水平扩展)\n可靠性|\t从1.8版本后,采用binlog方式(类似Mysql) 支持持久化\t|依赖快照进行持久化;AOF增强可靠性;增强性的同时,影响访问性能\t|-\n一致性|\t不支持事务,靠客户端保证\t|支持事务,比较脆,仅能保证事务中的操作按顺序执行\t|Redis优于MongoDB\n数据分析|\t内置数据分析功能(mapreduce)\t|不支持\t|MongoDB优于Redis\n应用场景|\t海量数据的访问效率提升\t|较小数据量的性能和运算\t|MongoDB优于Redis\n\n\n### 数据库\n\n#### 数据库事务的四大特性(ACID)\n\n- **原子性(Atomicity)**\n事务是数据库的逻辑工作单位,它对数据库的修改要么全部执行,要么全部不执行.\n- **一致性(Consistemcy)**\n事务前后,数据库的状态都满足所有的完整性约束\n- **隔离性(lsolation)**\n并发执行的事务是隔离的,一个不影响一个.如果有两个事务,运行在相同的时间内,执行相同的功能,事务的隔离性将确保每一事务在系统中认为只有该事物在使用系统. 这种属性有时称为串行化,为了防止事务操作间的混淆,必须串行化或序列化请求,使得在同一时间仅有y一个请求用于统一数据.通过设置数据库的**隔离级别**,可以达到不同的隔离效果.\n- 持久性(Durability)\n在事务完成后,该事务所对数据库所作的更改便持久的保存在数据库之中,并不会被回滚.\n\n#### 并发事务引起的问题\n\n- **更新丢失**\n两个事务都同时更新一行数据，但是第二个事务却中途失败退出，导致对数据的两个修改都失效了。这是因为系统没有执行任何的锁操作，因此并发事务并没有被隔离开来。\n\n- **脏读**\n脏读又称无效数据读出。一个事务读取另外一个事务还没有提交的数据叫脏读。\n例如：事务T1修改了一行数据，但是还没有提交，这时候事务T2读取了被事务T1修改后的数据，之后事务T1因为某种原因Rollback了，那么事务T2读取的数据就是脏的。\n\n## 设计题/系统题\n\n### .\n\n#### []设计一个ID分配器\n\n#### .\n\n\n## 技术无关\n\n### .\n\n#### 能抗住压力么 \n\n答:作为应届生,本就应该吃苦耐劳学技术,人都是逼出来的,有压力才有动力,这点压力不算什么.\n\n#### 有女朋友么\n答: 没有,一心向学,不找女朋友浪费时间.(TM是找不到好不2333)\n\n#### 你有什么问题吗\n\n1. 这个岗位做的主要业务是什么\n2. 岗位的技术栈\n3. 招这个岗位的校招或者实习生更看重哪方面的能力\n","slug":"StudyOfInterview","published":1,"updated":"2018-09-23T09:37:43.110Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnyhsxoj000sas1om5yfmpel","content":"<blockquote>\n<p>记录下我针对面试的学习</p>\n</blockquote>\n<h2 id=\"算法-编程题\"><a href=\"#算法-编程题\" class=\"headerlink\" title=\"算法/编程题\"></a>算法/编程题</h2><h3 id=\"a\"><a href=\"#a\" class=\"headerlink\" title=\"a\"></a>a</h3><h4 id=\"√-荷兰国旗问题\"><a href=\"#√-荷兰国旗问题\" class=\"headerlink\" title=\"[√]荷兰国旗问题\"></a>[√]<a href=\"http://acm.nyist.edu.cn/JudgeOnline/problem.php?pid=268\" target=\"_blank\" rel=\"noopener\">荷兰国旗问题</a></h4><p> 噗 , 被高大上的名字给吓到了,其实就是简单的C语言入门题.</p>\n<h4 id=\"实现一个LRU算法\"><a href=\"#实现一个LRU算法\" class=\"headerlink\" title=\"实现一个LRU算法\"></a>实现一个LRU算法</h4><h4 id=\"√-双栈实现一个队列\"><a href=\"#√-双栈实现一个队列\" class=\"headerlink\" title=\"[√]双栈实现一个队列\"></a>[√]双栈实现一个队列</h4><p><a href=\"https://github.com/tabris233/slove-problems/blob/master/2018-1/29/QUEUE-two%20stack.cpp\" target=\"_blank\" rel=\"noopener\">实现代码</a></p>\n<h4 id=\"√-编程题\"><a href=\"#√-编程题\" class=\"headerlink\" title=\"[√]编程题\"></a>[√]编程题</h4><p>问题: 两个数组 A 表示一串螺丝 B 表示一串螺帽 螺丝和螺帽能够配对，但是A中螺丝之间不能比较大小，B中螺帽之间也不能比较大小，螺丝和螺帽可以比较大小，返回所有螺丝和螺帽的对应关系，要求复杂度小于O(n^2)</p>\n<p>解: 类似快速排序,一个和另一个比较就可以了.<br><a href=\"https://github.com/tabris233/slove-problems/blob/master/2018-1/30/%E8%9E%BA%E4%B8%9D%E5%92%8C%E8%9E%BA%E5%B8%BD.cpp\" target=\"_blank\" rel=\"noopener\">code</a></p>\n<h4 id=\"今日头条笔试真题\"><a href=\"#今日头条笔试真题\" class=\"headerlink\" title=\"今日头条笔试真题\"></a>今日头条笔试真题</h4><p><a href=\"https://www.nowcoder.com/test/8537140/summary\" target=\"_blank\" rel=\"noopener\">https://www.nowcoder.com/test/8537140/summary</a></p>\n<h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><h3 id=\"算法与数据结构\"><a href=\"#算法与数据结构\" class=\"headerlink\" title=\"算法与数据结构\"></a>算法与数据结构</h3><h3 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h3><h4 id=\"一个进程\"><a href=\"#一个进程\" class=\"headerlink\" title=\"一个进程\"></a>一个进程</h4><p>一个进程是<strong>PCB结构与程序与数据的组合</strong></p>\n<h4 id=\"产生死锁的必要条件\"><a href=\"#产生死锁的必要条件\" class=\"headerlink\" title=\"[-]产生死锁的必要条件\"></a>[-]产生死锁的必要条件</h4><ul>\n<li><p>互斥条件: 即某个资源在一段时间内只能由一个进程占有,不能同事被两个或两个以上的进程占有.这种独占资源如CD-ROM驱动器,打印机等等,必须在占有该资源的进程主动释放它之后,其他进程才能占有该资源.这是有资源本身的属性所决定的.如独木桥就是一种独占资源,两方的人不能同时过桥.</p>\n</li>\n<li><p>不可抢占条件: 进程所获得的资源在未使用完毕之前,资源申请者不能强行地从资源占有者中夺取资源.而只能由该资源的占有者进程自行释放.如过独木桥的人自己不能强迫对方后退,也不能非法地将对方退下桥,必须是桥上的人自己过桥后空出桥面(即主动释放占有资源),对方的人才能过桥.</p>\n</li>\n<li><p>占有且申请条件: 进程至少已经占有一个资源,但又申请新的资源; 由于该资源已经被另外进程占有,此时该进程阻塞; 但是,它在等待新资源之时,扔继续占用已占有的资源.还以过独木桥为例,甲乙两人在桥上相遇. 甲走过一段桥面(即占有了一些资源),还需要走其余的桥面(申请新的资源),但那部分桥面被已占有(已走过一段桥面).甲过不去,前进不能,又不后退;乙也处于同样的状况.</p>\n</li>\n<li><p>循环等待条件: 存在一个进程等待序列{P1,P2, … ,Pn}, 其中P1等待P2所占有的某一资源, P2等待P3所占有的某一源, …… ,而Pn等待P1所占有的某一资源形成一个进程循环等待环.就像前面的过独木桥问题,甲等待乙占有的桥面,而乙有等待甲占有的桥面, 从而彼此循环等待.</p>\n</li>\n</ul>\n<h4 id=\"死锁预防\"><a href=\"#死锁预防\" class=\"headerlink\" title=\"[-]死锁预防\"></a>[-]死锁预防</h4><ul>\n<li><p>打破互斥条件: 即允许进程同事访问某些资源.但是,有的资源不允许被同时访问的,像打印机等等.这是由资源本身的属性所决定的. 所以,这种办法并无实用价值</p>\n</li>\n<li><p>打破不可抢占条件: 即允许进程强行从占有者哪里夺取某些资源. 就是说, 当一个进程已占有了某些资源,他又申请新的资源,但不能立即被满足,它必须释放所占有的全部资源, 以后再重新申请. 他所释放的资源可以分配给其他进程.这就相当于该进程占有的资源被隐蔽性地强占了. 这种预防死锁的方法实现起来困难,会降低系统性能.</p>\n</li>\n<li><p>打破占有且申请条件: 可以实行资源预先分配策略. 即进程在运行前一次地向系统申请它所需要的全部资源. 如果某个进程所需的全部资源得不到满足,则不分配任何资源,此进程在不运行.只有当系统能够满足当前进程的全部资源需求时,才一次性地将所申请的资源全部分配给该进程. 由于运行的进程已占有它所需要的全部资源所以不会发生占有资源有申请资源的现象, 因此不会发生死锁. 但是,这种策略也有如下缺点:</p>\n<ul>\n<li>在许多情况下,一个进程在执行之前不可能知道它所需要的全部资源. 这是由于进程在执行时是动态的,不可预测的.</li>\n<li>资源利用率低.无论所分资源何时用到,一个进程只有在占有所需要的全部资源后才能执行.即使有些资源最后才被该进程用到一次,但该进程生存期间一直占有他们,造成长期占着不用的状况.这显然是一种极大的资源浪费.</li>\n<li>降低了进程的并发性.因为资源有限,又加上存在浪费,能分配到所需全部资源的进程个数就必然少了.</li>\n</ul>\n</li>\n<li>打破循环等待条件:<strong>实行资源有序分配策略</strong>.采用这种策略,即把资源事先分类编号,按号分配,使进程在申请,占用资源是不会形成环路.所有进程对资源的请求必须严格按字元序号递增的顺序提出.进程占用了小号资源,才能申请大耗资源,就不会产生环路, 从而预防了死锁.这种策略与前面的策略相比, 资源的利用率和系统的吞吐量都有了很大的提高,但是也存在一下缺点:<ul>\n<li>限制了进程对资源的请求,同事给系统中所有资源合理编号也是件困难时,并增加了系统的开销.</li>\n<li>为了遵循按编号申请的次序,在不使用的资源也需要提前申请,从而增加了进程对资源的占用时间.</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"死锁避免\"><a href=\"#死锁避免\" class=\"headerlink\" title=\"死锁避免\"></a>死锁避免</h4><ul>\n<li>银行家算法<br>系统给当前进程分配资源时,先检查是否安全.<br>在满足当前的进程X资源申请后,是否还能有足够的资源去满足下一个距最大资源需求最近的进程(如某进程最大需要5个单位资源,已拥有1个,还需4个),若可以满足,则继续检查下一个距最大资源需求最近的进程,若均能满足所有进程,则表示为安全,可以允许给当前进程X分配其所需的资源申请,否则让该进程X进入等待.</li>\n<li>哲学家进餐问题</li>\n</ul>\n<h4 id=\"进程和线程的区别\"><a href=\"#进程和线程的区别\" class=\"headerlink\" title=\"[-]进程和线程的区别\"></a>[-]进程和线程的区别</h4><blockquote>\n<p>定义<br><strong>进程</strong>是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.<br><strong>线程</strong>是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.<br>关系<br>一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.<br>相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。<br>区别<br>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p>\n<blockquote>\n<p>简而言之,一个程序至少有一个进程,一个进程至少有一个线程.<br>线程的划分尺度小于进程，使得多线程程序的并发性高。<br>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。<br>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。<br>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。<br>优缺点<br>线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。</p>\n</blockquote>\n</blockquote>\n<h4 id=\"进程间通信\"><a href=\"#进程间通信\" class=\"headerlink\" title=\"[]进程间通信\"></a>[]进程间通信</h4><p>####### 为什么需要进程间通信？？</p>\n<p>进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程）之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源（例如打开的文件描述符）。</p>\n<p>但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程间通信( IPC：Inter Processes Communication )。</p>\n<p>进程间通信的目的：</p>\n<ul>\n<li>数据传输：一个进程需要将它的数据发送给另一个进程。</li>\n<li>通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。</li>\n<li>资源共享：多个进程之间共享同样的资源。为了做到这一点，需要内核提供互斥和同步机制。</li>\n<li>进程控制：有些进程希望完全控制另一个进程的执行（如 Debug 进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。<br>Linux 操作系统支持的主要进程间通信的通信机制：</li>\n</ul>\n<p><img src=\"../images/StudyOfInterview/jcjtx.jpg\" alt=\"进程间通信-1\" title=\"进程间通信\"></p>\n<h6 id=\"进程间通信-IPC-介绍\"><a href=\"#进程间通信-IPC-介绍\" class=\"headerlink\" title=\"进程间通信(IPC)介绍\"></a><a href=\"https://www.cnblogs.com/CheeseZH/p/5264465.html\" target=\"_blank\" rel=\"noopener\">进程间通信(IPC)介绍</a></h6><h4 id=\"进程调度\"><a href=\"#进程调度\" class=\"headerlink\" title=\"[]进程调度\"></a>[]进程调度</h4><h4 id=\"进程的内存分布\"><a href=\"#进程的内存分布\" class=\"headerlink\" title=\"[]进程的内存分布\"></a>[]进程的内存分布</h4><table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>代码段</td>\n<td>全局常量（const）、字符串常量、函数以及编译时可决定的某些东西</td>\n</tr>\n<tr>\n<td>数据段</td>\n<td>存储初始化的全局变量 和 初始化的静态变量(全局和局部)</td>\n</tr>\n<tr>\n<td>BSS段</td>\n<td>存储未初始化的全局变量 和 未初始化的静态变量(全局和局部)</td>\n</tr>\n<tr>\n<td>堆</td>\n<td>动态分配的区域（malloc、new等）</td>\n</tr>\n<tr>\n<td>栈</td>\n<td>l临时声明的局部变量(初始化以及未初始化的,但不包含静态变量),局部常量(const)</td>\n</tr>\n<tr>\n<td>命令行参数和环境变量</td>\n<td>顾名思义</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"https://images2015.cnblogs.com/blog/978007/201702/978007-20170208113706760-1208301174.png\" alt=\"\"></p>\n<h4 id=\"进程调度-1\"><a href=\"#进程调度-1\" class=\"headerlink\" title=\"进程调度\"></a>进程调度</h4><ul>\n<li><p>先来先服务 （FCFS，first come first served）<br>在所有调度算法中，最简单的是非抢占式的FCFS算法。<br>算法原理：进程按照它们请求CPU的顺序使用CPU.就像你买东西去排队，谁第一个排，谁就先被执行，在它执行的过程中，不会中断它。当其他人也想进入内存被执行，就要排队等着，如果在执行过程中出现一些事，他现在不想排队了，下一个排队的就补上。此时如果他又想排队了，只能站到队尾去。<br>算法优点：易于理解且实现简单，只需要一个队列(FIFO)，且相当公平<br>算法缺点：比较有利于长进程，而不利于短进程，有利于CPU 繁忙的进程，而不利于I/O 繁忙的进程</p>\n</li>\n<li><p>最短作业优先（SJF, Shortest Job First）<br>短作业优先（SJF, Shortest Job First）又称为“短进程优先”SPN(Shortest Process Next)；这是对FCFS算法的改进，其目标是减少平均周转时间。<br>算法原理：对预计执行时间短的进程优先分派处理机。通常后来的短进程不抢先正在执行的进程。<br>算法优点：相比FCFS 算法，该算法可改善平均周转时间和平均带权周转时间，缩短进程的等待时间，提高系统的吞吐量。<br>算法缺点：对长进程非常不利，可能长时间得不到执行，且未能依据进程的紧迫程度来划分执行的优先级，以及难以准确估计进程的执行时间，从而影响调度性能。</p>\n</li>\n<li><p>最高响应比优先法(HRRN，Highest Response Ratio Next)<br>最高响应比优先法(HRRN，Highest Response Ratio Next)是对FCFS方式和SJF方式的一种综合平衡。FCFS方式只考虑每个作业的等待时间而未考虑执行时间的长短，而SJF方式只考虑执行时间而未考虑等待时间的长短。因此，这两种调度算法在某些极端情况下会带来某些不便。HRN调度策略同时考虑每个作业的等待时间长短和估计需要的执行时间长短，从中选出响应比最高的作业投入执行。这样，即使是长作业，随着它等待时间的增加，W / T也就随着增加，也就有机会获得调度执行。这种算法是介于FCFS和SJF之间的一种折中算法。<br>算法原理：响应比R定义如下： R =(W+T)/T = 1+W/T<br>其中T为该作业估计需要的执行时间，W为作业在后备状态队列中的等待时间。每当要进行作业调度时，系统计算每个作业的响应比，选择其中R最大者投入执行。<br>算法优点：由于长作业也有机会投入运行，在同一时间内处理的作业数显然要少于SJF法，从而采用HRRN方式时其吞吐量将小于采用SJF 法时的吞吐量。<br>算法缺点：由于每次调度前要计算响应比，系统开销也要相应增加。</p>\n</li>\n<li><p>时间片轮转算法（RR，Round-Robin）<br>该算法采用剥夺策略。时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称RR调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。<br>算法原理：让就绪进程以FCFS 的方式按时间片轮流使用CPU 的调度方式，即将系统中所有的就绪进程按照FCFS 原则，排成一个队列，每次调度时将CPU 分派给队首进程，让其执行一个时间片，时间片的长度从几个ms 到几百ms。在一个时间片结束时，发生时钟中断，调度程序据此暂停当前进程的执行，将其送到就绪队列的末尾，并通过上下文切换执行当前的队首进程，进程可以未使用完一个时间片，就出让CPU（如阻塞）。<br>算法优点：时间片轮转调度算法的特点是简单易行、平均响应时间短。<br>算法缺点：不利于处理紧急作业。在时间片轮转算法中，时间片的大小对系统性能的影响很大，因此时间片的大小应选择恰当<br>怎样确定时间片的大小：</p>\n<ul>\n<li>时间片大小的确定<br>1.系统对响应时间的要求<br>2.就绪队列中进程的数目<br>3.系统的处理力</li>\n</ul>\n</li>\n<li><p>多级反馈队列(Multilevel Feedback Queue)<br>多级反馈队列调度算法是一种CPU处理机调度算法，UNIX操作系统采取的便是这种调度算法。<br>多级反馈队列调度算法描述：<br>　　1、进程在进入待调度的队列等待时，首先进入优先级最高的Q1等待。<br>　　2、首先调度优先级高的队列中的进程。若高优先级中队列中已没有调度的进程，则调度次优先级队列中的进程。例如：Q1,Q2,Q3三个队列，只有在Q1中没有进程等待时才去调度Q2，同理，只有Q1,Q2都为空时才会去调度Q3。<br>　　3、对于同一个队列中的各个进程，按照时间片轮转法调度。比如Q1队列的时间片为N，那么Q1中的作业在经历了N个时间片后若还没有完成，则进入Q2队列等待，若Q2的时间片用完后作业还不能完成，一直进入下一级队列，直至完成。<br>　　4、在低优先级的队列中的进程在运行时，又有新到达的作业，那么在运行完这个时间片后，CPU马上分配给新到达的作业（抢占式）。<br>　　在多级反馈队列调度算法中，如果规定第一个队列的时间片略大于多数人机交互所需之处理时间时，便能够较好的满足各种类型用户的需要。</p>\n</li>\n</ul>\n<h3 id=\"计算机网络\"><a href=\"#计算机网络\" class=\"headerlink\" title=\"计算机网络\"></a>计算机网络</h3><h4 id=\"TCP和UDP区别\"><a href=\"#TCP和UDP区别\" class=\"headerlink\" title=\"[]TCP和UDP区别\"></a>[]TCP和UDP区别</h4><table>\n<thead>\n<tr>\n<th></th>\n<th>TCP</th>\n<th>UDP</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>传输</td>\n<td>提供面向连接的、可靠地数据流传输</td>\n<td>提供的是非面向连接的、不可靠的数据流传输</td>\n</tr>\n<tr>\n<td>传输单位</td>\n<td>TCP报文段</td>\n<td>用户数据报</td>\n</tr>\n<tr>\n<td>安全性</td>\n<td>TCP注重数据安全性</td>\n<td>UDP数据传输快，因为不需要链接等待，少了许多操作，但是起安全性却一般</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>协议</td>\n<td>FTP:定义了文件传输协议,使用21端口;</td>\n<td>DNS: 用于域名解析服务,将域名地址转换成IP地址.DNS用的是53号端口.</td>\n</tr>\n<tr>\n<td>协议</td>\n<td>Telnet: 一种用于远程登录的端口,使用23端口,用户可以以自己的身份远程连接到计算机上,可提供基于DOS模式下的通信服务</td>\n<td>SNMP: 简单网络管理协议,使用161端口,是用来管理网络十倍的.由于网络设备很多,无连接的服务就体现出其优势.</td>\n</tr>\n<tr>\n<td>协议</td>\n<td>SMTP: 邮件传送协议,用于发送邮件.服务端开放的是25号端口</td>\n<td>TFTP(Trival File Transfer Protocal): 简单文件传输协议,该协议在熟知端口69上使用UDP服务</td>\n</tr>\n<tr>\n<td>协议</td>\n<td>POP3: 它是和SMTP对应,POP3用于接收邮件.POP3协议所用的是110端口</td>\n<td></td>\n</tr>\n<tr>\n<td>协议</td>\n<td>HTTP: 是从Web服务器传输超文本到本地浏览器的传送协议</td>\n</tr>\n</tbody>\n</table>\n<p><a href=\"http://blog.csdn.net/li_ning_/article/details/52117463\" target=\"_blank\" rel=\"noopener\">详细介绍,戳&lt;&lt;&lt;–</a></p>\n<blockquote>\n<p>TCP与UDP区别总结：<br>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接<br>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保   证可靠交付<br>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）<br>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信<br>TCP首部开销20字节;UDP的首部开销小，只有8个字节<br>TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</p>\n</blockquote>\n<h4 id=\"TCP三次握手-四次挥手\"><a href=\"#TCP三次握手-四次挥手\" class=\"headerlink\" title=\"[-]TCP三次握手/四次挥手\"></a>[-]TCP三次握手/四次挥手</h4><p><a href=\"http://blog.csdn.net/qzcsu/article/details/72861891\" target=\"_blank\" rel=\"noopener\">详细介绍,戳&lt;&lt;&lt;—</a><br><a href=\"https://www.cnblogs.com/myvin/p/4862167.html\" target=\"_blank\" rel=\"noopener\">更亲民的介绍,戳&lt;&lt;&lt;—</a></p>\n<p>建立连接的过程是利用客户服务器模式,假设主机A为客户端,主机B为服务端</p>\n<ul>\n<li>TCP的三次握手过程：主机Ａ向Ｂ发送链接请求; -&gt; 主机B对收到的主机A的报文段进行确认; -&gt; 主机A再次对主机B的确认进行确认</li>\n<li>采用三次握手是为了防止失效的链接请求报文段突然有传送到主机B,因而产生错误.失效的链接请求报文段是指: 主机A出的连接请求没有收到主机B的确认,于是经过一段时间后,主机A又重新向主机B发送连接请求,且建立成功,顺序完成数据传输. 考虑这样一个特殊情况,主机A第一次发送的连接请求并没有丢失,而是因为网络节点导致延迟到达主机B,主机B以为是主机又发起的新连接,于是主机B同意连接,并向主机A发回确认,但是此时主机A根本不会理会,主机B就一直在等待主机A发送数据，导致主机Ｂ的资源浪费．</li>\n<li>采用两次握手不行, 原因就是上面说的实效的连接请求的特殊情况.</li>\n</ul>\n<h4 id=\"TCP里的一些机制\"><a href=\"#TCP里的一些机制\" class=\"headerlink\" title=\"TCP里的一些机制\"></a>TCP里的一些机制</h4><h4 id=\"OSI-TCP-IP-五层协议的体系结构-以及各层协议\"><a href=\"#OSI-TCP-IP-五层协议的体系结构-以及各层协议\" class=\"headerlink\" title=\"OSI,TCP/IP,五层协议的体系结构,以及各层协议\"></a>OSI,TCP/IP,五层协议的体系结构,以及各层协议</h4><p>OSI分层(7层): 物理层,数据链路层,网络层,传输层,会话层,表示层,应用层.<br>TCP/IP分层(4层): 网络接口层,网际层,运输层,应用层.<br>五层协议(5层): 物理层,数据链路层,网络层,运输层,应用层.</p>\n<p>每一层的协议如下:<br>物理层: RJ45,CLOCK,IEEE802.3(中继器,集线器)<br>数据链路: POP,FR,HDLC,VLAN,MAX(网桥,交换机)<br>网络层: IP,UCMP,ARP,RARP,OSPF,IPX,RIP,IGRP(路由器)<br>传输层: TCP,UDP,SPX<br>会话层: NFS,SQL,NETBIOS,RPC<br>表示层: JPEG,MPEG,ASII<br>应用层: FTP,DNS,Telnet,SMTP,HTTP,WWW,NFS</p>\n<p>每一层的作用如下</p>\n<p>物理层: 通过媒介传输比特,确定机械及电器规范(比特Bit)<br>数据链路: 将比特组装成帧和点到点的传递(帧Frame)<br>网络层: 负责数据包从源到宿的传递和网际互联(包PackeT)<br>传输层: 提供端到端的可靠报文传递和错误回复(段Segment)<br>会话层: 简历,管理和中智慧化(会话协议数据单元SPDU)<br>表示层: 对数据进行翻译,加密和压缩(表示协议数据单元PPDU)<br>应用层: 允许方位OSI环境的手段(应用协议数据单元APDU)</p>\n<h4 id=\"IP地址的分类\"><a href=\"#IP地址的分类\" class=\"headerlink\" title=\"IP地址的分类\"></a>IP地址的分类</h4><p>A类地址: 以0开头, 第一个字节范围1~127(1.0.0.0~127.255.255.255);<br>B类地址: 以10开头, 第一个字节范围128~191(128.0.0.0~191.255.255.255);<br>C类地址: 以110开头, 第一个字节范围192~223(192.0.0.0~223.255.255.255);<br>D类地址: 以1110开头, 第一个字节范围224~239(224.0.0.0~239.255.255.255);<br>E类地址: 保留</p>\n<p>一种A,B,C是基本类,D,E类作为多播和保留使用.<br>以下是留用的内部私有地址:<br>A类 10.0.0.0  – 10.255.255.255<br>B类 182.16.00 – 192.31.255.255<br>C类 192.168.0.0 – 192.168.255.255</p>\n<p>IP地址与子网掩码相与(&amp;)得到网络号<br>ip 192.168.2.110<br>&amp;<br>submask:255.255.255.0<br>.———————————<br>网络号 192.168.2.0</p>\n<p>注: 主机号,全是0的网络号(例如192.168.2.0),主机号全为1的为广播地址(192.168.2.255)</p>\n<h4 id=\"ARP是地址解析协议-简单语言解释一下工作原理\"><a href=\"#ARP是地址解析协议-简单语言解释一下工作原理\" class=\"headerlink\" title=\"ARP是地址解析协议,简单语言解释一下工作原理.\"></a>ARP是地址解析协议,简单语言解释一下工作原理.</h4><ul>\n<li>首先,每个主机都会在自己的ARP缓冲区中建立一个ARP列表,以表示IP地址和MAC地址之间的对应关系.</li>\n<li>当源主机要发送数据时,首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址,如果有,则直接发送数据,如果没有,就向本网段的所有主机发送ARP数据包,该数据包包括的内容有: 源主机的IP地址,源主机的MAC地址,目的主机的IP地址.</li>\n<li>当本网络中的所有主机收到该ARP数据包时,首先检查数据包中的IP地址是否是自己的IP地址,如果不是,则忽略该数据包,,如果是,则首先从数据包中去除源主机的IP和MAC地址写入到ARP列表中,如果已经存在,则覆盖,然后将自己的MAC地址写入ARP响应包中,告诉源主机自己是它想要找的MAC地址</li>\n<li>源主机收到ARP响应后.将目的主机的IP和MAC地址写入ARP列表,并利用此信息发送数据. 如果源主机一直没有收到ARP相应数据包,表示ARP查询失败.</li>\n</ul>\n<p>广播发送ARP请求,单播发送ARP相应. </p>\n<h4 id=\"RARP协议\"><a href=\"#RARP协议\" class=\"headerlink\" title=\"RARP协议\"></a>RARP协议</h4><p>RARP是逆地址解析协议,作用是完成硬件地址到IP地址的映射,主要用于无盘工作站,因为给无盘工作站配置的IP地址不能保存.<br>工作流畅: 在网络中配置一台RARP服务器,里面保存者IP地址和MAC地址的映射关系,当无盘工作站启动后,就封装一个RARP数据包,里面有其MAC地址,然后广播到网络上去,当服务器收到请求包后,就查找对应的MAC地址的IP地址装入响应报文中发回给请求者. 因为需要广播请求报文,因此RARP只能用于具有广播能力的网络.</p>\n<h4 id=\"各种协议的介绍\"><a href=\"#各种协议的介绍\" class=\"headerlink\" title=\"各种协议的介绍\"></a>各种协议的介绍</h4><ul>\n<li><strong>ICMP协议</strong>: 因特网控制报文协议.它是TCP/IP协议族的一个自协议,用于在IP主机/路由器之间传递控制消息.</li>\n<li><strong>TFTP协议</strong>: 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议,提供不复杂,开销不大的文件传输服务.</li>\n<li><strong>HTTP协议</strong>: 超文本传输协议,是一个属于应用层的面向对象的协议,由于其简捷,快速的方式,适用于分布式超媒体信息系统</li>\n<li><strong>NAT协议</strong>: 网络地址转换属介入广域网(WAN)技术,是一种将私有(保留)地址转化为合法IP地址的转换技术.</li>\n<li><strong>DHCP协议</strong>: 动态主机配置协议,给用户或者内部网络管理员作为对所有计算机作中央管理的手段.</li>\n</ul>\n<h4 id=\"在浏览器中输入www-baidu-com后执行的全部过程\"><a href=\"#在浏览器中输入www-baidu-com后执行的全部过程\" class=\"headerlink\" title=\"在浏览器中输入www.baidu.com后执行的全部过程\"></a>在浏览器中输入<a href=\"http://www.baidu.com后执行的全部过程\" target=\"_blank\" rel=\"noopener\">www.baidu.com后执行的全部过程</a></h4><ul>\n<li><ol>\n<li>客户端浏览器通过DNS解析到<a href=\"http://www.baidu.com的IP地址为220.181.27.48\" target=\"_blank\" rel=\"noopener\">www.baidu.com的IP地址为220.181.27.48</a>, 通过这个IP地址找到客户端到服务器的路径. 客户端浏览器发起一个HTTP回话到220.181.27.48, 然后通过TCP进行封装数据包, 输入到网络层.</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>在客户端的传输层,把HTTP回话请求分成报文段,添加源和目的端口, 如服务器使用80端口监听客户端的请求, 客户端有系统随机选择一个端口如5000, 与服务器进行交换,服务器吧相应的请求返回给客户端的5000端口. 然后使用IP层的IP地址查找目的端.</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>客户端的网络层不用关心应用层或者传输层的东西, 主要做到的是通过查找路由表确定如何到达服务器,期间可能经过多个路由器,这些都是有路由器来完成的工作, 我不做过多的描述, 无非就是通过查找路由表决定通过哪个路径到达服务器.</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>客户端的链路层, 包通过链路层发送到路由器, 通过邻居协议查找给定IP地址的MAC地址,然后发送ARP请求查找到目的地址, 如果得到回应后就可以使用ARP的请求应答交换的IP数据包,现在就可以传输了,然后发送IP数据包到达服务器的地址.</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"DNS域名系统-简单描述其工作原理\"><a href=\"#DNS域名系统-简单描述其工作原理\" class=\"headerlink\" title=\"DNS域名系统,简单描述其工作原理\"></a>DNS域名系统,简单描述其工作原理</h4><p>当DNS客户机需要在程序中使用名称时, 它会查询DNS服务器来解析该名称. 客户机发送的每条查询信息包括三条信息: 包括: 指定的DNS域名,DNS域名的指定类型. 基于UDP服务,端口53. 该应用一般不直接为用户使用, 而是为其他应用服务,如 HTTP,SMTO等在其中需要完成主机名到地址的转换.</p>\n<h4 id=\"了解交换机-路由器-网关的概念-并知道各自的用途\"><a href=\"#了解交换机-路由器-网关的概念-并知道各自的用途\" class=\"headerlink\" title=\"了解交换机,路由器,网关的概念, 并知道各自的用途\"></a>了解交换机,路由器,网关的概念, 并知道各自的用途</h4><ul>\n<li><p><strong>交换机</strong><br>在计算机网络系统中,交换机是针对共享工作模式的弱点而推出的.交换机拥有一条高带宽的背部总线和内部交换矩阵.交换机的所有的端口都挂接在这条背部总线上,当控制电路收到数据包以后,处理端口会查找内存中的地址对照表以确定目的端口.目的MAC若不存在,交换机才广播到所有的端口, 接手端口回应后交换机会’学习’新的地址,并把它添加入内部地址表中.<br>交换机工作于OSI参考模型的第二层,即数据链路层. 交换机内部的CPU会在每个端口成功连接时,通过ARP协议学习它的MAC地址,保存成一张ARP表. 在今后的通讯中, 发往该MAC地址的数据包将仅送往其对应的端口,而不是所有端口. 因此,交换机可用于划分数据链路层广播,即冲突域; 但它不能划分网络层广播, 即广播域.<br>交换机被广泛应用于二层网络交换,俗称’二层交换机’.<br>交换机的种类有: 二层交换机,三层交换机,四层交换机,七层交换机分别工作在OSI七层模型中的第二层,第三层,第四层和第七层,并因此而得名.</p>\n</li>\n<li><p>路由器<br>路由器(Router)是一种计算机网络设备,提供了路由与传送两种重要机制,可以决定数据包从来源端到目的端所经过的路由路径(host到host之间的传输路径),这个过程称为<strong>路由</strong>; 将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行),这成为<strong>传动</strong>. 路由工作在OSI模型的第三层 -&gt; 即网络层,例如网际协议.<br>路由器的一个作用是连通不同的网络另一个作用是选择信息传送的线路. 路由器与交换机的差别, 路由器是属于OSI第三层的产品,交换机是OSI第二层的产品(这里至二层交换机)</p>\n</li>\n<li><p>网关<br>网关(Gateway), 网关顾名思义就是连接两个网络的设备,区别与路由器(由于历史的原因,许多有关TCP/IP的文献曾经把网络层使用的路由器成为网关,在今天很多局域网采用的都是路由器来接入网络,因此现在通常指的网关就是路由器的IP),经常在家庭中或者小型企业网络中使用,用于连接局域网和Internet. 网关也经常把一种协议转成另一种协议的设备,比如语音网关.<br>在传统TCP/IP术语中,网络设备只分成两种,一种为网关(Gateway),另一种称为主机(host). 网关能在网络间传递数据包,但主机不能传送数据包.在主机(又称终端系统,end system)中,数据包需经过TCP/IP四层协议处理,但是在网关(又称中介系统,intermediate system)只需要到达网际层(Internet layer),决定路径之后就可以传送. 在当时,网关(Gateway)和路由(Router)还没有区别.<br>在现代网络术语中,网关(Gateway)和路由(Router)的定义不同,网关(Gateway)能在不同协议间移动数据,而路由器(Router)是在不同网络间移动数据,相当于传统所说的IP网关(IP Gateway).<br>网关是连接两个网络的设备,对于语音网关来说,它可以连接PSTN网络和以太网,这就相当于VOIP,把不同电话的模拟信号通过网关而转换成数字信号,而且加入协议再去传输. 在到了接收端的时候再通过网关还原成模拟的电话信号,最后才能在电话机上听到.<br>对于以太网中的网关只能转发三层以上数据包,这一点和路由是一样的.而不同的是网关中并没有路由表,他只能按照预先设定的不同网段来进行转发.网关最重要的一层就是端口映射,子网内用户在外网看来只是外网的IP地址对应着不同的端口,这样看来就会保护子网内的用户.</p>\n</li>\n</ul>\n<h3 id=\"C-C\"><a href=\"#C-C\" class=\"headerlink\" title=\"C/C++\"></a>C/C++</h3><h4 id=\"BSS段的功能\"><a href=\"#BSS段的功能\" class=\"headerlink\" title=\"BSS段的功能\"></a>BSS段的功能</h4><h4 id=\"char-p1-“123”-与char-p2-”123”-其中p1-p2区别\"><a href=\"#char-p1-“123”-与char-p2-”123”-其中p1-p2区别\" class=\"headerlink\" title=\"char *p1 = “123” 与char p2[]=”123”,其中p1,p2区别\"></a>char *p1 = “123” 与char p2[]=”123”,其中p1,p2区别</h4><p>答: 常量是存储在内存中的,<br>*p1 是指针 指向”123”中的”1”的地址<br>p2[] 是数组 本质是在堆栈中定义的一段内存</p>\n<h4 id=\"sizeof-struct-char-c-int-a\"><a href=\"#sizeof-struct-char-c-int-a\" class=\"headerlink\" title=\"sizeof(struct{char c;int a;}) = ?\"></a>sizeof(struct{char c;int a;}) = ?</h4><p>答: 4</p>\n<p>内存对其,整体占得内存一定是<strong>最大数据元素的整数倍</strong>.<br>这里最大的是int(4字节)整体就是(4*n字节)<br>大概是这个样子<br>|int|char|<br>△△△△|△—|</p>\n<h4 id=\"多线程编程经验\"><a href=\"#多线程编程经验\" class=\"headerlink\" title=\"多线程编程经验\"></a>多线程编程经验</h4><h4 id=\"C-网络编程\"><a href=\"#C-网络编程\" class=\"headerlink\" title=\"C++网络编程\"></a>C++网络编程</h4><h4 id=\"C-11新增了什么-了解的有哪些\"><a href=\"#C-11新增了什么-了解的有哪些\" class=\"headerlink\" title=\"C++11新增了什么,了解的有哪些.\"></a>C++11新增了什么,了解的有哪些.</h4><h4 id=\"√-const关键字作用\"><a href=\"#√-const关键字作用\" class=\"headerlink\" title=\"[√]const关键字作用.\"></a>[√]const关键字作用.</h4><p><a href=\"https://www.cnblogs.com/chogen/p/4574118.html\" target=\"_blank\" rel=\"noopener\">好文</a></p>\n<h4 id=\"多态-虚函数\"><a href=\"#多态-虚函数\" class=\"headerlink\" title=\"[-]多态/虚函数\"></a>[-]多态/虚函数</h4><p><a href=\"https://www.cnblogs.com/qiaoconglovelife/p/5128523.html\" target=\"_blank\" rel=\"noopener\">介绍</a></p>\n<h3 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h3><h4 id=\"√-HashMap\"><a href=\"#√-HashMap\" class=\"headerlink\" title=\"[√]HashMap\"></a>[√]HashMap</h4><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653191907&amp;idx=1&amp;sn=876860c5a9a6710ead5dd8de37403ffc&amp;chksm=8c990c39bbee852f71c9dfc587fd70d10b0eab1cca17123c0a68bf1e16d46d71717712b91509&amp;scene=38#wechat_redirect\" target=\"_blank\" rel=\"noopener\">介绍链接</a></p>\n<h4 id=\"Synchronze-和-Lock的区别和用法\"><a href=\"#Synchronze-和-Lock的区别和用法\" class=\"headerlink\" title=\"Synchronze 和 Lock的区别和用法\"></a>Synchronze 和 Lock的区别和用法</h4><table>\n<thead>\n<tr>\n<th>Synchronze(隐式锁)</th>\n<th>Lock(显示锁)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>在需要同步的对象中加入此控制,synchronize可以加在方法上,也可以加在特定代码块中,括号中表示需要所得对象</td>\n<td>需要显示指定起始位置和终止位置.一般使用ReentrantLock类作为锁,多个线程中必须要使用一个ReentrantLock类作为对象才能保证锁的生效.且在加锁和解锁处需要通过lock()和unlock()显示指出.所以一般会在finally块中写unlock()以防死锁</td>\n</tr>\n<tr>\n<td>托管给JVM执行的</td>\n<td>java写的控制锁代码</td>\n</tr>\n<tr>\n<td>采用的的CPU的悲观锁机制,即线程获得的是独占锁.独占锁意味着其他线程只能依靠阻塞来等待线程释放锁</td>\n<td>乐观锁方式,每次不加锁而是假设没有冲突而去完成某项操作,如果因为冲突失败就重试,直到成功为止.乐观锁实现的机制就是CAS操作(Compare and Swap)</td>\n</tr>\n</tbody>\n</table>\n<p>Ps: 在Java1.5中, syncchronize是性能低效的,因为这是一个重量级操作,需要调用操作接口,导致有可能加锁消耗的系统时间比加锁以外的操作还多. 相比之下使用Java提供的Lock对象,性能更高一些.但是到了Java1.6,发生了变化. synchronize在语义上很清晰,可以进行很多优化,有适应自旋,锁消除,锁粗化,轻量级锁,偏向锁等等. 导致在Java1.6上synchronize的性能并不比Lock差.</p>\n<h4 id=\"乐观锁-悲观锁\"><a href=\"#乐观锁-悲观锁\" class=\"headerlink\" title=\"乐观锁,悲观锁\"></a>乐观锁,悲观锁</h4><ul>\n<li><strong>乐观锁（ Optimistic Locking ）</strong> 相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。而乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</li>\n<li><strong>悲观锁（Pessimistic Lock）</strong>，正如其名，具有强烈的独占和排他特性。它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</li>\n</ul>\n<h3 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h3><h4 id=\"进程的内存分布-1\"><a href=\"#进程的内存分布-1\" class=\"headerlink\" title=\"进程的内存分布\"></a>进程的内存分布</h4><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>代码段</td>\n<td>可执行代码</td>\n</tr>\n<tr>\n<td>数据段</td>\n<td>已初始化全局变量,已初始化全局静态变量,局部静态变量,常量数据</td>\n</tr>\n<tr>\n<td>BSS段</td>\n<td>未初始化全局变量,未初始化全局静态变量</td>\n</tr>\n<tr>\n<td>栈</td>\n<td>局部变量,函数参数</td>\n</tr>\n<tr>\n<td>堆</td>\n<td>动态内存分配</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"那个命令可以常看内存使用情况\"><a href=\"#那个命令可以常看内存使用情况\" class=\"headerlink\" title=\"那个命令可以常看内存使用情况\"></a>那个命令可以常看内存使用情况</h4><p>答:<br>top<br>free [-h]<br><!-- ps aux --sort -rss --></p>\n<h4 id=\"touch有什么用\"><a href=\"#touch有什么用\" class=\"headerlink\" title=\"touch有什么用\"></a>touch有什么用</h4><p>答: 两个作用</p>\n<ul>\n<li>一,用于吧已存在文件的时间标签更新为系统当前的时间(默认方式),它们的数据将原封不动地保留下来;</li>\n<li>二,用来创建新的空文件</li>\n</ul>\n<h4 id=\"僵尸进程-孤儿进程-守护进程\"><a href=\"#僵尸进程-孤儿进程-守护进程\" class=\"headerlink\" title=\"僵尸进程,孤儿进程,守护进程\"></a>僵尸进程,孤儿进程,守护进程</h4><p><a href=\"https://blog.csdn.net/gogokongyin/article/details/51340432\" target=\"_blank\" rel=\"noopener\">详细介绍</a></p>\n<ul>\n<li><p><strong>僵尸进程:</strong> 在fork()/execve()过程中,假设子进程结束时父进程仍存在,而父进程fork()之前既没安装SIGCHLD信号处理函数调用waitpid()等待子进程结束,又没有显示忽略该信号,则子进程成为僵尸进程.</p>\n</li>\n<li><p><strong>孤儿进程:</strong> 一个父进程退出,而它的一个或多个子进程还在运行,那么那些子进程将成为孤儿进程. 孤儿进程将被init进程(进程号为1)所收养,并由init进程对他们完成状态收集工作. </p>\n</li>\n<li><p><strong>守护进程:</strong> Linux系统中的守护进程是一种运行在后台的进程. 而守护进程,也就是通常说的Daemon进程. 它通常独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件. Linux大多数服务器进程就是用这种守护进程实现的, 例如Web服务.守护进程常常在系统引导装入时启动, 在系统关闭时终止. 守护进程最大的特点是运行在后台,与终端无连接, 除非特殊情况下, 用户不能操作守护进程.</p>\n</li>\n</ul>\n<h3 id=\"python\"><a href=\"#python\" class=\"headerlink\" title=\"python\"></a>python</h3><h3 id=\"大数据\"><a href=\"#大数据\" class=\"headerlink\" title=\"大数据\"></a>大数据</h3><h4 id=\"MongoDB-vs-Redis\"><a href=\"#MongoDB-vs-Redis\" class=\"headerlink\" title=\"MongoDB vs Redis\"></a>MongoDB vs Redis</h4><p>MongoDB和Redis都是NoSQL，采用结构型数据存储。二者在使用场景中，存在一定的区别，这也主要由于二者在内存映射的处理过程，持久化的处理方法不同。</p>\n<p> MongoDB建议集群部署，更多的考虑到集群方案，Redis更偏重于进程顺序写入，虽然支持集群，也仅限于主-从模式。</p>\n<table>\n<thead>\n<tr>\n<th>比较指标</th>\n<th>MongoDB(v2.4.9)</th>\n<th>Redis(v2.4.17)</th>\n<th>比较说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>实现语言</td>\n<td>c++</td>\n<td>c/c++</td>\n<td>-</td>\n</tr>\n<tr>\n<td>协议</td>\n<td>BSON,自定义二进制</td>\n<td>类telnet</td>\n<td>-</td>\n</tr>\n<tr>\n<td>性能</td>\n<td>依赖内存,TPS{(transaction per second)代表每秒执行的事务数量}较高</td>\n<td>依赖内存,TPS非常高</td>\n<td>Redis优于MongoDB</td>\n</tr>\n<tr>\n<td>可操作性</td>\n<td>丰富的数据表达,索引;最类似于关系型数据库,支持丰富的查询语句</td>\n<td>数据丰富,较少的IO</td>\n<td>MongoDB优于Redis</td>\n</tr>\n<tr>\n<td>内存及存储</td>\n<td>适合大数据量存储,依赖系统虚拟内存,采用镜像文件存储;内存占用率比较高,官方建议独立部署在64位系统</td>\n<td>Redis2.0后支持虚拟内存特性(VM) 突破物理内存限制;数据可以设置时效性,类似于memcache</td>\n<td>不同的应用场景,各有千秋</td>\n</tr>\n<tr>\n<td>可用性</td>\n<td>支持master-slave,replicatset(内部采用paxos选举算法,自动故障恢复),auto sharding机制,对客户端屏蔽了故障转移和切片机制</td>\n<td>依赖客户端来实现分布式读写;主从复制时,每次从节点重新连接主节点都要依赖整个快照,无增量复制;不支持auto sharding,需要依赖程序设定一致性hash机制</td>\n<td>MongoDB优于Redis；单点问题上,MongoDB应用简单,相对用户透明,Redis比较复杂,需要客户端主动解决.(MongoDB一般使用replicasets和sharding相结合,replicasets侧重高可用性以及高可靠,sharding侧重性能,水平扩展)</td>\n</tr>\n<tr>\n<td>可靠性</td>\n<td>从1.8版本后,采用binlog方式(类似Mysql) 支持持久化</td>\n<td>依赖快照进行持久化;AOF增强可靠性;增强性的同时,影响访问性能</td>\n<td>-</td>\n</tr>\n<tr>\n<td>一致性</td>\n<td>不支持事务,靠客户端保证</td>\n<td>支持事务,比较脆,仅能保证事务中的操作按顺序执行</td>\n<td>Redis优于MongoDB</td>\n</tr>\n<tr>\n<td>数据分析</td>\n<td>内置数据分析功能(mapreduce)</td>\n<td>不支持</td>\n<td>MongoDB优于Redis</td>\n</tr>\n<tr>\n<td>应用场景</td>\n<td>海量数据的访问效率提升</td>\n<td>较小数据量的性能和运算</td>\n<td>MongoDB优于Redis</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h3><h4 id=\"数据库事务的四大特性-ACID\"><a href=\"#数据库事务的四大特性-ACID\" class=\"headerlink\" title=\"数据库事务的四大特性(ACID)\"></a>数据库事务的四大特性(ACID)</h4><ul>\n<li><strong>原子性(Atomicity)</strong><br>事务是数据库的逻辑工作单位,它对数据库的修改要么全部执行,要么全部不执行.</li>\n<li><strong>一致性(Consistemcy)</strong><br>事务前后,数据库的状态都满足所有的完整性约束</li>\n<li><strong>隔离性(lsolation)</strong><br>并发执行的事务是隔离的,一个不影响一个.如果有两个事务,运行在相同的时间内,执行相同的功能,事务的隔离性将确保每一事务在系统中认为只有该事物在使用系统. 这种属性有时称为串行化,为了防止事务操作间的混淆,必须串行化或序列化请求,使得在同一时间仅有y一个请求用于统一数据.通过设置数据库的<strong>隔离级别</strong>,可以达到不同的隔离效果.</li>\n<li>持久性(Durability)<br>在事务完成后,该事务所对数据库所作的更改便持久的保存在数据库之中,并不会被回滚.</li>\n</ul>\n<h4 id=\"并发事务引起的问题\"><a href=\"#并发事务引起的问题\" class=\"headerlink\" title=\"并发事务引起的问题\"></a>并发事务引起的问题</h4><ul>\n<li><p><strong>更新丢失</strong><br>两个事务都同时更新一行数据，但是第二个事务却中途失败退出，导致对数据的两个修改都失效了。这是因为系统没有执行任何的锁操作，因此并发事务并没有被隔离开来。</p>\n</li>\n<li><p><strong>脏读</strong><br>脏读又称无效数据读出。一个事务读取另外一个事务还没有提交的数据叫脏读。<br>例如：事务T1修改了一行数据，但是还没有提交，这时候事务T2读取了被事务T1修改后的数据，之后事务T1因为某种原因Rollback了，那么事务T2读取的数据就是脏的。</p>\n</li>\n</ul>\n<h2 id=\"设计题-系统题\"><a href=\"#设计题-系统题\" class=\"headerlink\" title=\"设计题/系统题\"></a>设计题/系统题</h2><h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\".\"></a>.</h3><h4 id=\"设计一个ID分配器\"><a href=\"#设计一个ID分配器\" class=\"headerlink\" title=\"[]设计一个ID分配器\"></a>[]设计一个ID分配器</h4><h4 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\".\"></a>.</h4><h2 id=\"技术无关\"><a href=\"#技术无关\" class=\"headerlink\" title=\"技术无关\"></a>技术无关</h2><h3 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\".\"></a>.</h3><h4 id=\"能抗住压力么\"><a href=\"#能抗住压力么\" class=\"headerlink\" title=\"能抗住压力么\"></a>能抗住压力么</h4><p>答:作为应届生,本就应该吃苦耐劳学技术,人都是逼出来的,有压力才有动力,这点压力不算什么.</p>\n<h4 id=\"有女朋友么\"><a href=\"#有女朋友么\" class=\"headerlink\" title=\"有女朋友么\"></a>有女朋友么</h4><p>答: 没有,一心向学,不找女朋友浪费时间.(TM是找不到好不2333)</p>\n<h4 id=\"你有什么问题吗\"><a href=\"#你有什么问题吗\" class=\"headerlink\" title=\"你有什么问题吗\"></a>你有什么问题吗</h4><ol>\n<li>这个岗位做的主要业务是什么</li>\n<li>岗位的技术栈</li>\n<li>招这个岗位的校招或者实习生更看重哪方面的能力</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>记录下我针对面试的学习</p>\n</blockquote>\n<h2 id=\"算法-编程题\"><a href=\"#算法-编程题\" class=\"headerlink\" title=\"算法/编程题\"></a>算法/编程题</h2><h3 id=\"a\"><a href=\"#a\" class=\"headerlink\" title=\"a\"></a>a</h3><h4 id=\"√-荷兰国旗问题\"><a href=\"#√-荷兰国旗问题\" class=\"headerlink\" title=\"[√]荷兰国旗问题\"></a>[√]<a href=\"http://acm.nyist.edu.cn/JudgeOnline/problem.php?pid=268\" target=\"_blank\" rel=\"noopener\">荷兰国旗问题</a></h4><p> 噗 , 被高大上的名字给吓到了,其实就是简单的C语言入门题.</p>\n<h4 id=\"实现一个LRU算法\"><a href=\"#实现一个LRU算法\" class=\"headerlink\" title=\"实现一个LRU算法\"></a>实现一个LRU算法</h4><h4 id=\"√-双栈实现一个队列\"><a href=\"#√-双栈实现一个队列\" class=\"headerlink\" title=\"[√]双栈实现一个队列\"></a>[√]双栈实现一个队列</h4><p><a href=\"https://github.com/tabris233/slove-problems/blob/master/2018-1/29/QUEUE-two%20stack.cpp\" target=\"_blank\" rel=\"noopener\">实现代码</a></p>\n<h4 id=\"√-编程题\"><a href=\"#√-编程题\" class=\"headerlink\" title=\"[√]编程题\"></a>[√]编程题</h4><p>问题: 两个数组 A 表示一串螺丝 B 表示一串螺帽 螺丝和螺帽能够配对，但是A中螺丝之间不能比较大小，B中螺帽之间也不能比较大小，螺丝和螺帽可以比较大小，返回所有螺丝和螺帽的对应关系，要求复杂度小于O(n^2)</p>\n<p>解: 类似快速排序,一个和另一个比较就可以了.<br><a href=\"https://github.com/tabris233/slove-problems/blob/master/2018-1/30/%E8%9E%BA%E4%B8%9D%E5%92%8C%E8%9E%BA%E5%B8%BD.cpp\" target=\"_blank\" rel=\"noopener\">code</a></p>\n<h4 id=\"今日头条笔试真题\"><a href=\"#今日头条笔试真题\" class=\"headerlink\" title=\"今日头条笔试真题\"></a>今日头条笔试真题</h4><p><a href=\"https://www.nowcoder.com/test/8537140/summary\" target=\"_blank\" rel=\"noopener\">https://www.nowcoder.com/test/8537140/summary</a></p>\n<h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><h3 id=\"算法与数据结构\"><a href=\"#算法与数据结构\" class=\"headerlink\" title=\"算法与数据结构\"></a>算法与数据结构</h3><h3 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h3><h4 id=\"一个进程\"><a href=\"#一个进程\" class=\"headerlink\" title=\"一个进程\"></a>一个进程</h4><p>一个进程是<strong>PCB结构与程序与数据的组合</strong></p>\n<h4 id=\"产生死锁的必要条件\"><a href=\"#产生死锁的必要条件\" class=\"headerlink\" title=\"[-]产生死锁的必要条件\"></a>[-]产生死锁的必要条件</h4><ul>\n<li><p>互斥条件: 即某个资源在一段时间内只能由一个进程占有,不能同事被两个或两个以上的进程占有.这种独占资源如CD-ROM驱动器,打印机等等,必须在占有该资源的进程主动释放它之后,其他进程才能占有该资源.这是有资源本身的属性所决定的.如独木桥就是一种独占资源,两方的人不能同时过桥.</p>\n</li>\n<li><p>不可抢占条件: 进程所获得的资源在未使用完毕之前,资源申请者不能强行地从资源占有者中夺取资源.而只能由该资源的占有者进程自行释放.如过独木桥的人自己不能强迫对方后退,也不能非法地将对方退下桥,必须是桥上的人自己过桥后空出桥面(即主动释放占有资源),对方的人才能过桥.</p>\n</li>\n<li><p>占有且申请条件: 进程至少已经占有一个资源,但又申请新的资源; 由于该资源已经被另外进程占有,此时该进程阻塞; 但是,它在等待新资源之时,扔继续占用已占有的资源.还以过独木桥为例,甲乙两人在桥上相遇. 甲走过一段桥面(即占有了一些资源),还需要走其余的桥面(申请新的资源),但那部分桥面被已占有(已走过一段桥面).甲过不去,前进不能,又不后退;乙也处于同样的状况.</p>\n</li>\n<li><p>循环等待条件: 存在一个进程等待序列{P1,P2, … ,Pn}, 其中P1等待P2所占有的某一资源, P2等待P3所占有的某一源, …… ,而Pn等待P1所占有的某一资源形成一个进程循环等待环.就像前面的过独木桥问题,甲等待乙占有的桥面,而乙有等待甲占有的桥面, 从而彼此循环等待.</p>\n</li>\n</ul>\n<h4 id=\"死锁预防\"><a href=\"#死锁预防\" class=\"headerlink\" title=\"[-]死锁预防\"></a>[-]死锁预防</h4><ul>\n<li><p>打破互斥条件: 即允许进程同事访问某些资源.但是,有的资源不允许被同时访问的,像打印机等等.这是由资源本身的属性所决定的. 所以,这种办法并无实用价值</p>\n</li>\n<li><p>打破不可抢占条件: 即允许进程强行从占有者哪里夺取某些资源. 就是说, 当一个进程已占有了某些资源,他又申请新的资源,但不能立即被满足,它必须释放所占有的全部资源, 以后再重新申请. 他所释放的资源可以分配给其他进程.这就相当于该进程占有的资源被隐蔽性地强占了. 这种预防死锁的方法实现起来困难,会降低系统性能.</p>\n</li>\n<li><p>打破占有且申请条件: 可以实行资源预先分配策略. 即进程在运行前一次地向系统申请它所需要的全部资源. 如果某个进程所需的全部资源得不到满足,则不分配任何资源,此进程在不运行.只有当系统能够满足当前进程的全部资源需求时,才一次性地将所申请的资源全部分配给该进程. 由于运行的进程已占有它所需要的全部资源所以不会发生占有资源有申请资源的现象, 因此不会发生死锁. 但是,这种策略也有如下缺点:</p>\n<ul>\n<li>在许多情况下,一个进程在执行之前不可能知道它所需要的全部资源. 这是由于进程在执行时是动态的,不可预测的.</li>\n<li>资源利用率低.无论所分资源何时用到,一个进程只有在占有所需要的全部资源后才能执行.即使有些资源最后才被该进程用到一次,但该进程生存期间一直占有他们,造成长期占着不用的状况.这显然是一种极大的资源浪费.</li>\n<li>降低了进程的并发性.因为资源有限,又加上存在浪费,能分配到所需全部资源的进程个数就必然少了.</li>\n</ul>\n</li>\n<li>打破循环等待条件:<strong>实行资源有序分配策略</strong>.采用这种策略,即把资源事先分类编号,按号分配,使进程在申请,占用资源是不会形成环路.所有进程对资源的请求必须严格按字元序号递增的顺序提出.进程占用了小号资源,才能申请大耗资源,就不会产生环路, 从而预防了死锁.这种策略与前面的策略相比, 资源的利用率和系统的吞吐量都有了很大的提高,但是也存在一下缺点:<ul>\n<li>限制了进程对资源的请求,同事给系统中所有资源合理编号也是件困难时,并增加了系统的开销.</li>\n<li>为了遵循按编号申请的次序,在不使用的资源也需要提前申请,从而增加了进程对资源的占用时间.</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"死锁避免\"><a href=\"#死锁避免\" class=\"headerlink\" title=\"死锁避免\"></a>死锁避免</h4><ul>\n<li>银行家算法<br>系统给当前进程分配资源时,先检查是否安全.<br>在满足当前的进程X资源申请后,是否还能有足够的资源去满足下一个距最大资源需求最近的进程(如某进程最大需要5个单位资源,已拥有1个,还需4个),若可以满足,则继续检查下一个距最大资源需求最近的进程,若均能满足所有进程,则表示为安全,可以允许给当前进程X分配其所需的资源申请,否则让该进程X进入等待.</li>\n<li>哲学家进餐问题</li>\n</ul>\n<h4 id=\"进程和线程的区别\"><a href=\"#进程和线程的区别\" class=\"headerlink\" title=\"[-]进程和线程的区别\"></a>[-]进程和线程的区别</h4><blockquote>\n<p>定义<br><strong>进程</strong>是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.<br><strong>线程</strong>是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.<br>关系<br>一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.<br>相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。<br>区别<br>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p>\n<blockquote>\n<p>简而言之,一个程序至少有一个进程,一个进程至少有一个线程.<br>线程的划分尺度小于进程，使得多线程程序的并发性高。<br>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。<br>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。<br>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。<br>优缺点<br>线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。</p>\n</blockquote>\n</blockquote>\n<h4 id=\"进程间通信\"><a href=\"#进程间通信\" class=\"headerlink\" title=\"[]进程间通信\"></a>[]进程间通信</h4><p>####### 为什么需要进程间通信？？</p>\n<p>进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程）之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源（例如打开的文件描述符）。</p>\n<p>但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程间通信( IPC：Inter Processes Communication )。</p>\n<p>进程间通信的目的：</p>\n<ul>\n<li>数据传输：一个进程需要将它的数据发送给另一个进程。</li>\n<li>通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。</li>\n<li>资源共享：多个进程之间共享同样的资源。为了做到这一点，需要内核提供互斥和同步机制。</li>\n<li>进程控制：有些进程希望完全控制另一个进程的执行（如 Debug 进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。<br>Linux 操作系统支持的主要进程间通信的通信机制：</li>\n</ul>\n<p><img src=\"../images/StudyOfInterview/jcjtx.jpg\" alt=\"进程间通信-1\" title=\"进程间通信\"></p>\n<h6 id=\"进程间通信-IPC-介绍\"><a href=\"#进程间通信-IPC-介绍\" class=\"headerlink\" title=\"进程间通信(IPC)介绍\"></a><a href=\"https://www.cnblogs.com/CheeseZH/p/5264465.html\" target=\"_blank\" rel=\"noopener\">进程间通信(IPC)介绍</a></h6><h4 id=\"进程调度\"><a href=\"#进程调度\" class=\"headerlink\" title=\"[]进程调度\"></a>[]进程调度</h4><h4 id=\"进程的内存分布\"><a href=\"#进程的内存分布\" class=\"headerlink\" title=\"[]进程的内存分布\"></a>[]进程的内存分布</h4><table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>代码段</td>\n<td>全局常量（const）、字符串常量、函数以及编译时可决定的某些东西</td>\n</tr>\n<tr>\n<td>数据段</td>\n<td>存储初始化的全局变量 和 初始化的静态变量(全局和局部)</td>\n</tr>\n<tr>\n<td>BSS段</td>\n<td>存储未初始化的全局变量 和 未初始化的静态变量(全局和局部)</td>\n</tr>\n<tr>\n<td>堆</td>\n<td>动态分配的区域（malloc、new等）</td>\n</tr>\n<tr>\n<td>栈</td>\n<td>l临时声明的局部变量(初始化以及未初始化的,但不包含静态变量),局部常量(const)</td>\n</tr>\n<tr>\n<td>命令行参数和环境变量</td>\n<td>顾名思义</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"https://images2015.cnblogs.com/blog/978007/201702/978007-20170208113706760-1208301174.png\" alt=\"\"></p>\n<h4 id=\"进程调度-1\"><a href=\"#进程调度-1\" class=\"headerlink\" title=\"进程调度\"></a>进程调度</h4><ul>\n<li><p>先来先服务 （FCFS，first come first served）<br>在所有调度算法中，最简单的是非抢占式的FCFS算法。<br>算法原理：进程按照它们请求CPU的顺序使用CPU.就像你买东西去排队，谁第一个排，谁就先被执行，在它执行的过程中，不会中断它。当其他人也想进入内存被执行，就要排队等着，如果在执行过程中出现一些事，他现在不想排队了，下一个排队的就补上。此时如果他又想排队了，只能站到队尾去。<br>算法优点：易于理解且实现简单，只需要一个队列(FIFO)，且相当公平<br>算法缺点：比较有利于长进程，而不利于短进程，有利于CPU 繁忙的进程，而不利于I/O 繁忙的进程</p>\n</li>\n<li><p>最短作业优先（SJF, Shortest Job First）<br>短作业优先（SJF, Shortest Job First）又称为“短进程优先”SPN(Shortest Process Next)；这是对FCFS算法的改进，其目标是减少平均周转时间。<br>算法原理：对预计执行时间短的进程优先分派处理机。通常后来的短进程不抢先正在执行的进程。<br>算法优点：相比FCFS 算法，该算法可改善平均周转时间和平均带权周转时间，缩短进程的等待时间，提高系统的吞吐量。<br>算法缺点：对长进程非常不利，可能长时间得不到执行，且未能依据进程的紧迫程度来划分执行的优先级，以及难以准确估计进程的执行时间，从而影响调度性能。</p>\n</li>\n<li><p>最高响应比优先法(HRRN，Highest Response Ratio Next)<br>最高响应比优先法(HRRN，Highest Response Ratio Next)是对FCFS方式和SJF方式的一种综合平衡。FCFS方式只考虑每个作业的等待时间而未考虑执行时间的长短，而SJF方式只考虑执行时间而未考虑等待时间的长短。因此，这两种调度算法在某些极端情况下会带来某些不便。HRN调度策略同时考虑每个作业的等待时间长短和估计需要的执行时间长短，从中选出响应比最高的作业投入执行。这样，即使是长作业，随着它等待时间的增加，W / T也就随着增加，也就有机会获得调度执行。这种算法是介于FCFS和SJF之间的一种折中算法。<br>算法原理：响应比R定义如下： R =(W+T)/T = 1+W/T<br>其中T为该作业估计需要的执行时间，W为作业在后备状态队列中的等待时间。每当要进行作业调度时，系统计算每个作业的响应比，选择其中R最大者投入执行。<br>算法优点：由于长作业也有机会投入运行，在同一时间内处理的作业数显然要少于SJF法，从而采用HRRN方式时其吞吐量将小于采用SJF 法时的吞吐量。<br>算法缺点：由于每次调度前要计算响应比，系统开销也要相应增加。</p>\n</li>\n<li><p>时间片轮转算法（RR，Round-Robin）<br>该算法采用剥夺策略。时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称RR调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。<br>算法原理：让就绪进程以FCFS 的方式按时间片轮流使用CPU 的调度方式，即将系统中所有的就绪进程按照FCFS 原则，排成一个队列，每次调度时将CPU 分派给队首进程，让其执行一个时间片，时间片的长度从几个ms 到几百ms。在一个时间片结束时，发生时钟中断，调度程序据此暂停当前进程的执行，将其送到就绪队列的末尾，并通过上下文切换执行当前的队首进程，进程可以未使用完一个时间片，就出让CPU（如阻塞）。<br>算法优点：时间片轮转调度算法的特点是简单易行、平均响应时间短。<br>算法缺点：不利于处理紧急作业。在时间片轮转算法中，时间片的大小对系统性能的影响很大，因此时间片的大小应选择恰当<br>怎样确定时间片的大小：</p>\n<ul>\n<li>时间片大小的确定<br>1.系统对响应时间的要求<br>2.就绪队列中进程的数目<br>3.系统的处理力</li>\n</ul>\n</li>\n<li><p>多级反馈队列(Multilevel Feedback Queue)<br>多级反馈队列调度算法是一种CPU处理机调度算法，UNIX操作系统采取的便是这种调度算法。<br>多级反馈队列调度算法描述：<br>　　1、进程在进入待调度的队列等待时，首先进入优先级最高的Q1等待。<br>　　2、首先调度优先级高的队列中的进程。若高优先级中队列中已没有调度的进程，则调度次优先级队列中的进程。例如：Q1,Q2,Q3三个队列，只有在Q1中没有进程等待时才去调度Q2，同理，只有Q1,Q2都为空时才会去调度Q3。<br>　　3、对于同一个队列中的各个进程，按照时间片轮转法调度。比如Q1队列的时间片为N，那么Q1中的作业在经历了N个时间片后若还没有完成，则进入Q2队列等待，若Q2的时间片用完后作业还不能完成，一直进入下一级队列，直至完成。<br>　　4、在低优先级的队列中的进程在运行时，又有新到达的作业，那么在运行完这个时间片后，CPU马上分配给新到达的作业（抢占式）。<br>　　在多级反馈队列调度算法中，如果规定第一个队列的时间片略大于多数人机交互所需之处理时间时，便能够较好的满足各种类型用户的需要。</p>\n</li>\n</ul>\n<h3 id=\"计算机网络\"><a href=\"#计算机网络\" class=\"headerlink\" title=\"计算机网络\"></a>计算机网络</h3><h4 id=\"TCP和UDP区别\"><a href=\"#TCP和UDP区别\" class=\"headerlink\" title=\"[]TCP和UDP区别\"></a>[]TCP和UDP区别</h4><table>\n<thead>\n<tr>\n<th></th>\n<th>TCP</th>\n<th>UDP</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>传输</td>\n<td>提供面向连接的、可靠地数据流传输</td>\n<td>提供的是非面向连接的、不可靠的数据流传输</td>\n</tr>\n<tr>\n<td>传输单位</td>\n<td>TCP报文段</td>\n<td>用户数据报</td>\n</tr>\n<tr>\n<td>安全性</td>\n<td>TCP注重数据安全性</td>\n<td>UDP数据传输快，因为不需要链接等待，少了许多操作，但是起安全性却一般</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>协议</td>\n<td>FTP:定义了文件传输协议,使用21端口;</td>\n<td>DNS: 用于域名解析服务,将域名地址转换成IP地址.DNS用的是53号端口.</td>\n</tr>\n<tr>\n<td>协议</td>\n<td>Telnet: 一种用于远程登录的端口,使用23端口,用户可以以自己的身份远程连接到计算机上,可提供基于DOS模式下的通信服务</td>\n<td>SNMP: 简单网络管理协议,使用161端口,是用来管理网络十倍的.由于网络设备很多,无连接的服务就体现出其优势.</td>\n</tr>\n<tr>\n<td>协议</td>\n<td>SMTP: 邮件传送协议,用于发送邮件.服务端开放的是25号端口</td>\n<td>TFTP(Trival File Transfer Protocal): 简单文件传输协议,该协议在熟知端口69上使用UDP服务</td>\n</tr>\n<tr>\n<td>协议</td>\n<td>POP3: 它是和SMTP对应,POP3用于接收邮件.POP3协议所用的是110端口</td>\n<td></td>\n</tr>\n<tr>\n<td>协议</td>\n<td>HTTP: 是从Web服务器传输超文本到本地浏览器的传送协议</td>\n</tr>\n</tbody>\n</table>\n<p><a href=\"http://blog.csdn.net/li_ning_/article/details/52117463\" target=\"_blank\" rel=\"noopener\">详细介绍,戳&lt;&lt;&lt;–</a></p>\n<blockquote>\n<p>TCP与UDP区别总结：<br>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接<br>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保   证可靠交付<br>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）<br>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信<br>TCP首部开销20字节;UDP的首部开销小，只有8个字节<br>TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</p>\n</blockquote>\n<h4 id=\"TCP三次握手-四次挥手\"><a href=\"#TCP三次握手-四次挥手\" class=\"headerlink\" title=\"[-]TCP三次握手/四次挥手\"></a>[-]TCP三次握手/四次挥手</h4><p><a href=\"http://blog.csdn.net/qzcsu/article/details/72861891\" target=\"_blank\" rel=\"noopener\">详细介绍,戳&lt;&lt;&lt;—</a><br><a href=\"https://www.cnblogs.com/myvin/p/4862167.html\" target=\"_blank\" rel=\"noopener\">更亲民的介绍,戳&lt;&lt;&lt;—</a></p>\n<p>建立连接的过程是利用客户服务器模式,假设主机A为客户端,主机B为服务端</p>\n<ul>\n<li>TCP的三次握手过程：主机Ａ向Ｂ发送链接请求; -&gt; 主机B对收到的主机A的报文段进行确认; -&gt; 主机A再次对主机B的确认进行确认</li>\n<li>采用三次握手是为了防止失效的链接请求报文段突然有传送到主机B,因而产生错误.失效的链接请求报文段是指: 主机A出的连接请求没有收到主机B的确认,于是经过一段时间后,主机A又重新向主机B发送连接请求,且建立成功,顺序完成数据传输. 考虑这样一个特殊情况,主机A第一次发送的连接请求并没有丢失,而是因为网络节点导致延迟到达主机B,主机B以为是主机又发起的新连接,于是主机B同意连接,并向主机A发回确认,但是此时主机A根本不会理会,主机B就一直在等待主机A发送数据，导致主机Ｂ的资源浪费．</li>\n<li>采用两次握手不行, 原因就是上面说的实效的连接请求的特殊情况.</li>\n</ul>\n<h4 id=\"TCP里的一些机制\"><a href=\"#TCP里的一些机制\" class=\"headerlink\" title=\"TCP里的一些机制\"></a>TCP里的一些机制</h4><h4 id=\"OSI-TCP-IP-五层协议的体系结构-以及各层协议\"><a href=\"#OSI-TCP-IP-五层协议的体系结构-以及各层协议\" class=\"headerlink\" title=\"OSI,TCP/IP,五层协议的体系结构,以及各层协议\"></a>OSI,TCP/IP,五层协议的体系结构,以及各层协议</h4><p>OSI分层(7层): 物理层,数据链路层,网络层,传输层,会话层,表示层,应用层.<br>TCP/IP分层(4层): 网络接口层,网际层,运输层,应用层.<br>五层协议(5层): 物理层,数据链路层,网络层,运输层,应用层.</p>\n<p>每一层的协议如下:<br>物理层: RJ45,CLOCK,IEEE802.3(中继器,集线器)<br>数据链路: POP,FR,HDLC,VLAN,MAX(网桥,交换机)<br>网络层: IP,UCMP,ARP,RARP,OSPF,IPX,RIP,IGRP(路由器)<br>传输层: TCP,UDP,SPX<br>会话层: NFS,SQL,NETBIOS,RPC<br>表示层: JPEG,MPEG,ASII<br>应用层: FTP,DNS,Telnet,SMTP,HTTP,WWW,NFS</p>\n<p>每一层的作用如下</p>\n<p>物理层: 通过媒介传输比特,确定机械及电器规范(比特Bit)<br>数据链路: 将比特组装成帧和点到点的传递(帧Frame)<br>网络层: 负责数据包从源到宿的传递和网际互联(包PackeT)<br>传输层: 提供端到端的可靠报文传递和错误回复(段Segment)<br>会话层: 简历,管理和中智慧化(会话协议数据单元SPDU)<br>表示层: 对数据进行翻译,加密和压缩(表示协议数据单元PPDU)<br>应用层: 允许方位OSI环境的手段(应用协议数据单元APDU)</p>\n<h4 id=\"IP地址的分类\"><a href=\"#IP地址的分类\" class=\"headerlink\" title=\"IP地址的分类\"></a>IP地址的分类</h4><p>A类地址: 以0开头, 第一个字节范围1~127(1.0.0.0~127.255.255.255);<br>B类地址: 以10开头, 第一个字节范围128~191(128.0.0.0~191.255.255.255);<br>C类地址: 以110开头, 第一个字节范围192~223(192.0.0.0~223.255.255.255);<br>D类地址: 以1110开头, 第一个字节范围224~239(224.0.0.0~239.255.255.255);<br>E类地址: 保留</p>\n<p>一种A,B,C是基本类,D,E类作为多播和保留使用.<br>以下是留用的内部私有地址:<br>A类 10.0.0.0  – 10.255.255.255<br>B类 182.16.00 – 192.31.255.255<br>C类 192.168.0.0 – 192.168.255.255</p>\n<p>IP地址与子网掩码相与(&amp;)得到网络号<br>ip 192.168.2.110<br>&amp;<br>submask:255.255.255.0<br>.———————————<br>网络号 192.168.2.0</p>\n<p>注: 主机号,全是0的网络号(例如192.168.2.0),主机号全为1的为广播地址(192.168.2.255)</p>\n<h4 id=\"ARP是地址解析协议-简单语言解释一下工作原理\"><a href=\"#ARP是地址解析协议-简单语言解释一下工作原理\" class=\"headerlink\" title=\"ARP是地址解析协议,简单语言解释一下工作原理.\"></a>ARP是地址解析协议,简单语言解释一下工作原理.</h4><ul>\n<li>首先,每个主机都会在自己的ARP缓冲区中建立一个ARP列表,以表示IP地址和MAC地址之间的对应关系.</li>\n<li>当源主机要发送数据时,首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址,如果有,则直接发送数据,如果没有,就向本网段的所有主机发送ARP数据包,该数据包包括的内容有: 源主机的IP地址,源主机的MAC地址,目的主机的IP地址.</li>\n<li>当本网络中的所有主机收到该ARP数据包时,首先检查数据包中的IP地址是否是自己的IP地址,如果不是,则忽略该数据包,,如果是,则首先从数据包中去除源主机的IP和MAC地址写入到ARP列表中,如果已经存在,则覆盖,然后将自己的MAC地址写入ARP响应包中,告诉源主机自己是它想要找的MAC地址</li>\n<li>源主机收到ARP响应后.将目的主机的IP和MAC地址写入ARP列表,并利用此信息发送数据. 如果源主机一直没有收到ARP相应数据包,表示ARP查询失败.</li>\n</ul>\n<p>广播发送ARP请求,单播发送ARP相应. </p>\n<h4 id=\"RARP协议\"><a href=\"#RARP协议\" class=\"headerlink\" title=\"RARP协议\"></a>RARP协议</h4><p>RARP是逆地址解析协议,作用是完成硬件地址到IP地址的映射,主要用于无盘工作站,因为给无盘工作站配置的IP地址不能保存.<br>工作流畅: 在网络中配置一台RARP服务器,里面保存者IP地址和MAC地址的映射关系,当无盘工作站启动后,就封装一个RARP数据包,里面有其MAC地址,然后广播到网络上去,当服务器收到请求包后,就查找对应的MAC地址的IP地址装入响应报文中发回给请求者. 因为需要广播请求报文,因此RARP只能用于具有广播能力的网络.</p>\n<h4 id=\"各种协议的介绍\"><a href=\"#各种协议的介绍\" class=\"headerlink\" title=\"各种协议的介绍\"></a>各种协议的介绍</h4><ul>\n<li><strong>ICMP协议</strong>: 因特网控制报文协议.它是TCP/IP协议族的一个自协议,用于在IP主机/路由器之间传递控制消息.</li>\n<li><strong>TFTP协议</strong>: 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议,提供不复杂,开销不大的文件传输服务.</li>\n<li><strong>HTTP协议</strong>: 超文本传输协议,是一个属于应用层的面向对象的协议,由于其简捷,快速的方式,适用于分布式超媒体信息系统</li>\n<li><strong>NAT协议</strong>: 网络地址转换属介入广域网(WAN)技术,是一种将私有(保留)地址转化为合法IP地址的转换技术.</li>\n<li><strong>DHCP协议</strong>: 动态主机配置协议,给用户或者内部网络管理员作为对所有计算机作中央管理的手段.</li>\n</ul>\n<h4 id=\"在浏览器中输入www-baidu-com后执行的全部过程\"><a href=\"#在浏览器中输入www-baidu-com后执行的全部过程\" class=\"headerlink\" title=\"在浏览器中输入www.baidu.com后执行的全部过程\"></a>在浏览器中输入<a href=\"http://www.baidu.com后执行的全部过程\" target=\"_blank\" rel=\"noopener\">www.baidu.com后执行的全部过程</a></h4><ul>\n<li><ol>\n<li>客户端浏览器通过DNS解析到<a href=\"http://www.baidu.com的IP地址为220.181.27.48\" target=\"_blank\" rel=\"noopener\">www.baidu.com的IP地址为220.181.27.48</a>, 通过这个IP地址找到客户端到服务器的路径. 客户端浏览器发起一个HTTP回话到220.181.27.48, 然后通过TCP进行封装数据包, 输入到网络层.</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>在客户端的传输层,把HTTP回话请求分成报文段,添加源和目的端口, 如服务器使用80端口监听客户端的请求, 客户端有系统随机选择一个端口如5000, 与服务器进行交换,服务器吧相应的请求返回给客户端的5000端口. 然后使用IP层的IP地址查找目的端.</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>客户端的网络层不用关心应用层或者传输层的东西, 主要做到的是通过查找路由表确定如何到达服务器,期间可能经过多个路由器,这些都是有路由器来完成的工作, 我不做过多的描述, 无非就是通过查找路由表决定通过哪个路径到达服务器.</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>客户端的链路层, 包通过链路层发送到路由器, 通过邻居协议查找给定IP地址的MAC地址,然后发送ARP请求查找到目的地址, 如果得到回应后就可以使用ARP的请求应答交换的IP数据包,现在就可以传输了,然后发送IP数据包到达服务器的地址.</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"DNS域名系统-简单描述其工作原理\"><a href=\"#DNS域名系统-简单描述其工作原理\" class=\"headerlink\" title=\"DNS域名系统,简单描述其工作原理\"></a>DNS域名系统,简单描述其工作原理</h4><p>当DNS客户机需要在程序中使用名称时, 它会查询DNS服务器来解析该名称. 客户机发送的每条查询信息包括三条信息: 包括: 指定的DNS域名,DNS域名的指定类型. 基于UDP服务,端口53. 该应用一般不直接为用户使用, 而是为其他应用服务,如 HTTP,SMTO等在其中需要完成主机名到地址的转换.</p>\n<h4 id=\"了解交换机-路由器-网关的概念-并知道各自的用途\"><a href=\"#了解交换机-路由器-网关的概念-并知道各自的用途\" class=\"headerlink\" title=\"了解交换机,路由器,网关的概念, 并知道各自的用途\"></a>了解交换机,路由器,网关的概念, 并知道各自的用途</h4><ul>\n<li><p><strong>交换机</strong><br>在计算机网络系统中,交换机是针对共享工作模式的弱点而推出的.交换机拥有一条高带宽的背部总线和内部交换矩阵.交换机的所有的端口都挂接在这条背部总线上,当控制电路收到数据包以后,处理端口会查找内存中的地址对照表以确定目的端口.目的MAC若不存在,交换机才广播到所有的端口, 接手端口回应后交换机会’学习’新的地址,并把它添加入内部地址表中.<br>交换机工作于OSI参考模型的第二层,即数据链路层. 交换机内部的CPU会在每个端口成功连接时,通过ARP协议学习它的MAC地址,保存成一张ARP表. 在今后的通讯中, 发往该MAC地址的数据包将仅送往其对应的端口,而不是所有端口. 因此,交换机可用于划分数据链路层广播,即冲突域; 但它不能划分网络层广播, 即广播域.<br>交换机被广泛应用于二层网络交换,俗称’二层交换机’.<br>交换机的种类有: 二层交换机,三层交换机,四层交换机,七层交换机分别工作在OSI七层模型中的第二层,第三层,第四层和第七层,并因此而得名.</p>\n</li>\n<li><p>路由器<br>路由器(Router)是一种计算机网络设备,提供了路由与传送两种重要机制,可以决定数据包从来源端到目的端所经过的路由路径(host到host之间的传输路径),这个过程称为<strong>路由</strong>; 将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行),这成为<strong>传动</strong>. 路由工作在OSI模型的第三层 -&gt; 即网络层,例如网际协议.<br>路由器的一个作用是连通不同的网络另一个作用是选择信息传送的线路. 路由器与交换机的差别, 路由器是属于OSI第三层的产品,交换机是OSI第二层的产品(这里至二层交换机)</p>\n</li>\n<li><p>网关<br>网关(Gateway), 网关顾名思义就是连接两个网络的设备,区别与路由器(由于历史的原因,许多有关TCP/IP的文献曾经把网络层使用的路由器成为网关,在今天很多局域网采用的都是路由器来接入网络,因此现在通常指的网关就是路由器的IP),经常在家庭中或者小型企业网络中使用,用于连接局域网和Internet. 网关也经常把一种协议转成另一种协议的设备,比如语音网关.<br>在传统TCP/IP术语中,网络设备只分成两种,一种为网关(Gateway),另一种称为主机(host). 网关能在网络间传递数据包,但主机不能传送数据包.在主机(又称终端系统,end system)中,数据包需经过TCP/IP四层协议处理,但是在网关(又称中介系统,intermediate system)只需要到达网际层(Internet layer),决定路径之后就可以传送. 在当时,网关(Gateway)和路由(Router)还没有区别.<br>在现代网络术语中,网关(Gateway)和路由(Router)的定义不同,网关(Gateway)能在不同协议间移动数据,而路由器(Router)是在不同网络间移动数据,相当于传统所说的IP网关(IP Gateway).<br>网关是连接两个网络的设备,对于语音网关来说,它可以连接PSTN网络和以太网,这就相当于VOIP,把不同电话的模拟信号通过网关而转换成数字信号,而且加入协议再去传输. 在到了接收端的时候再通过网关还原成模拟的电话信号,最后才能在电话机上听到.<br>对于以太网中的网关只能转发三层以上数据包,这一点和路由是一样的.而不同的是网关中并没有路由表,他只能按照预先设定的不同网段来进行转发.网关最重要的一层就是端口映射,子网内用户在外网看来只是外网的IP地址对应着不同的端口,这样看来就会保护子网内的用户.</p>\n</li>\n</ul>\n<h3 id=\"C-C\"><a href=\"#C-C\" class=\"headerlink\" title=\"C/C++\"></a>C/C++</h3><h4 id=\"BSS段的功能\"><a href=\"#BSS段的功能\" class=\"headerlink\" title=\"BSS段的功能\"></a>BSS段的功能</h4><h4 id=\"char-p1-“123”-与char-p2-”123”-其中p1-p2区别\"><a href=\"#char-p1-“123”-与char-p2-”123”-其中p1-p2区别\" class=\"headerlink\" title=\"char *p1 = “123” 与char p2[]=”123”,其中p1,p2区别\"></a>char *p1 = “123” 与char p2[]=”123”,其中p1,p2区别</h4><p>答: 常量是存储在内存中的,<br>*p1 是指针 指向”123”中的”1”的地址<br>p2[] 是数组 本质是在堆栈中定义的一段内存</p>\n<h4 id=\"sizeof-struct-char-c-int-a\"><a href=\"#sizeof-struct-char-c-int-a\" class=\"headerlink\" title=\"sizeof(struct{char c;int a;}) = ?\"></a>sizeof(struct{char c;int a;}) = ?</h4><p>答: 4</p>\n<p>内存对其,整体占得内存一定是<strong>最大数据元素的整数倍</strong>.<br>这里最大的是int(4字节)整体就是(4*n字节)<br>大概是这个样子<br>|int|char|<br>△△△△|△—|</p>\n<h4 id=\"多线程编程经验\"><a href=\"#多线程编程经验\" class=\"headerlink\" title=\"多线程编程经验\"></a>多线程编程经验</h4><h4 id=\"C-网络编程\"><a href=\"#C-网络编程\" class=\"headerlink\" title=\"C++网络编程\"></a>C++网络编程</h4><h4 id=\"C-11新增了什么-了解的有哪些\"><a href=\"#C-11新增了什么-了解的有哪些\" class=\"headerlink\" title=\"C++11新增了什么,了解的有哪些.\"></a>C++11新增了什么,了解的有哪些.</h4><h4 id=\"√-const关键字作用\"><a href=\"#√-const关键字作用\" class=\"headerlink\" title=\"[√]const关键字作用.\"></a>[√]const关键字作用.</h4><p><a href=\"https://www.cnblogs.com/chogen/p/4574118.html\" target=\"_blank\" rel=\"noopener\">好文</a></p>\n<h4 id=\"多态-虚函数\"><a href=\"#多态-虚函数\" class=\"headerlink\" title=\"[-]多态/虚函数\"></a>[-]多态/虚函数</h4><p><a href=\"https://www.cnblogs.com/qiaoconglovelife/p/5128523.html\" target=\"_blank\" rel=\"noopener\">介绍</a></p>\n<h3 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h3><h4 id=\"√-HashMap\"><a href=\"#√-HashMap\" class=\"headerlink\" title=\"[√]HashMap\"></a>[√]HashMap</h4><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653191907&amp;idx=1&amp;sn=876860c5a9a6710ead5dd8de37403ffc&amp;chksm=8c990c39bbee852f71c9dfc587fd70d10b0eab1cca17123c0a68bf1e16d46d71717712b91509&amp;scene=38#wechat_redirect\" target=\"_blank\" rel=\"noopener\">介绍链接</a></p>\n<h4 id=\"Synchronze-和-Lock的区别和用法\"><a href=\"#Synchronze-和-Lock的区别和用法\" class=\"headerlink\" title=\"Synchronze 和 Lock的区别和用法\"></a>Synchronze 和 Lock的区别和用法</h4><table>\n<thead>\n<tr>\n<th>Synchronze(隐式锁)</th>\n<th>Lock(显示锁)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>在需要同步的对象中加入此控制,synchronize可以加在方法上,也可以加在特定代码块中,括号中表示需要所得对象</td>\n<td>需要显示指定起始位置和终止位置.一般使用ReentrantLock类作为锁,多个线程中必须要使用一个ReentrantLock类作为对象才能保证锁的生效.且在加锁和解锁处需要通过lock()和unlock()显示指出.所以一般会在finally块中写unlock()以防死锁</td>\n</tr>\n<tr>\n<td>托管给JVM执行的</td>\n<td>java写的控制锁代码</td>\n</tr>\n<tr>\n<td>采用的的CPU的悲观锁机制,即线程获得的是独占锁.独占锁意味着其他线程只能依靠阻塞来等待线程释放锁</td>\n<td>乐观锁方式,每次不加锁而是假设没有冲突而去完成某项操作,如果因为冲突失败就重试,直到成功为止.乐观锁实现的机制就是CAS操作(Compare and Swap)</td>\n</tr>\n</tbody>\n</table>\n<p>Ps: 在Java1.5中, syncchronize是性能低效的,因为这是一个重量级操作,需要调用操作接口,导致有可能加锁消耗的系统时间比加锁以外的操作还多. 相比之下使用Java提供的Lock对象,性能更高一些.但是到了Java1.6,发生了变化. synchronize在语义上很清晰,可以进行很多优化,有适应自旋,锁消除,锁粗化,轻量级锁,偏向锁等等. 导致在Java1.6上synchronize的性能并不比Lock差.</p>\n<h4 id=\"乐观锁-悲观锁\"><a href=\"#乐观锁-悲观锁\" class=\"headerlink\" title=\"乐观锁,悲观锁\"></a>乐观锁,悲观锁</h4><ul>\n<li><strong>乐观锁（ Optimistic Locking ）</strong> 相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。而乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</li>\n<li><strong>悲观锁（Pessimistic Lock）</strong>，正如其名，具有强烈的独占和排他特性。它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</li>\n</ul>\n<h3 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h3><h4 id=\"进程的内存分布-1\"><a href=\"#进程的内存分布-1\" class=\"headerlink\" title=\"进程的内存分布\"></a>进程的内存分布</h4><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>代码段</td>\n<td>可执行代码</td>\n</tr>\n<tr>\n<td>数据段</td>\n<td>已初始化全局变量,已初始化全局静态变量,局部静态变量,常量数据</td>\n</tr>\n<tr>\n<td>BSS段</td>\n<td>未初始化全局变量,未初始化全局静态变量</td>\n</tr>\n<tr>\n<td>栈</td>\n<td>局部变量,函数参数</td>\n</tr>\n<tr>\n<td>堆</td>\n<td>动态内存分配</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"那个命令可以常看内存使用情况\"><a href=\"#那个命令可以常看内存使用情况\" class=\"headerlink\" title=\"那个命令可以常看内存使用情况\"></a>那个命令可以常看内存使用情况</h4><p>答:<br>top<br>free [-h]<br><!-- ps aux --sort -rss --></p>\n<h4 id=\"touch有什么用\"><a href=\"#touch有什么用\" class=\"headerlink\" title=\"touch有什么用\"></a>touch有什么用</h4><p>答: 两个作用</p>\n<ul>\n<li>一,用于吧已存在文件的时间标签更新为系统当前的时间(默认方式),它们的数据将原封不动地保留下来;</li>\n<li>二,用来创建新的空文件</li>\n</ul>\n<h4 id=\"僵尸进程-孤儿进程-守护进程\"><a href=\"#僵尸进程-孤儿进程-守护进程\" class=\"headerlink\" title=\"僵尸进程,孤儿进程,守护进程\"></a>僵尸进程,孤儿进程,守护进程</h4><p><a href=\"https://blog.csdn.net/gogokongyin/article/details/51340432\" target=\"_blank\" rel=\"noopener\">详细介绍</a></p>\n<ul>\n<li><p><strong>僵尸进程:</strong> 在fork()/execve()过程中,假设子进程结束时父进程仍存在,而父进程fork()之前既没安装SIGCHLD信号处理函数调用waitpid()等待子进程结束,又没有显示忽略该信号,则子进程成为僵尸进程.</p>\n</li>\n<li><p><strong>孤儿进程:</strong> 一个父进程退出,而它的一个或多个子进程还在运行,那么那些子进程将成为孤儿进程. 孤儿进程将被init进程(进程号为1)所收养,并由init进程对他们完成状态收集工作. </p>\n</li>\n<li><p><strong>守护进程:</strong> Linux系统中的守护进程是一种运行在后台的进程. 而守护进程,也就是通常说的Daemon进程. 它通常独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件. Linux大多数服务器进程就是用这种守护进程实现的, 例如Web服务.守护进程常常在系统引导装入时启动, 在系统关闭时终止. 守护进程最大的特点是运行在后台,与终端无连接, 除非特殊情况下, 用户不能操作守护进程.</p>\n</li>\n</ul>\n<h3 id=\"python\"><a href=\"#python\" class=\"headerlink\" title=\"python\"></a>python</h3><h3 id=\"大数据\"><a href=\"#大数据\" class=\"headerlink\" title=\"大数据\"></a>大数据</h3><h4 id=\"MongoDB-vs-Redis\"><a href=\"#MongoDB-vs-Redis\" class=\"headerlink\" title=\"MongoDB vs Redis\"></a>MongoDB vs Redis</h4><p>MongoDB和Redis都是NoSQL，采用结构型数据存储。二者在使用场景中，存在一定的区别，这也主要由于二者在内存映射的处理过程，持久化的处理方法不同。</p>\n<p> MongoDB建议集群部署，更多的考虑到集群方案，Redis更偏重于进程顺序写入，虽然支持集群，也仅限于主-从模式。</p>\n<table>\n<thead>\n<tr>\n<th>比较指标</th>\n<th>MongoDB(v2.4.9)</th>\n<th>Redis(v2.4.17)</th>\n<th>比较说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>实现语言</td>\n<td>c++</td>\n<td>c/c++</td>\n<td>-</td>\n</tr>\n<tr>\n<td>协议</td>\n<td>BSON,自定义二进制</td>\n<td>类telnet</td>\n<td>-</td>\n</tr>\n<tr>\n<td>性能</td>\n<td>依赖内存,TPS{(transaction per second)代表每秒执行的事务数量}较高</td>\n<td>依赖内存,TPS非常高</td>\n<td>Redis优于MongoDB</td>\n</tr>\n<tr>\n<td>可操作性</td>\n<td>丰富的数据表达,索引;最类似于关系型数据库,支持丰富的查询语句</td>\n<td>数据丰富,较少的IO</td>\n<td>MongoDB优于Redis</td>\n</tr>\n<tr>\n<td>内存及存储</td>\n<td>适合大数据量存储,依赖系统虚拟内存,采用镜像文件存储;内存占用率比较高,官方建议独立部署在64位系统</td>\n<td>Redis2.0后支持虚拟内存特性(VM) 突破物理内存限制;数据可以设置时效性,类似于memcache</td>\n<td>不同的应用场景,各有千秋</td>\n</tr>\n<tr>\n<td>可用性</td>\n<td>支持master-slave,replicatset(内部采用paxos选举算法,自动故障恢复),auto sharding机制,对客户端屏蔽了故障转移和切片机制</td>\n<td>依赖客户端来实现分布式读写;主从复制时,每次从节点重新连接主节点都要依赖整个快照,无增量复制;不支持auto sharding,需要依赖程序设定一致性hash机制</td>\n<td>MongoDB优于Redis；单点问题上,MongoDB应用简单,相对用户透明,Redis比较复杂,需要客户端主动解决.(MongoDB一般使用replicasets和sharding相结合,replicasets侧重高可用性以及高可靠,sharding侧重性能,水平扩展)</td>\n</tr>\n<tr>\n<td>可靠性</td>\n<td>从1.8版本后,采用binlog方式(类似Mysql) 支持持久化</td>\n<td>依赖快照进行持久化;AOF增强可靠性;增强性的同时,影响访问性能</td>\n<td>-</td>\n</tr>\n<tr>\n<td>一致性</td>\n<td>不支持事务,靠客户端保证</td>\n<td>支持事务,比较脆,仅能保证事务中的操作按顺序执行</td>\n<td>Redis优于MongoDB</td>\n</tr>\n<tr>\n<td>数据分析</td>\n<td>内置数据分析功能(mapreduce)</td>\n<td>不支持</td>\n<td>MongoDB优于Redis</td>\n</tr>\n<tr>\n<td>应用场景</td>\n<td>海量数据的访问效率提升</td>\n<td>较小数据量的性能和运算</td>\n<td>MongoDB优于Redis</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h3><h4 id=\"数据库事务的四大特性-ACID\"><a href=\"#数据库事务的四大特性-ACID\" class=\"headerlink\" title=\"数据库事务的四大特性(ACID)\"></a>数据库事务的四大特性(ACID)</h4><ul>\n<li><strong>原子性(Atomicity)</strong><br>事务是数据库的逻辑工作单位,它对数据库的修改要么全部执行,要么全部不执行.</li>\n<li><strong>一致性(Consistemcy)</strong><br>事务前后,数据库的状态都满足所有的完整性约束</li>\n<li><strong>隔离性(lsolation)</strong><br>并发执行的事务是隔离的,一个不影响一个.如果有两个事务,运行在相同的时间内,执行相同的功能,事务的隔离性将确保每一事务在系统中认为只有该事物在使用系统. 这种属性有时称为串行化,为了防止事务操作间的混淆,必须串行化或序列化请求,使得在同一时间仅有y一个请求用于统一数据.通过设置数据库的<strong>隔离级别</strong>,可以达到不同的隔离效果.</li>\n<li>持久性(Durability)<br>在事务完成后,该事务所对数据库所作的更改便持久的保存在数据库之中,并不会被回滚.</li>\n</ul>\n<h4 id=\"并发事务引起的问题\"><a href=\"#并发事务引起的问题\" class=\"headerlink\" title=\"并发事务引起的问题\"></a>并发事务引起的问题</h4><ul>\n<li><p><strong>更新丢失</strong><br>两个事务都同时更新一行数据，但是第二个事务却中途失败退出，导致对数据的两个修改都失效了。这是因为系统没有执行任何的锁操作，因此并发事务并没有被隔离开来。</p>\n</li>\n<li><p><strong>脏读</strong><br>脏读又称无效数据读出。一个事务读取另外一个事务还没有提交的数据叫脏读。<br>例如：事务T1修改了一行数据，但是还没有提交，这时候事务T2读取了被事务T1修改后的数据，之后事务T1因为某种原因Rollback了，那么事务T2读取的数据就是脏的。</p>\n</li>\n</ul>\n<h2 id=\"设计题-系统题\"><a href=\"#设计题-系统题\" class=\"headerlink\" title=\"设计题/系统题\"></a>设计题/系统题</h2><h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\".\"></a>.</h3><h4 id=\"设计一个ID分配器\"><a href=\"#设计一个ID分配器\" class=\"headerlink\" title=\"[]设计一个ID分配器\"></a>[]设计一个ID分配器</h4><h4 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\".\"></a>.</h4><h2 id=\"技术无关\"><a href=\"#技术无关\" class=\"headerlink\" title=\"技术无关\"></a>技术无关</h2><h3 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\".\"></a>.</h3><h4 id=\"能抗住压力么\"><a href=\"#能抗住压力么\" class=\"headerlink\" title=\"能抗住压力么\"></a>能抗住压力么</h4><p>答:作为应届生,本就应该吃苦耐劳学技术,人都是逼出来的,有压力才有动力,这点压力不算什么.</p>\n<h4 id=\"有女朋友么\"><a href=\"#有女朋友么\" class=\"headerlink\" title=\"有女朋友么\"></a>有女朋友么</h4><p>答: 没有,一心向学,不找女朋友浪费时间.(TM是找不到好不2333)</p>\n<h4 id=\"你有什么问题吗\"><a href=\"#你有什么问题吗\" class=\"headerlink\" title=\"你有什么问题吗\"></a>你有什么问题吗</h4><ol>\n<li>这个岗位做的主要业务是什么</li>\n<li>岗位的技术栈</li>\n<li>招这个岗位的校招或者实习生更看重哪方面的能力</li>\n</ol>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjnyhsxma0002as1oejv9mei7","tag_id":"cjnyhsxmh0004as1oiccbayff","_id":"cjnyhsxmo0007as1o524s43qi"},{"post_id":"cjnyhsxmf0003as1oatnp6p59","tag_id":"cjnyhsxmn0006as1ogwx29h9w","_id":"cjnyhsxmq0009as1oygoinmz3"},{"post_id":"cjnyhsxmk0005as1on4yddivs","tag_id":"cjnyhsxmp0008as1ovskkc90f","_id":"cjnyhsxms000aas1o0cpolb54"},{"post_id":"cjnyhsxn3000bas1o7odn97ek","tag_id":"cjnyhsxn4000cas1o1rgvbv3h","_id":"cjnyhsxn5000das1o9252txxu"},{"post_id":"cjnyhsxno000eas1ow90ntrn9","tag_id":"cjnyhsxnv000gas1oie820n9h","_id":"cjnyhsxny000ias1odq5pi8oz"},{"post_id":"cjnyhsxnr000fas1ogy9ykrsm","tag_id":"cjnyhsxnx000has1oypqlu9ve","_id":"cjnyhsxo5000nas1obaji09vn"},{"post_id":"cjnyhsxnr000fas1ogy9ykrsm","tag_id":"cjnyhsxnz000jas1o45q5twr8","_id":"cjnyhsxo5000oas1o0kbzzde0"},{"post_id":"cjnyhsxnr000fas1ogy9ykrsm","tag_id":"cjnyhsxo2000kas1o4uqjqszi","_id":"cjnyhsxo6000pas1objjxcey4"},{"post_id":"cjnyhsxnr000fas1ogy9ykrsm","tag_id":"cjnyhsxo3000las1ov4ok0epb","_id":"cjnyhsxo6000qas1os1ijoqcl"},{"post_id":"cjnyhsxnr000fas1ogy9ykrsm","tag_id":"cjnyhsxo4000mas1olpq5hrts","_id":"cjnyhsxo6000ras1oo550s559"},{"post_id":"cjnyhsxoj000sas1om5yfmpel","tag_id":"cjnyhsxnx000has1oypqlu9ve","_id":"cjnyhsxou000uas1o51hsk4jw"},{"post_id":"cjnyhsxoj000sas1om5yfmpel","tag_id":"cjnyhsxnz000jas1o45q5twr8","_id":"cjnyhsxov000vas1obxzm415k"},{"post_id":"cjnyhsxoj000sas1om5yfmpel","tag_id":"cjnyhsxor000tas1og9voarev","_id":"cjnyhsxow000was1o2vxt8w3m"},{"post_id":"cjnyhsxoj000sas1om5yfmpel","tag_id":"cjnyhsxo3000las1ov4ok0epb","_id":"cjnyhsxow000xas1orxhjirzg"},{"post_id":"cjnyhsxoj000sas1om5yfmpel","tag_id":"cjnyhsxo4000mas1olpq5hrts","_id":"cjnyhsxow000yas1oyn4pzpey"}],"Tag":[{"name":"毕业设计","_id":"cjnyhsxmh0004as1oiccbayff"},{"name":"git","_id":"cjnyhsxmn0006as1ogwx29h9w"},{"name":"随笔","_id":"cjnyhsxmp0008as1ovskkc90f"},{"name":"linux","_id":"cjnyhsxn4000cas1o1rgvbv3h"},{"name":"正则表达式","_id":"cjnyhsxnv000gas1oie820n9h"},{"name":"面试","_id":"cjnyhsxnx000has1oypqlu9ve"},{"name":"C++","_id":"cjnyhsxnz000jas1o45q5twr8"},{"name":"数据库","_id":"cjnyhsxo2000kas1o4uqjqszi"},{"name":"操作系统","_id":"cjnyhsxo3000las1ov4ok0epb"},{"name":"计算机网络","_id":"cjnyhsxo4000mas1olpq5hrts"},{"name":"大数据","_id":"cjnyhsxor000tas1og9voarev"}]}}